<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; primer 第11章 关联容器 - pi</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="canpi" /><meta name="description" content="关联容器的元素按照关键字来保存和访问，而顺序容器的元素是按照在容器中的位置来保存和访问 关联容器支持高效的关键字查找和访问 2种关联容器： map" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.74.3 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/cpp/cppprimer_ch11/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.651e6917abb0239242daa570c2bec9867267bbcd83646da5a850afe573347b44.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; primer 第11章 关联容器" />
<meta property="og:description" content="关联容器的元素按照关键字来保存和访问，而顺序容器的元素是按照在容器中的位置来保存和访问 关联容器支持高效的关键字查找和访问 2种关联容器： map" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/cpp/cppprimer_ch11/" />
<meta property="article:published_time" content="2020-03-02T17:07:00+08:00" />
<meta property="article:modified_time" content="2020-03-02T17:07:00+08:00" />
<meta itemprop="name" content="C&#43;&#43; primer 第11章 关联容器">
<meta itemprop="description" content="关联容器的元素按照关键字来保存和访问，而顺序容器的元素是按照在容器中的位置来保存和访问 关联容器支持高效的关键字查找和访问 2种关联容器： map">
<meta itemprop="datePublished" content="2020-03-02T17:07:00+08:00" />
<meta itemprop="dateModified" content="2020-03-02T17:07:00+08:00" />
<meta itemprop="wordCount" content="5449">



<meta itemprop="keywords" content="C&#43;&#43;,C&#43;&#43; primer,读书," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; primer 第11章 关联容器"/>
<meta name="twitter:description" content="关联容器的元素按照关键字来保存和访问，而顺序容器的元素是按照在容器中的位置来保存和访问 关联容器支持高效的关键字查找和访问 2种关联容器： map"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">canpi</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">canpi</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; primer 第11章 关联容器</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-03-02 </span>
        
          <span class="more-meta"> 约 5449 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#使用关联容器">使用关联容器</a></li>
    <li><a href="#关联容器概述">关联容器概述</a>
      <ul>
        <li><a href="#定义关联容器">定义关联容器</a></li>
        <li><a href="#关键字类型的要求">关键字类型的要求</a></li>
        <li><a href="#pair类型">pair类型</a></li>
      </ul>
    </li>
    <li><a href="#关联容器操作">关联容器操作</a>
      <ul>
        <li><a href="#关联容器迭代器">关联容器迭代器</a></li>
        <li><a href="#添加元素">添加元素</a></li>
        <li><a href="#删除元素">删除元素</a></li>
        <li><a href="#map的下标操作">map的下标操作</a></li>
        <li><a href="#访问元素">访问元素</a></li>
        <li><a href="#一个单词转换的map">一个单词转换的map</a></li>
      </ul>
    </li>
    <li><a href="#无序容器">无序容器</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <ul>
<li><code>关联容器</code>的元素按照<code>关键字</code>来保存和访问，而<code>顺序容器</code>的元素是按照在容器中的<code>位置</code>来保存和访问</li>
<li>关联容器支持高效的关键字查找和访问</li>
<li>2种关联容器：
<ul>
<li><code>map</code>中的元素是关键字-值对（<code>key-value对</code>），关键字作为索引，值表示与索引相关的数据</li>
<li><code>set</code>中的元素只包含关键字</li>
</ul>
</li>
<li>8个关联容器：
<ul>
<li>按<code>类型</code>：或者是<code>map</code>，或者是<code>set</code></li>
<li>按<code>关键字能否重复</code>：或者是<code>multi</code>，或者不是</li>
<li>按<code>关键字是否顺序保存</code>：或者是<code>unordered_</code>，或者不是</li>
</ul>
</li>
<li>4个头文件：
<ul>
<li><code>map</code>和<code>multimap</code>定义于<code>map</code>头文件</li>
<li><code>set</code>和<code>multiset</code>定义于<code>set</code>头文件</li>
<li><code>unordered_map</code>和<code>unordered_multimap</code>定义于<code>unordered_map</code>头文件</li>
<li><code>unordered_set</code>和<code>unordered_multiset</code>定义于<code>unordered_set</code>头文件</li>
</ul>
</li>
<li>关联容器类型见表11.1
<img src="../cpp_figs/CPPprimer_ch11-tab_11_1.png" alt="tab_11_1"></li>
</ul>
<h2 id="使用关联容器">使用关联容器</h2>
<ul>
<li><code>map</code>类型常称为<code>关联数组</code>（<code>字典</code>），但其下标不必是整数，且通过关键字而不是位置来查找值</li>
<li><code>set</code>是关键字的简单集合，只想知道一个值是否存在或出现的次数时，很有用</li>
<li>例子：使用map</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span>          <span class="c1">//默认初始化字典
</span><span class="c1"></span><span class="n">string</span> <span class="n">word</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">word</span><span class="p">)</span>
    <span class="o">++</span><span class="n">word_count</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>                 <span class="c1">//关键字存在则递增其值，关键字不存在则初始化其值为0后递增
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">w</span><span class="p">:</span><span class="n">word_count</span><span class="p">)</span>           <span class="c1">//遍历字典元素
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">w</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="s">&#34; occurs &#34;</span><span class="o">&lt;&lt;</span><span class="n">w</span><span class="p">.</span><span class="n">second</span> <span class="c1">//字典元素是pair，其first成员是key，second成员是value
</span><span class="c1"></span>        <span class="o">&lt;&lt;</span><span class="p">((</span><span class="n">w</span><span class="p">.</span><span class="n">second</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="s">&#34; times&#34;</span><span class="o">:</span><span class="s">&#34; time&#34;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>map是模板，使用时必须在模板参数中指定key和value类型。</li>
<li>对map使用key作为下标访问其value，若key不存在则创建一个新元素，其关键字为给定key，值初始化为0</li>
<li>map的元素都是pair类型，<code>pair</code>也是模板，保存两个public数据成员（<code>first</code>和<code>second</code>）。map使用的pair的first成员是关键字，second是值</li>
<li>例子：使用set</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span>              <span class="c1">//默认初始化字典
</span><span class="c1"></span><span class="n">set</span><span class="o">&lt;</span><span class="n">stirng</span><span class="o">&gt;</span> <span class="n">exclude</span><span class="o">=</span><span class="p">{</span><span class="s">&#34;The&#34;</span><span class="p">,</span><span class="s">&#34;But&#34;</span><span class="p">,</span><span class="s">&#34;And&#34;</span><span class="p">};</span>    <span class="c1">//列表初始化集合
</span><span class="c1"></span><span class="n">string</span> <span class="n">word</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">word</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">exclude</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="o">==</span><span class="n">exclude</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>   <span class="c1">//在集合中查找元素，返回迭代器若为end则未找到
</span><span class="c1"></span>        <span class="o">++</span><span class="n">word_count</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>set是模板，使用时必须在模板参数中指定元素类型</li>
<li>可以对关联容器（set和map都可）做<code>列表初始化</code></li>
<li>set的<code>find</code>方法返回一个迭代器，若给定关键字在set中则返回指向它的迭代器，否则返回end</li>
</ul>
<h2 id="关联容器概述">关联容器概述</h2>
<ul>
<li>所有关联容器都支持表9.2中的通用容器操作，但不支持顺序容器特有的操作</li>
<li>关联容器的迭代器都是<code>双向迭代器</code></li>
</ul>
<h3 id="定义关联容器">定义关联容器</h3>
<ul>
<li>定义map时需在模板参数中给出key和value的类型，定义set时需在模板参数中给出关键字类型</li>
<li>定义关联容器的4种方法：
<ul>
<li>关联容器都有<code>默认构造函数</code>，生成空容器</li>
<li>可将关联容器初始化为另一个<code>同类型容器的拷贝</code></li>
<li>可用<code>元素范围初始化</code>关联容器，只要这些元素可转换为关联容器所需类型</li>
<li>C++11允许对关联容器使用值初始化（<code>列表初始化</code>）</li>
</ul>
</li>
<li>对map做列表初始化时，每个元素也是一个花括号列表，其中包含两个值</li>
<li>map和set的关键字必唯一，但multimap和multiset允许多个元素有相同关键字</li>
</ul>
<h3 id="关键字类型的要求">关键字类型的要求</h3>
<ul>
<li>set的关键字就是元素，map的关键字是元素的first成员</li>
<li>对于有序关联容器（map、multimap、set、multiset），关键字类型必须有序，默认使用元素类型的<code>&lt;</code>算符。</li>
<li>可提供自定义操作代替<code>&lt;</code>算符，要求自定义操作在关键字类型上定义<code>严格弱序</code>：
<ul>
<li>两关键字不能同时“小于等于”对方</li>
<li>“小于等于”具有传递性</li>
<li>若两关键字都不“小于等于”对方，则称为“等价”，“等价”具有传递性</li>
</ul>
</li>
<li>若两关键字等价，则关联容器认为它们相等。用作map的key时，只能有一个value与这两个key关联，用任一个key访问都得到这个value</li>
<li>若使用自定义的严格弱序函数，则定义关联容器时，必须在模板参数中给出<code>该函数指针类型</code>，在构造函数参数中给出<code>该函数</code></li>
<li>例子：自定义严格弱序</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//定义严格弱序
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">compareIsbn</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span><span class="o">&lt;</span><span class="n">rhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">using</span> <span class="n">SalesSetType</span><span class="o">=</span><span class="n">multiset</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="p">,</span><span class="k">decltype</span><span class="p">(</span><span class="n">compareIsbn</span><span class="p">)</span> <span class="o">*&gt;</span><span class="p">;</span>    <span class="c1">//自定义了严格弱序的multiset类型
</span><span class="c1"></span><span class="n">SalesSetType</span> <span class="nf">bookstore</span><span class="p">(</span><span class="n">compareIsbn</span><span class="p">);</span>                                <span class="c1">//自定义了严格弱序的multiset对象
</span></code></pre></td></tr></table>
</div>
</div><h3 id="pair类型">pair类型</h3>
<ul>
<li><code>pair</code>类型定义于<code>utility</code>头文件中</li>
<li>一个pair保存两个public的数据成员，分别叫first和second</li>
<li>pair是模板，创建时需在模板参数中指定两个数据成员的类型</li>
<li>pair的默认构造函数对数据成员做<code>值初始化</code></li>
<li>pair的操作在表11.2
<img src="../cpp_figs/CPPprimer_ch11-tab_11_2.png" alt="tab_11_2"></li>
<li>可用<code>make_pair</code>函数和auto来创建pair，其类型由传入make_pair的实参（即pair的两个成员）推出</li>
<li>C++11中可用返回值做列表初始化</li>
<li>例子：返回值做列表初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">process</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">size</span><span class="p">()};</span>  <span class="c1">//列表初始化返回值
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="k">return</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>          <span class="c1">//隐式构造返回值
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="关联容器操作">关联容器操作</h2>
<ul>
<li>关联容器独有的类型别名见表11.3
<img src="../cpp_figs/CPPprimer_ch11-tab_11_3.png" alt="tab_11_3"></li>
<li>对于set，其<code>key_type</code>和<code>value_type</code>都是元素类型，即关键字类型。它没有<code>mapped_type</code></li>
<li>对于map，其<code>key_type</code>是关键字类型，<code>mapped_type</code>是值类型，<code>value_type</code>是key-value对的pair类型</li>
<li><code>不可改变关键字</code>，故关键字类型都是const：
<ul>
<li>set的<code>key_type</code>和<code>value_type</code>都是const</li>
<li>map的<code>key_type</code>和<code>value_type.first</code>都是const</li>
</ul>
</li>
<li>使用这些类型别名时，需用作用域指明容器类型，例如<code>map&lt;string,int&gt;::key_type</code></li>
</ul>
<h3 id="关联容器迭代器">关联容器迭代器</h3>
<ul>
<li>迭代器解引用
<ul>
<li>解引用关联容器迭代器时，得到一个类型为容器的<code>value_type</code>的引用。</li>
<li>set迭代器解引用得到的都是关键字引用，故都是常量引用。虽然同时存在iterator和const_iterator类型，但都不可写</li>
<li>map迭代器解引用得到的是pair的引用，first为const。其iterator可写second，const_iterator不可写</li>
</ul>
</li>
<li>map和set都有<code>begin</code>和<code>end</code>成员函数，可得到迭代器用于遍历元素</li>
<li>关联容器很少使用<code>泛型算法</code>
<ul>
<li>通常不对关联容器使用泛型算法。因为关键字是const，元素不可改变也不可重排。</li>
<li>关联容器只可使用只读算法，但这些算法在关联容器中搜索时效率低下。例如用关联容器的<code>find成员函数</code>比<code>泛型find函数</code>快得多</li>
<li>如果真要对关联容器使用泛型算法，则只能把它当源序列，或当目的位置用inserter插入</li>
</ul>
</li>
</ul>
<h3 id="添加元素">添加元素</h3>
<ul>
<li>关联容器的<code>insert</code>成员函数向容器中添加一个元素或元素范围</li>
<li>关联容器的insert/emplace操作见表11.4
<img src="../cpp_figs/CPPprimer_ch11-tab_11_4.png" alt="tab_11_4"></li>
<li>对于无重复关键字的map和set，若插入元素的key在容器中已存在，则插入失败，insert不做任何事</li>
<li>insert有两个版本
<ul>
<li>接受一对迭代器，这些迭代器指向的类型可转为该容器的value_type</li>
<li>接受initializer_list，即花括号列表，该列表用于构造一个value_type</li>
</ul>
</li>
<li>例子：对map进行insert的4种方法</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">word</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>                                <span class="c1">//花括号列表转为initializer_list
</span><span class="c1"></span><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>                       <span class="c1">//make_pair函数生成pair
</span><span class="c1"></span><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>             <span class="c1">//显式构造pair
</span><span class="c1"></span><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">size_t</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>  <span class="c1">//显式构造value_type
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>insert/emplace的返回值依赖于容器类型和参数</li>
<li>向set/map添加单一元素，则insert/emplace返回一个pair，其first为迭代器，second为bool。
<ul>
<li>若关键字不在容器中，则插入。first指向插入的元素，second为true</li>
<li>若关键字在容器中，则插入失败。first指向给定元素，second为false</li>
</ul>
</li>
<li>向multiset/multimap添加单一元素，总是插入成功，insert/emplace返回一个迭代器指向插入的元素</li>
<li>例子：对map做insert</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span>
<span class="n">string</span> <span class="n">word</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">word</span><span class="p">){</span>
    <span class="c1">//ret的类型是pair&lt;map&lt;string,size_t&gt;::iterator,bool&gt;
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">ret</span><span class="o">=</span><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">word</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>   <span class="c1">//尝试插入关键字和初始计数值1
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">.</span><span class="n">second</span><span class="p">)</span>                         <span class="c1">//如果插入失败，说明关键字已存在，只需将值递增
</span><span class="c1"></span>        <span class="o">++</span><span class="n">ret</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>                <span class="c1">//ret.first指向插入的元素，其second是值
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="删除元素">删除元素</h3>
<ul>
<li>关联容器定义了3个版本的<code>erase</code>，如表11.5
<img src="../cpp_figs/CPPprimer_ch11-tab_11_5.png" alt="tab_11_5"></li>
<li>关联容器的特殊erase操作：可提供一个关键字，删除与其相关的所有元素，并返回删除元素的数量。对于关键字不重复的容器，erase总返回0或1</li>
</ul>
<h3 id="map的下标操作">map的下标操作</h3>
<ul>
<li>map和unordered_map的下标操作如表11.6：
<img src="../cpp_figs/CPPprimer_ch11-tab_11_6.png" alt="tab_11_6"></li>
<li>只适用于关键字不可重复的map容器：
<ul>
<li>map和unordered_map都有下标算符和at函数</li>
<li>multimap和unordered_multimap都不支持下标，因为一个关键字可能有多个值</li>
<li>所有的set类型都不支持下标，因为没有值</li>
</ul>
</li>
<li>map/unordered_map下标接受一个关键字，访问与其关联的值。若关键字不在容器中，则创建元素插入容器，关联值进行<code>值初始化</code></li>
<li>例子：map用下标插入元素时值初始化为0</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span>
<span class="n">word_count</span><span class="p">[</span><span class="s">&#34;Anna&#34;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="cm">/*上一行的操作步骤：
</span><span class="cm"> *1、容器中搜索关键字&#34;Anna&#34;，未找到
</span><span class="cm"> *2、创建新key-value对，key是const string，value被值初始化为0
</span><span class="cm"> *3、提取新插入的元素，为其赋值为1
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>由于下标可能插入新元素，故只可对非const的map/unordered_map使用下标</li>
<li>通常解引用迭代器和下标返回的类型一样，但map/unordered_map不一样，它们解引用迭代器得到<code>value_type</code>，下标得到<code>mapped_type</code></li>
<li>map的下标返回<code>左值</code></li>
</ul>
<h3 id="访问元素">访问元素</h3>
<ul>
<li>在关联容器中查找元素的方法如表11.7
<img src="../cpp_figs/CPPprimer_ch11-tab_11_7.png" alt="tab_11_7"></li>
<li><code>find</code>判断一个关键字是否在容器中，若在则返回指向第一个key相同的元素的迭代器，否则返回end</li>
<li><code>count</code>返回容器中有多少个相同的给定关键字</li>
<li>查找时应用find而不是下标，因为下标的副作用会导致元素未找到时插入，即改变容器</li>
<li>若multiset/multimap中有重复关键字，则它们<code>相邻存放</code>，因此可找到第一个，然后递增迭代器</li>
<li><code>lower_bound</code>和<code>upper_bound</code>成员函数查找范围：
<ul>
<li>若给定关键字在容器中，则lower_bound返回第一个匹配元素的迭代器，upper_bound返回最后一个匹配元素之后的迭代器</li>
<li>若给定关键字不在容器中，则lower_bound和upper_bound都返回指向第一个大于该关键字的元素的迭代器，该位置称为<code>安全插入点</code>，即在此处insert该关键字可保持容器中关键字的顺序</li>
<li>lower_bound和upper_bound都不支持无序容器</li>
</ul>
</li>
<li><code>equal_range</code>成员函数相当于用同样的关键字调用lower_bound和upper_bound，它返回一个迭代器pair。
<ul>
<li>若关键字在容器中，则first是指向第一个匹配元素的迭代器，second是指向最后一个匹配元素之后的迭代器</li>
<li>若关键字不在容器中，则返回指向第一个大于该关键字的元素的迭代器，即安全插入点</li>
</ul>
</li>
<li>例子：关联容器查找元素</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">multimap</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">authors</span><span class="p">;</span>
<span class="n">authors</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;Barth, John&#34;</span><span class="p">,</span><span class="s">&#34;Sot-Weed Factor&#34;</span><span class="p">});</span>
<span class="n">authors</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;Barth, John&#34;</span><span class="p">,</span><span class="s">&#34;Lost in the Funhouse&#34;</span><span class="p">});</span>
<span class="n">string</span> <span class="nf">search_item</span><span class="p">(</span><span class="s">&#34;Alain de Botton&#34;</span><span class="p">);</span>
<span class="c1">//法1：用find查找迭代器，count计数
</span><span class="c1"></span><span class="k">auto</span> <span class="n">entries</span><span class="o">=</span><span class="n">authors</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">search_item</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">iter</span><span class="o">=</span><span class="n">authors</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">search_item</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="n">entries</span><span class="p">){</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="o">++</span><span class="n">iter</span><span class="p">;</span>
    <span class="o">--</span><span class="n">entries</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//法2：用lower_bound和upper_bound查找范围
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">beg</span><span class="o">=</span><span class="n">ahthors</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">search_item</span><span class="p">),</span><span class="n">end</span><span class="o">=</span><span class="n">ahthors</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">search_item</span><span class="p">);</span>
    <span class="n">beg</span><span class="o">!=</span><span class="n">end</span><span class="p">;</span><span class="o">++</span><span class="n">beg</span><span class="p">)</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">beg</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">//法3：用equal_range查找范围
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">pos</span><span class="o">=</span><span class="n">authors</span><span class="p">.</span><span class="n">equal_range</span><span class="p">(</span><span class="n">search_item</span><span class="p">);</span>
    <span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="o">!=</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="o">++</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="一个单词转换的map">一个单词转换的map</h3>
<ul>
<li>例子：给定缩写对照表和需要转换的文本，输出转换后的文本<br>
//缩写对照表示例：<br>
brb be right back<br>
k okay?<br>
y why<br>
r are<br>
u you<br>
pic picture<br>
thk thanks!<br>
l8r later<br>
//要转换文本示例：<br>
where r u<br>
y dont u send me a pic<br>
k thk l8r<br>
//转换后的文本：<br>
where are you<br>
why dont you send me a picture<br>
okay? thanks! later</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//读取对照表，存为字典
</span><span class="c1"></span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">buildMap</span><span class="p">(</span><span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">map_file</span><span class="p">){</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">trans_map</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">map_file</span><span class="o">&gt;&gt;</span><span class="n">key</span> <span class="o">&amp;&amp;</span> <span class="n">getline</span><span class="p">(</span><span class="n">map_file</span><span class="p">,</span><span class="n">value</span><span class="p">))</span> <span class="c1">//利用&amp;&amp;的执行顺序，先读一个单词，再取剩下的一行
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>                          <span class="c1">//若转换规则存在
</span><span class="c1"></span>            <span class="n">trans_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">value</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>         <span class="c1">//取子串，忽略getline读到的第一个空格
</span><span class="c1"></span>        <span class="k">else</span>
            <span class="k">throw</span> <span class="nf">runtime_error</span><span class="p">(</span><span class="s">&#34;no rule for &#34;</span><span class="o">+</span><span class="n">key</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">trans_map</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//转换单个词语
</span><span class="c1"></span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">transform</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">map_it</span><span class="o">=</span><span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">//在字典中查找
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">map_it</span><span class="o">!=</span><span class="n">m</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span>    <span class="c1">//不等于end则查找到
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">map_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//读取对照表和输入，打印输出
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">word_transform</span><span class="p">(</span><span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">map_file</span><span class="p">,</span> <span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">trans_map</span><span class="o">=</span><span class="n">buildMap</span><span class="p">(</span><span class="n">map_file</span><span class="p">);</span>          <span class="c1">//对照表生成字典
</span><span class="c1"></span>    <span class="n">string</span> <span class="n">text</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="n">text</span><span class="p">)){</span>                 <span class="c1">//逐行处理
</span><span class="c1"></span>        <span class="n">istringstream</span> <span class="n">stream</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>             <span class="c1">//一行字符串作为一个流处理
</span><span class="c1"></span>        <span class="n">string</span> <span class="n">word</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">firstword</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">stream</span><span class="o">&gt;&gt;</span><span class="n">word</span><span class="p">){</span>                    <span class="c1">//逐个单词处理
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">firstword</span><span class="p">)</span>   <span class="n">firstword</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>    <span class="c1">//如果不是第一个单词，则输出之前打印空格
</span><span class="c1"></span>            <span class="k">else</span>            <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
            <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">transform</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="n">trans_map</span><span class="p">);</span>    <span class="c1">//转换单词
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="无序容器">无序容器</h2>
<ul>
<li>C++11定义了4个无序关联容器，它们组织元素的方式不是关键字的序，而是<code>哈希函数</code>和<code>==</code>算符</li>
<li>使用无序容器的情形：
<ul>
<li>关键字不存在序</li>
<li>维护关键字的序代价较高</li>
</ul>
</li>
<li>无序容器在存储上组织为一组<code>桶</code>，每个桶中保存0个或多个元素。即，层次化的存储</li>
<li>无序容器使用一个<code>哈希函数</code>，将关键字映射到桶。访问元素时先计算关键字的哈希值来判断在哪个桶中，再在桶内搜索。</li>
<li><code>哈希值</code>相同的关键字放在同一桶中，因此关键字相同的元素都在同一桶中</li>
<li>无序容器的性能依赖于：哈希函数的质量、桶数量、桶大小</li>
<li>C++允许查询无序容器的状态，并可改变映射和存储的策略，管理桶的函数如表11.8：
<img src="../cpp_figs/CPPprimer_ch11-tab_11_8.png" alt="tab_11_8"></li>
<li>默认情况下，无序容器用关键字类型的<code>==</code>算符比较元素，用hash<code>&lt;key_type&gt;</code>类型的对象来生成元素的哈希值。</li>
<li>标准库为<code>内置类型(包括指针)</code>、<code>string</code>、<code>智能指针</code>提供了hash函数，因此可直接定义这些类型为无序容器的关键字</li>
<li>无序容器可使用自定义的==算符和哈希函数，只需在模板参数中给出函数指针类型，并在构造函数参数中给出函数指针即可</li>
<li>对于有==算符的类型，可以只自定义哈希函数</li>
<li>例子：自定义==算符和哈希函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//定义哈希函数
</span><span class="c1"></span><span class="n">size_t</span> <span class="nf">hasher</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">sd</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">sd</span><span class="p">.</span><span class="n">isbn</span><span class="p">());</span> <span class="c1">//用一个成员的哈希作为该类的哈希
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//定义==算符
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">eqOp</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span><span class="o">==</span><span class="n">rhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">();</span> <span class="c1">//用一个成员的==算符作为该类的==算符
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//使用自定义的哈希函数和==算符定义类型并初始化
</span><span class="c1"></span><span class="k">using</span> <span class="n">SD_multiset</span><span class="o">=</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">hasher</span><span class="p">)</span> <span class="o">*</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">eqOp</span><span class="p">)</span> <span class="o">*&gt;</span><span class="p">;</span>
<span class="n">SD_multiset</span> <span class="nf">bookstore</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="n">hasher</span><span class="p">,</span><span class="n">eqOp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">canpi</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-03-02
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_wechat.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_alipay.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          <a href="/tags/c&#43;&#43;-primer/">C&#43;&#43; primer</a>
          <a href="/tags/%E8%AF%BB%E4%B9%A6/">读书</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cpp/cppprimer_ch12/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43; primer 第12章 动态内存</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/cpp/cppprimer_ch10/">
            <span class="next-text nav-default">C&#43;&#43; primer 第10章 泛型算法</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/cpp/cppprimer_ch11/" class="leancloud_visitors" data-flag-title="C&#43;&#43; primer 第11章 关联容器">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'ntftaTIdLaT8sVPL9qFX5dAg-gzGzoHsz',
        appKey: 'lNOKznaI2Gnej5D2MgpUJnzV',
        notify:  false ,
        verify:  false ,
        avatar:'retro',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hucanpei@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/hucanpei" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/canpi" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">canpi</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>








</body>
</html>
