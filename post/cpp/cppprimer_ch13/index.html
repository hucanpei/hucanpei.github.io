<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; primer 第13章 拷贝控制 - pi</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="canpi" /><meta name="description" content="定义一个类时，可显式或隐式的指定在此类型对象上拷贝、移动、赋值、销毁时做什么。通过5种成员函数实现拷贝控制操作： 拷贝构造函数：用同类型的另一" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.67.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/cpp/cppprimer_ch13/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.78f8f17bab244b9ee62ad16480c9584d5fc2db06ae20681d1ca225cefd80767c.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; primer 第13章 拷贝控制" />
<meta property="og:description" content="定义一个类时，可显式或隐式的指定在此类型对象上拷贝、移动、赋值、销毁时做什么。通过5种成员函数实现拷贝控制操作： 拷贝构造函数：用同类型的另一" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/cpp/cppprimer_ch13/" />
<meta property="article:published_time" content="2020-03-15T16:30:00+08:00" />
<meta property="article:modified_time" content="2020-03-15T16:30:00+08:00" />
<meta itemprop="name" content="C&#43;&#43; primer 第13章 拷贝控制">
<meta itemprop="description" content="定义一个类时，可显式或隐式的指定在此类型对象上拷贝、移动、赋值、销毁时做什么。通过5种成员函数实现拷贝控制操作： 拷贝构造函数：用同类型的另一">
<meta itemprop="datePublished" content="2020-03-15T16:30:00&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-15T16:30:00&#43;08:00" />
<meta itemprop="wordCount" content="15446">



<meta itemprop="keywords" content="C&#43;&#43;,C&#43;&#43; primer,读书," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; primer 第13章 拷贝控制"/>
<meta name="twitter:description" content="定义一个类时，可显式或隐式的指定在此类型对象上拷贝、移动、赋值、销毁时做什么。通过5种成员函数实现拷贝控制操作： 拷贝构造函数：用同类型的另一"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">canpi</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">canpi</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; primer 第13章 拷贝控制</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-03-15 </span>
        
          <span class="more-meta"> 约 15446 字 </span>
          <span class="more-meta"> 预计阅读 31 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#拷贝赋值与销毁">拷贝、赋值与销毁</a>
      <ul>
        <li><a href="#拷贝构造函数">拷贝构造函数</a></li>
        <li><a href="#拷贝赋值运算符">拷贝赋值运算符</a></li>
        <li><a href="#析构函数">析构函数</a></li>
        <li><a href="#三五法则">三/五法则</a></li>
        <li><a href="#使用default">使用=default</a></li>
        <li><a href="#阻止拷贝">阻止拷贝</a></li>
      </ul>
    </li>
    <li><a href="#拷贝控制和资源管理">拷贝控制和资源管理</a>
      <ul>
        <li><a href="#行为像值的类">行为像值的类</a></li>
        <li><a href="#定义行为像指针的类">定义行为像指针的类</a></li>
      </ul>
    </li>
    <li><a href="#交换操作">交换操作</a></li>
    <li><a href="#拷贝控制示例">拷贝控制示例</a></li>
    <li><a href="#动态内存管理类">动态内存管理类</a></li>
    <li><a href="#对象移动">对象移动</a>
      <ul>
        <li><a href="#右值引用">右值引用</a></li>
        <li><a href="#移动构造函数和移动赋值运算符">移动构造函数和移动赋值运算符</a></li>
        <li><a href="#右值引用和成员函数">右值引用和成员函数</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <ul>
<li>定义一个类时，可显式或隐式的指定在此类型对象上<code>拷贝</code>、<code>移动</code>、<code>赋值</code>、<code>销毁</code>时做什么。通过5种<code>成员函数</code>实现<code>拷贝控制</code>操作：
<ul>
<li><code>拷贝构造函数</code>：用同类型的另一个对象初始化本对象时做什么（拷贝初始化）</li>
<li><code>拷贝赋值算符</code>：将同类型的另一个对象赋值给本对象时做什么（拷贝赋值）</li>
<li><code>移动构造函数</code>：用同类型的另一个对象初始化本对象时做什么（移动初始化）</li>
<li><code>移动赋值算符</code>：将同类型的另一个对象赋值给本对象时做什么（移动赋值）</li>
<li><code>析构函数</code>：本对象销毁时做什么（析构）</li>
</ul>
</li>
<li>如果类未定义这些拷贝控制成员，编译器会自动合成一部分缺失的操作，因此很多类不需要自定义拷贝控制。最困难的经常是认识到什么时候需要自定义拷贝控制：编译器合成版本的行为可能并非预期。</li>
</ul>
<h2 id="拷贝赋值与销毁">拷贝、赋值与销毁</h2>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<ul>
<li><code>拷贝构造函数</code>：这种构造函数的第一个参数是<code>自身类类型的引用</code>，且任何额外参数都有默认值。</li>
<li>拷贝构造函数的第一个参数必须是引用类型（否则传参时需要拷贝，循环调用）。虽然也可定义为非const，但几乎总是用<code>const引用</code>（不会改变被拷贝对象，且const引用能接受更多类型的参数）。</li>
<li>拷贝构造函数经常会被隐式使用（例如函数的传参和返回值），故不应该是<code>explicit</code></li>
<li>若未自定义拷贝构造函数，即使定义了其他构造函数，编译器也会合成一个拷贝构造函数（这一点与默认构造函数不同）</li>
<li><code>合成的拷贝构造函数</code>若非删除，则会将其参数的非static成员逐个拷贝到正在构造的对象中：
<ul>
<li>内置类型：直接拷贝</li>
<li>类类型：用拷贝构造函数来拷贝</li>
<li>数组：逐元素拷贝（若元素是类类型，也用拷贝构造函数）</li>
</ul>
</li>
<li>例子：合成的拷贝构造函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Sales_data</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//拷贝构造函数，参数是该类类型的引用，经常是const引用
</span><span class="c1"></span>    <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">bookNo</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">units_sold</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">revenue</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//与合成的拷贝构造函数等价，逐个拷贝成员
</span><span class="c1"></span><span class="n">Sales_data</span><span class="o">::</span><span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">orig</span><span class="p">)</span><span class="o">:</span>
                      <span class="n">bookNo</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">bookNo</span><span class="p">),</span>
                      <span class="n">units_sold</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">units_sold</span><span class="p">),</span>
                      <span class="n">revenue</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">revenue</span><span class="p">)</span>
                      <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>直接初始化和拷贝初始化的差别：
<ul>
<li><code>直接初始化</code>：要求编译器使用普通函数匹配来选择最匹配的构造函数</li>
<li><code>拷贝初始化</code>：要求编译器将<code>=</code>右侧运算对象拷贝到正在创建的对象中，需要时可进行隐式转换</li>
</ul>
</li>
<li>例子：直接初始化和拷贝初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">dots</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="sc">&#39;.&#39;</span><span class="p">);</span>                <span class="c1">//直接初始化
</span><span class="c1"></span><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="n">dots</span><span class="p">);</span>                     <span class="c1">//直接初始化
</span><span class="c1"></span><span class="n">string</span> <span class="n">s2</span><span class="o">=</span><span class="n">dots</span><span class="p">;</span>                     <span class="c1">//拷贝初始化
</span><span class="c1"></span><span class="n">string</span> <span class="n">null_book</span><span class="o">=</span><span class="s">&#34;9-999-99999-9&#34;</span><span class="p">;</span>   <span class="c1">//拷贝初始化，发生C风格字符串到const string的隐式转换（临时量）
</span><span class="c1"></span><span class="n">string</span> <span class="n">nines</span><span class="o">=</span><span class="n">string</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="sc">&#39;9&#39;</span><span class="p">);</span>       <span class="c1">//拷贝初始化
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>拷贝初始化的工具：
<ul>
<li><code>拷贝构造函数</code>：通常使用拷贝构造函数</li>
<li><code>移动构造函数</code>：如果该类有移动构造函数且用<code>右值</code>调用时</li>
</ul>
</li>
<li>拷贝初始化发生的情况:
<ul>
<li>用<code>=</code>定义变量</li>
<li>将对象作为实参传递给非引用类型的形参</li>
<li>从返回类型非引用的函数返回对象</li>
<li>用花括号列表初始化一个数组的元素或一个聚合类的成员</li>
<li>某些类类型会对其分配的对象使用拷贝初始化。例如初始化标准库容器或是调用<code>insert</code>/<code>push</code>时容器对元素进行拷贝初始化，而用<code>emplace</code>是对元素直接初始化</li>
</ul>
</li>
<li>使用explicit的构造函数时，只能直接构造，不能拷贝构造（即，explicit的构造函数不可用于拷贝构造）</li>
<li>传递实参或返回值时，不能隐式使用explicit构造函数，必须显式使用</li>
<li>例子：explicit的构造函数不可用于拷贝构造</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>     <span class="c1">//对，直接初始化
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>      <span class="c1">//错，vector的接受大小的构造函数是explicit
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>    <span class="c1">//f的参数非引用，需拷贝初始化
</span><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>                  <span class="c1">//错，int不可拷贝为vector
</span><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>     <span class="c1">//对，从int直接构造临时vector
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>拷贝初始化时，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。但即使编译器跳过拷贝/移动构造函数，他们仍必须是存在且可访问的（例如不能是private）</li>
<li>例子：跳过拷贝/移动构造函数，直接创建</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//编译器允许将上一行代码改写为下面一行，直接构造。
</span><span class="c1"></span><span class="n">string</span> <span class="n">null_book</span><span class="o">=</span><span class="s">&#34;9-999-99999-9&#34;</span><span class="p">;</span>   <span class="c1">//拷贝初始化
</span><span class="c1"></span><span class="n">string</span> <span class="nf">null_book</span><span class="p">(</span><span class="s">&#34;9-999-99999-9&#34;</span><span class="p">);</span>  <span class="c1">//跳过拷贝构造函数，直接构造
</span></code></pre></td></tr></table>
</div>
</div><h3 id="拷贝赋值运算符">拷贝赋值运算符</h3>
<ul>
<li>类可通过拷贝构造函数来控制初始化，也可通过<code>拷贝赋值算符</code>来控制对象赋值</li>
<li><code>重载算符</code>本质上是函数，其名字是<code>operator</code>关键字后接要定义的算符的符号。</li>
<li>赋值算符是名为<code>operator=</code>的函数，它也有返回类型和参数列表</li>
<li>某些算符，包括赋值算符，必须定义为成员函数。若算符是成员函数，则其<code>左侧对象</code>隐式绑定到this指针。对于二元算符，例如赋值算符，其<code>右侧对象</code>作为显式参数传递。</li>
<li>拷贝赋值算符接受一个与其所在类型相同的参数，返回左侧运算对象的引用（为与内置类型的赋值保持一致）。</li>
<li>标准库通常要求容器元素的类型有赋值算符，且返回值是左侧对象的引用，因为很多操作会拷贝元素。</li>
<li>若未自定义拷贝赋值算符，编译器会合成一个</li>
<li><code>合成的拷贝赋值算符</code>若非删除，则会将右侧对象的每个非static成员赋予左侧对象的对应成员（类类型成员调用拷贝赋值算符，数组成员逐个赋值）。它返回一个指向左侧对象的引用</li>
<li>例子：合成拷贝赋值算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Sales_data</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//拷贝赋值算符，参数是该类类型的引用，经常是const引用，返回该类类型的引用
</span><span class="c1"></span>    <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">Sales_data</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">bookNo</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">units_sold</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">revenue</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//左侧对象隐式绑定到返回的this，引用类型。右侧对象是传入参数，常量引用类型
</span><span class="c1"></span><span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">Sales_data</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="n">bookNo</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">bookNo</span><span class="p">;</span>
    <span class="n">units_sold</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">units_sold</span><span class="p">;</span>
    <span class="n">revenue</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">revenue</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="析构函数">析构函数</h3>
<ul>
<li>析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员并执行函数体，析构函数执行函数体并销毁对象的非static数据成员</li>
<li><code>析构函数</code>的名字是波浪线<code>~</code>后接类名，它没有返回值也不接受参数，故不可重载，一个类只能有一个析构函数</li>
<li>构造函数和析构函数的共性和差异：
<ul>
<li>构造函数有一个显式的初值列表和一个函数体；析构函数有一个函数体和一个隐式的析构部分。</li>
<li>构造函数先做成员初始化再执行函数体，成员按照类中出现的顺序初始化；析构函数先执行函数体再销毁成员，成员按照初始化的逆序销毁。</li>
</ul>
</li>
<li>析构函数的析构部分是隐式的，成员如何销毁完全取决于类型：类类型成员析构时调用析构函数，内置成员析构时什么都不做，特别是，析构内置指针成员不会delete它指向的对象。</li>
<li>对象被销毁时调用析构函数：
<ul>
<li>变量离开作用域被销毁</li>
<li>类对象被销毁时成员被销毁</li>
<li>标准库容器/数组被销毁时，元素被销毁</li>
<li>动态对象的指针被delete时对象被销毁</li>
<li>临时对象，创建它的完整表达式结束时被销毁</li>
</ul>
</li>
<li>析构函数自动运行，故程序可按需分配资源，无需担心何时释放（前提是析构函数良好定义）</li>
<li>例子：析构函数自动运行</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="p">{</span><span class="c1">//进入新作用域
</span><span class="c1"></span>    <span class="n">Sales_data</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="n">Sales_data</span><span class="p">;</span>       <span class="c1">//内置指针
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">p2</span><span class="o">=</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">//智能指针
</span><span class="c1"></span>    <span class="n">Sales_data</span> <span class="nf">item</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>                <span class="c1">//拷贝构造对象
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">p2</span><span class="p">);</span>                 <span class="c1">//拷贝进容器
</span><span class="c1"></span>    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>                           <span class="c1">//管理动态对象的内置指针需手动delete
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//离开作用域，p2、item、vec的析构函数自动运行
</span><span class="c1">//销毁p2会递减其引用计数，计数为0时对象被释放
</span><span class="c1">//销毁vec时其元素也被销毁
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>若未自定义析构函数，编译器会合成一个</li>
<li><code>合成析构函数</code>若非删除，则其函数体为空，只有隐式的析构部分。</li>
<li>析构函数体并不直接销毁成员，成员是在析构函数体执行之后的隐式析构阶段被销毁。</li>
</ul>
<h3 id="三五法则">三/五法则</h3>
<ul>
<li>三个基本操作可控制类的拷贝：<code>拷贝构造函数</code>、<code>拷贝赋值算符</code>、<code>析构函数</code>。C++11中还定义了<code>移动构造函数</code>和<code>移动赋值算符</code></li>
<li>这5个操作不必全部定义，可以只定义一两个。但这些操作经常是一个整体，需要同时定义。</li>
<li><code>需要自定义析构函数的类也需要自定义拷贝和赋值</code></li>
<li>若一个类需要自定义析构函数（如管理动态对象），几乎肯定它也需要自定义拷贝和赋值操作</li>
<li>例子：需要析构函数时使用默认的拷贝和赋值（反例）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">HasPtr</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//构造对象时产生动态对象，其指针作为成员
</span><span class="c1"></span>    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">=</span><span class="n">string</span><span class="p">())</span><span class="o">:</span>
          <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span><span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
          <span class="p">{}</span>
    <span class="c1">//自定义了析构函数来处理动态对象，但未自定义拷贝和赋值。故该类对象的所有拷贝共享动态对象
</span><span class="c1"></span>    <span class="o">~</span><span class="n">HasPtr</span><span class="p">(){</span><span class="k">delete</span> <span class="n">ps</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//定义函数处理该类对象
</span><span class="c1"></span><span class="n">HasPtr</span> <span class="nf">f</span><span class="p">(</span><span class="n">HasPtr</span> <span class="n">hp</span><span class="p">){</span>    <span class="c1">//调用函数时传入指针被拷贝给形参hp，实参和hp共享底层对象
</span><span class="c1"></span>    <span class="n">HasPtr</span> <span class="n">ret</span><span class="o">=</span><span class="n">hp</span><span class="p">;</span>      <span class="c1">//拷贝，默认拷贝操作只拷贝指针，使ret和hp共享底层对象
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>         <span class="c1">//将拷贝返回
</span><span class="c1"></span><span class="p">}</span>                       <span class="c1">//问题1、离开函数作用域时形参hp被销毁，调用析构函数将底层对象释放，实参和ret内的指针都空悬
</span><span class="c1"></span>                        <span class="c1">//问题2、返回类型非引用，故ret传出时拷贝，ret也被销毁，同一底层对象释放两次
</span><span class="c1"></span><span class="n">HasPtr</span> <span class="nf">p</span><span class="p">(</span><span class="s">&#34;some values&#34;</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>                   <span class="c1">//调用后，p中的指针空悬，且p底层的对象被释放两次
</span><span class="c1"></span><span class="n">HasPtr</span> <span class="nf">q</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>            <span class="c1">//p和q的指针都空悬
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>需要自定义拷贝操作的类也需要自定义赋值操作，反之亦然</code></li>
<li>需要自定义拷贝和赋值时，不一定需要自定义析构函数。例如，为类的每个对象生成编号</li>
</ul>
<h3 id="使用default">使用=default</h3>
<ul>
<li>将拷贝控制成员定义为<code>=default</code>可显式要求编译器生成合成的版本。只能对具有合成版本的成员函数使用（构造函数和拷贝控制成员）</li>
<li>例子：使用=default</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Sales_data</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Sales_data</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
    <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
    <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Sales_data</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//=default可在类内定义也可在类外定义
</span><span class="c1"></span><span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">Sales_data</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="阻止拷贝">阻止拷贝</h3>
<ul>
<li>大多数类应该定义默认构造函数、拷贝构造函数、拷贝赋值算符，无论显式还是隐式。但对某些类，这些操作并无意义。例如iostream不可拷贝。</li>
<li>若要阻止一个操作（例如禁止拷贝），不定义是无效的，因为编译器会合成。正确做法是将其定义为删除函数</li>
<li><code>删除函数</code>是这样一种函数：虽然定义了，但不可以任何形式使用。C++11可将拷贝构造函数和拷贝赋值算符定义为删除来阻止拷贝。</li>
<li>定义删除函数的方法是在参数列表后将其定义为<code>=delete</code>，它通知编译器，我们不希望定义这些成员。</li>
<li><code>=delete</code>和<code>=default</code>的区别：
<ul>
<li>=delete必须出现在第一次声明时，而=default只需在定义时给出。因为编译器在函数声明时就必须知道它是否为删除的，以便禁止使用它</li>
<li>=delete可对任意函数使用，而=default只能对编译器能合成的函数使用</li>
</ul>
</li>
<li>不能删除析构函数。若删除析构函数则无法销毁此类型对象。</li>
<li>删除析构函数的情形：
<ul>
<li>对于删除了析构函数的类，编译器不允许对该类型定义变量/临时对象</li>
<li>若类的类类型成员删除了析构函数，则该类也不能定义变量/临时对象。</li>
<li>对于删除了析构函数的类，可以分配该类型的动态对象，只是不能释放</li>
</ul>
</li>
<li>例子：删除析构函数的类可分配动态对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">NoDtor</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">NoDtor</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">NoDtor</span><span class="p">()</span><span class="o">=</span><span class="k">delete</span><span class="p">;</span>   <span class="c1">//删除析构函数
</span><span class="c1"></span><span class="p">};</span>
<span class="n">NoDtor</span> <span class="n">nd</span><span class="p">;</span>              <span class="c1">//错，不可创建变量
</span><span class="c1"></span><span class="n">NoDtor</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="n">NoDtor</span><span class="p">();</span> <span class="c1">//对，可分配动态对象但不可释放
</span><span class="c1"></span><span class="k">delete</span> <span class="n">p</span><span class="p">;</span>               <span class="c1">//错，析构函数是删除的
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>对某些类的某些拷贝控制成员，编译器将合成的成员定义为删除函数。本质上，这些规则的含义是：若类有数据成员不可默认构造、拷贝、赋值、销毁，则该类对应的成员函数被定义为删除：
<ul>
<li>删除合成析构函数：
<ul>
<li>类某成员的析构函数是删除的或不可访问</li>
</ul>
</li>
<li>删除合成拷贝构造函数：
<ul>
<li>类某成员的拷贝构造函数是删除的或不可访问</li>
<li>类某成员的析构函数是删除的或不可访问（可能创建无法销毁的对象）</li>
</ul>
</li>
<li>删除合成拷贝赋值算符：
<ul>
<li>类某成员的拷贝赋值算符是删除的或不可访问</li>
<li>类有const成员或引用成员（可给引用成员赋值，但改变的是底层共享对象，不是期望结果）</li>
</ul>
</li>
<li>删除默认构造函数：
<ul>
<li>类某成员的析构函数是删除的或不可访问</li>
<li>类的引用成员没有类内初始值</li>
<li>类的const成员没有类内初始值且类型未显式定义默认构造函数</li>
</ul>
</li>
</ul>
</li>
<li>C++11之前，阻止拷贝控制的方法是将拷贝构造函数和拷贝赋值算符<code>声明为private且不定义</code>
<ul>
<li>声明为private，保证类外拷贝时在编译期报错</li>
<li>声明但不定义，保证友元和成员函数拷贝时在链接期报错</li>
</ul>
</li>
<li>例子：通过声明为<code>private</code>且不定义来阻止拷贝</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">PrivateCopy</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">PrivateCopy</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">PrivateCopy</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">//将拷贝构造函数和拷贝赋值算符声明为private且不定义，阻止类被拷贝
</span><span class="c1"></span>    <span class="n">PrivateCopy</span><span class="p">(</span><span class="k">const</span> <span class="n">PrivateCopy</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">PrivateCopy</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">PrivateCopy</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>希望阻止拷贝的正经操作是定义拷贝构造函数和拷贝赋值算符为=delete</li>
</ul>
<h2 id="拷贝控制和资源管理">拷贝控制和资源管理</h2>
<ul>
<li>管理类外资源的类通常需要定义拷贝控制成员，因为它需要析构函数来释放资源，几乎肯定也需要拷贝构造函数和拷贝赋值算符</li>
<li><code>拷贝语义</code>：有2种选择，可定义拷贝操作使类的行为看起来像值或指针
<ul>
<li><code>行为像值的类</code>：每个对象有自己的资源。拷贝一个像值的对象时，副本和原对象完全独立。改变副本不会改变原对象，反之亦然。</li>
<li><code>行为像指针的类</code>：所有对象共享资源。拷贝一个像指针的对象时，副本和原对象使用相同的底层数据。改变副本会改变原对象，反之亦然。</li>
</ul>
</li>
<li>标准库容器和string的行为像值，shared_ptr的行为像指针，IO类型和unique_ptr不允许拷贝/赋值故不像值也不像指针</li>
</ul>
<h3 id="行为像值的类">行为像值的类</h3>
<ul>
<li>为了提供类值的行为，对于类管理的资源，每个对象都应有一份拷贝。</li>
<li><code>赋值算符通常组合了析构函数和构造函数的操作</code>（销毁左侧对象类似析构，从右侧对象拷贝/移动类似构造），且应保证执行顺序正确，可处理自赋值。如果可能，还要保证异常安全。
<ul>
<li><code>自赋值安全</code>：先拷贝右侧对象资源，再销毁左侧对象资源</li>
<li><code>异常安全</code>：先分配空间存放临时资源，再改变左侧对象状态</li>
</ul>
</li>
<li>最佳实践：定义赋值算符的步骤：
<ol>
<li>将右侧对象的资源拷贝出来</li>
<li>释放左侧对象的资源</li>
<li>让左侧对象接管从右侧对象拷出的资源</li>
</ol>
</li>
<li>例子：类值版本的HasPtr</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">HasPtr</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//构造时分配动态内存
</span><span class="c1"></span>    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">=</span><span class="n">string</span><span class="p">())</span><span class="o">:</span>
          <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span><span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
          <span class="p">{}</span>
    <span class="c1">//拷贝构造时也分配动态内存并拷贝数据，保证各对象资源独立
</span><span class="c1"></span>    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span><span class="o">:</span>
          <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span><span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">i</span><span class="p">)</span>
          <span class="p">{}</span>
    <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="o">~</span><span class="n">HasPtr</span><span class="p">(){</span><span class="k">delete</span> <span class="n">ps</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//定义拷贝赋值算符，保证自赋值安全、异常安全
</span><span class="c1"></span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">newp</span><span class="o">=</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>  <span class="c1">//1、将右侧对象的资源拷出
</span><span class="c1"></span>    <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>                      <span class="c1">//2、释放左侧对象的资源
</span><span class="c1"></span>    <span class="n">ps</span><span class="o">=</span><span class="n">newp</span><span class="p">;</span>                        <span class="c1">//3、让左侧对象接管拷出的资源
</span><span class="c1"></span>    <span class="n">i</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="定义行为像指针的类">定义行为像指针的类</h3>
<ul>
<li>对于行为像指针的类，需为其定义拷贝构造函数和拷贝赋值算符，来拷贝指针成员本身而不是它管理的底层资源</li>
<li>令一个类行为像指针的最好办法是用<code>shared_ptr</code>来管理类内的资源</li>
<li><code>引用计数</code>的工作方式：
<ul>
<li>每个<code>构造函数</code>（除拷贝构造函数外）都会创建独立的计数器（经常放在动态内存中），记录有多少对象与正在创建的对象共享数据。每个计数器初始化时都为1。</li>
<li><code>拷贝构造函数</code>不创建新的计数器，而是拷贝数据成员（包括指向计数器的指针），并将共享的计数器递增。</li>
<li><code>析构函数</code>递减计数器，若计数为0则销毁底层数据。</li>
<li><code>拷贝赋值算符</code>递增右侧对象的计数，递减左侧对象的计数。若左侧对象计数为0则销毁其底层数据</li>
</ul>
</li>
<li>计数器被保存在动态内存中，每次调用构造函数（除拷贝构造函数外）创建一个对象时都分配新的计数器。拷贝或赋值对象时，拷贝指向计数器的指针，使得副本和原对象共享相同的计数器。</li>
<li>赋值运算必须处理<code>自赋值</code>。实现方式是先递增右侧对象的计数再递减左侧对象的计数（检查是否为0之前递增）</li>
<li>例子：类指针版本的HasPtr，手动实现引用计数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">HasPtr</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//构造函数
</span><span class="c1"></span>    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">=</span><span class="n">string</span><span class="p">())</span><span class="o">:</span>
          <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span><span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">use</span><span class="p">(</span><span class="k">new</span> <span class="n">size_t</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">//动态内存中分配新的底层数据和计数器
</span><span class="c1"></span>          <span class="p">{}</span>
    <span class="c1">//拷贝构造函数
</span><span class="c1"></span>    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span><span class="o">:</span>
          <span class="n">ps</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span><span class="p">),</span><span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">i</span><span class="p">),</span><span class="n">use</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">use</span><span class="p">)</span>                <span class="c1">//拷贝指针，共享底层数据和计数器
</span><span class="c1"></span>          <span class="p">{</span><span class="o">++*</span><span class="n">use</span><span class="p">;}</span>                                 <span class="c1">//递增引用计数
</span><span class="c1"></span>    <span class="c1">//拷贝赋值算符
</span><span class="c1"></span>    <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="c1">//析构函数
</span><span class="c1"></span>    <span class="o">~</span><span class="n">HasPtr</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span> <span class="c1">//底层数据
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">use</span><span class="p">;</span> <span class="c1">//引用计数器
</span><span class="c1"></span><span class="p">};</span>
<span class="c1">//析构函数
</span><span class="c1"></span><span class="n">HasPtr</span><span class="o">::~</span><span class="n">HasPtr</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">--*</span><span class="n">use</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>  <span class="c1">//递减计数器，若递减后为0则释放资源
</span><span class="c1"></span>        <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">use</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//拷贝赋值算符，保证处理自赋值
</span><span class="c1"></span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="o">++*</span><span class="n">rhs</span><span class="p">.</span><span class="n">use</span><span class="p">;</span>     <span class="c1">//1、递增右侧计数器
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">--*</span><span class="n">use</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>  <span class="c1">//2、递减左侧计数器，若递减后为0则释放资源
</span><span class="c1"></span>        <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">use</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ps</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">ps</span><span class="p">;</span>      <span class="c1">//3、将右侧指针拷贝到左侧，共享底层数据和计数器
</span><span class="c1"></span>    <span class="n">i</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
    <span class="n">use</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">use</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="交换操作">交换操作</h2>
<ul>
<li>除定义拷贝控制成员外，管理资源的类通常还需定义<code>swap函数</code>（非成员）。对于与重排元素顺序的算法一起使用的类而言，swap函数很重要。这类算法需要在交换两元素时调用其类型的swap函数。若未自定义swap，则算法调用标准库定义的swap</li>
<li>交换两个对象，需要<code>一次拷贝和两次赋值</code>，即swap建立在拷贝控制之上</li>
<li><code>swap时尽量交换指针</code>，而不是分配新的副本</li>
<li>例子：交换对象时需要一次拷贝和两次赋值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//以下是拷贝值实现swap，假设HasPtr是行为像值的类
</span><span class="c1"></span><span class="n">HasPtr</span> <span class="n">temp</span><span class="o">=</span><span class="n">v1</span><span class="p">;</span>
<span class="n">v1</span><span class="o">=</span><span class="n">v2</span><span class="p">;</span>
<span class="n">v2</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="c1">//以下是拷贝指针实现swap，效率高很多
</span><span class="c1"></span><span class="n">string</span> <span class="o">*</span><span class="n">temp</span><span class="o">=</span><span class="n">v1</span><span class="p">.</span><span class="n">ps</span><span class="p">;</span>
<span class="n">v1</span><span class="p">.</span><span class="n">ps</span><span class="o">=</span><span class="n">v2</span><span class="p">.</span><span class="n">ps</span><span class="p">;</span>
<span class="n">v2</span><span class="p">.</span><span class="n">ps</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>在类中将swap声明为友元函数，即可重载出该类型的swap</li>
<li>自定义swap不是必须的，但对于管理资源的类，自定义swap可能是很重要的优化手段</li>
<li>swap经常被声明为<code>inline</code>以提高性能</li>
<li>例子：自定义swap友元函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">HasPtr</span><span class="p">{</span>
    <span class="c1">//声明为友元以访问private
</span><span class="c1"></span>    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="cm">/* 其他成员定义，与“行为像值的类”相同 */</span>
<span class="p">};</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>        <span class="c1">//允许但不是必须使用std::swap
</span><span class="c1"></span>    <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">ps</span><span class="p">,</span><span class="n">rhs</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>    <span class="c1">//交换底层数据的指针，优先使用匹配的swap
</span><span class="c1"></span>    <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">i</span><span class="p">,</span><span class="n">rhs</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>      <span class="c1">//交换内置类型的成员，优先使用匹配的swap
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>不同版本的swap：
<ul>
<li>对于内置类型，没有特定版本的swap，使用std::swap即可</li>
<li>对于类类型，应使用重载的swap，即使用swap而不是std::swap</li>
</ul>
</li>
<li>最佳实践：<code>using std::swap;</code>允许使用标准库的swap，使用时用<code>swap</code>尽量选择最匹配的自定义swap</li>
<li>定义了swap的类可用<code>swap实现赋值算符</code>，使用<code>拷贝并交换</code>技术，传参时拷贝右侧对象，将左侧对象与右侧对象的形参副本交换。</li>
<li>例子：用swap实现拷贝赋值算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//右侧对象按值传递，传进来时已经拷贝了一次，拷贝到形参rhs
</span><span class="c1"></span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="n">rhs</span><span class="p">){</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="n">rhs</span><span class="p">);</span>    <span class="c1">//交换左侧对象与形参rhs
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>       <span class="c1">//此时this指针指向右侧对象拷贝出的对象，形参rhs是交换前的左侧对象
</span><span class="c1"></span><span class="p">}</span>                       <span class="c1">//离开作用域，rhs（交换前的左侧对象）被销毁
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>“拷贝并交换”技术是<code>自赋值安全</code>且是<code>异常安全</code>的：
<ul>
<li>改变左侧对象之前就拷贝右侧对象，保证自赋值安全</li>
<li>唯一可能抛出异常的是拷贝右侧对象时的new，但这发生在改变左侧对象之前</li>
</ul>
</li>
</ul>
<h2 id="拷贝控制示例">拷贝控制示例</h2>
<ul>
<li>例子：使用拷贝控制进行簿记操作。每个Message可出现在多个Folder中，每个Folder也可容纳多个Message，但每个Message的内容只有一个副本。如图13.1
<img src="../cpp_figs/CPPprimer_ch13-fig_13_1.png" alt="fig_13_1"></li>
<li>具体实现：
<ul>
<li>每个Message保存一条内容和一个它所在的Folder指针的<code>set</code>，每个Folder保存一个它容纳的Message指针的<code>set</code></li>
<li>Message类提供<code>save</code>和<code>remove</code>操作，用于给定Folder添加/删除这个Message</li>
<li>Folder类提供<code>addMsg</code>和<code>remMsg</code>操作，用于在该Folder中添加/删除一个Message</li>
<li><code>拷贝</code>Message时，除拷贝消息内容和Folder指针集合外，还要在容纳它的所有Folder中添加指向新Message的指针</li>
<li><code>析构</code>Message时，除析构Message对象外，还要在容纳它的所有Folder中删除指向它的指针</li>
<li>将一个Message<code>赋值</code>给另一个Message时，除更新左侧对象的内容外，还要从容纳左侧对象的Folder中删除左侧对象，并在容纳右侧对象的Folder中添加左侧对象</li>
</ul>
</li>
<li>拷贝赋值算符通常执行拷贝构造函数和析构函数的工作，此时可定义公共的操作放在private中</li>
<li>代码：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Message</span><span class="p">{</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Folder</span><span class="p">;</span>                    <span class="c1">//允许Folder访问
</span><span class="c1"></span><span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Message</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="o">=</span><span class="s">&#34;&#34;</span><span class="p">)</span><span class="o">:</span> <span class="c1">//默认初始化为空字符串
</span><span class="c1"></span>                    <span class="n">contents</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>           <span class="c1">//显式初始化内容，而Folder指针的集合隐式地默认初始化
</span><span class="c1"></span>                    <span class="p">{}</span>
    <span class="n">Message</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="p">);</span>               <span class="c1">//拷贝构造函数
</span><span class="c1"></span>    <span class="n">Message</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="p">);</span>    <span class="c1">//拷贝赋值算符
</span><span class="c1"></span>    <span class="o">~</span><span class="n">Message</span><span class="p">();</span>                             <span class="c1">//析构函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">save</span><span class="p">(</span><span class="n">Folder</span> <span class="o">&amp;</span><span class="p">);</span>                    <span class="c1">//给定Folder，双向添加
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="n">Folder</span> <span class="o">&amp;</span><span class="p">);</span>                  <span class="c1">//给定Folder，双向删除
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">contents</span><span class="p">;</span>                        <span class="c1">//Message存放的内容
</span><span class="c1"></span>    <span class="n">set</span><span class="o">&lt;</span><span class="n">Folder</span> <span class="o">*&gt;</span> <span class="n">folders</span><span class="p">;</span>                  <span class="c1">//用集合来存储Folder的指针，构造时默认初始化
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">add_to_Folders</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="p">);</span>   <span class="c1">//在给定Message所属的各Folder中添加本Message
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">remove_from_Folders</span><span class="p">();</span>             <span class="c1">//在本Message所属的各Folder中删除本Message
</span><span class="c1"></span><span class="p">};</span>
<span class="c1">//给定Folder，双向添加
</span><span class="c1"></span><span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">save</span><span class="p">(</span><span class="n">Folder</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">){</span>
    <span class="n">folders</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">addMsg</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//给定Folder，双向删除
</span><span class="c1"></span><span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">Folder</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">){</span>
    <span class="n">folders</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">remMsg</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//在给定Message所属的各Folder中添加本Message
</span><span class="c1"></span><span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">add_to_Folders</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span><span class="p">:</span><span class="n">m</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
        <span class="n">f</span><span class="o">-&gt;</span><span class="n">addMsg</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//在本Message所属的各Folder中删除本Message
</span><span class="c1"></span><span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">remove_from_Folders</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span><span class="p">:</span><span class="n">folders</span><span class="p">)</span>
        <span class="n">f</span><span class="o">-&gt;</span><span class="n">remMsg</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//拷贝构造函数
</span><span class="c1">//1、拷贝数据成员
</span><span class="c1">//2、在右侧对象所属的各Folder中添加左侧对象
</span><span class="c1"></span><span class="n">Message</span><span class="o">::</span><span class="n">Message</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span><span class="o">:</span>
                <span class="n">contents</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">contents</span><span class="p">),</span><span class="n">folders</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">add_to_Folders</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//析构函数
</span><span class="c1">//1、在本对象所属的各Folder中删除该对象
</span><span class="c1">//2、释放该对象的资源
</span><span class="c1"></span><span class="n">Message</span><span class="o">::~</span><span class="n">Message</span><span class="p">(){</span>
    <span class="n">remove_from_Folders</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//拷贝赋值算符
</span><span class="c1">//1、在左侧对象所属的各Folder中删除左侧对象
</span><span class="c1">//2、将右侧对象的数据成员拷贝到左侧对象
</span><span class="c1">//3、在右侧对象所属的各Folder中添加左侧对象
</span><span class="c1">//先删除后添加是为了处理自赋值。若先添加后删除，自赋值时最后删除会全部删掉
</span><span class="c1"></span><span class="n">Message</span> <span class="o">&amp;</span><span class="n">Message</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="n">remove_from_Folders</span><span class="p">();</span>
    <span class="n">contents</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">contents</span><span class="p">;</span>
    <span class="n">folders</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">folders</span><span class="p">;</span>
    <span class="n">add_to_Folders</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//swap操作
</span><span class="c1">//1、两对象所属的各Folder中分别删除两对象
</span><span class="c1">//2、交换数据成员
</span><span class="c1">//3、两对象所属的各Folder中分别添加两对象（添加的是交换前的对方）
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Message</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="n">Message</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span><span class="p">:</span><span class="n">lhs</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
        <span class="n">f</span><span class="o">-&gt;</span><span class="n">remMsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span><span class="p">:</span><span class="n">rhs</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
        <span class="n">f</span><span class="o">-&gt;</span><span class="n">remMsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">folders</span><span class="p">,</span><span class="n">rhs</span><span class="p">.</span><span class="n">folders</span><span class="p">);</span>      <span class="c1">//调用set的swap
</span><span class="c1"></span>    <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">contents</span><span class="p">,</span><span class="n">ths</span><span class="p">.</span><span class="n">contents</span><span class="p">);</span>    <span class="c1">//调用string的swap
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span><span class="p">:</span><span class="n">lhs</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
        <span class="n">f</span><span class="o">-&gt;</span><span class="n">addMsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span><span class="p">:</span><span class="n">rhs</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
        <span class="n">f</span><span class="o">-&gt;</span><span class="n">addMsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="动态内存管理类">动态内存管理类</h2>
<ul>
<li>某些类在运行时需分配可变大小的内存空间，一般可使用标准库容器来保存可变数据，也可自定义拷贝控制成员来管理动态内存</li>
<li>vector的每个添加元素的成员函数都会检查空间是否足够。若足够则在下一个位置构造元素，若不够则重新分配空间，将已有元素移动到新空间中并释放旧空间，再添加元素</li>
<li>例子：使用拷贝控制实现vector的内存分配
<ul>
<li>alloc静态成员是allocator对象，用于获得原始内存并用construct/destroy创建和删除元素</li>
<li>3个指针成员界定内存的3个边界，如图13.2</li>
<li>函数alloc_n_copy分配内存并拷贝给定范围的元素</li>
<li>函数free销毁元素并释放内存</li>
<li>函数reallocate在内存用完时重新分配</li>
<li>函数chk_n_alloc保证至少有空间容纳一个新元素，如果没有就调用reallocate分配更多空间
<img src="../cpp_figs/CPPprimer_ch13-fig_13_2.png" alt="fig_13_2"></li>
</ul>
</li>
<li>代码：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">StrVec</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//构造函数初始化3个指针为nullptr
</span><span class="c1"></span>    <span class="n">StrVec</span><span class="p">()</span><span class="o">:</span>
          <span class="n">elements</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="n">first_free</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="n">cap</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span>
          <span class="p">{}</span>
    <span class="c1">//拷贝构造函数
</span><span class="c1"></span>    <span class="n">StrVec</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="c1">//拷贝赋值算符
</span><span class="c1"></span>    <span class="n">StrVec</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="c1">//析构函数
</span><span class="c1"></span>    <span class="o">~</span><span class="n">StrVec</span><span class="p">();</span>
    <span class="c1">//以下是实现vector部分功能的函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">first_free</span><span class="o">-</span><span class="n">elements</span><span class="p">;}</span>
    <span class="n">size_t</span> <span class="nf">capacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">cap</span><span class="o">-</span><span class="n">elements</span><span class="p">;}</span>
    <span class="n">string</span> <span class="o">*</span><span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">elements</span><span class="p">;}</span>
    <span class="n">string</span> <span class="o">*</span><span class="nf">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">first_free</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">//为类分配空间并构造元素
</span><span class="c1"></span>    <span class="k">static</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
    <span class="c1">//检查空余部分，若大小为0则reallocate重新分配空间
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">chk_n_alloc</span><span class="p">();</span>
    <span class="c1">//拷贝一个迭代器范围，返回元素部分的起始指针和尾后指针
</span><span class="c1"></span>    <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span> <span class="o">*</span><span class="p">,</span><span class="n">string</span> <span class="o">*&gt;</span> <span class="n">alloc_n_copy</span><span class="p">(</span><span class="k">const</span> <span class="n">sting</span> <span class="o">*</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//若首指针非空则逆序销毁其管理的所有元素并释放动态内存
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">free</span><span class="p">();</span>
    <span class="c1">//重新分配空间
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">reallocate</span><span class="p">();</span>
    <span class="n">string</span> <span class="o">*</span><span class="n">elements</span><span class="p">;</span>   <span class="c1">//元素部分的起始指针
</span><span class="c1"></span>    <span class="n">string</span> <span class="o">*</span><span class="n">first_free</span><span class="p">;</span> <span class="c1">//元素部分的尾后指针/空余部分的起始指针
</span><span class="c1"></span>    <span class="n">string</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>        <span class="c1">//空余部分的尾后指针
</span><span class="c1"></span><span class="p">};</span>
<span class="c1">//检查空间是否够用，并在元素部分的尾部构造新元素
</span><span class="c1"></span><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span>
    <span class="n">chk_n_alloc</span><span class="p">();</span>
    <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">first_free</span><span class="o">++</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//检查空余部分，若大小为0则reallocate重新分配空间
</span><span class="c1"></span><span class="kr">inline</span> <span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">chk_n_alloc</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="n">capacity</span><span class="p">())</span>
        <span class="n">reallocate</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//拷贝一个迭代器范围，返回元素部分的起始指针和尾后指针
</span><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span> <span class="o">*</span><span class="p">,</span><span class="n">string</span> <span class="o">*&gt;</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">alloc_n_copy</span><span class="p">(</span><span class="k">const</span> <span class="n">sting</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">e</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">data</span><span class="o">=</span><span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="n">b</span><span class="p">);</span>              <span class="c1">//分配空间用于拷贝元素
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span><span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">data</span><span class="p">)};</span> <span class="c1">//使用uninitialized_copy完成拷贝，并返回两个指针
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//若首指针非空则逆序销毁其管理的所有元素并释放动态内存
</span><span class="c1"></span><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">free</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">elements</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span><span class="o">=</span><span class="n">first_free</span><span class="p">;</span><span class="n">p</span><span class="o">!=</span><span class="n">elements</span><span class="p">;)</span>
            <span class="n">alloc</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="o">--</span><span class="n">p</span><span class="p">);</span>                     <span class="c1">//按逆序逐个销毁
</span><span class="c1"></span>        <span class="n">alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span><span class="n">cap</span><span class="o">-</span><span class="n">elements</span><span class="p">);</span>    <span class="c1">//释放空间
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//拷贝构造函数
</span><span class="c1">//1、将右侧对象的元素部分拷贝，得到首指针和尾后指针
</span><span class="c1">//2、让成员指针接管右侧对象拷出的动态元素
</span><span class="c1"></span><span class="n">StrVec</span><span class="o">::</span><span class="n">StrVec</span><span class="p">(</span><span class="n">cosnt</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">newdata</span><span class="o">=</span><span class="n">alloc_n_copy</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">elements</span><span class="o">=</span><span class="n">newdata</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="n">first_free</span><span class="o">=</span><span class="n">cap</span><span class="o">=</span><span class="n">newdata</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//析构函数
</span><span class="c1">//1、函数体调用free销毁该对象管理的动态元素，释放空间
</span><span class="c1">//2、隐式析构部分销毁该对象的成员
</span><span class="c1"></span><span class="n">StrVec</span><span class="o">::~</span><span class="n">SreVec</span><span class="p">(){</span><span class="n">free</span><span class="p">();}</span>
<span class="c1">//拷贝赋值算符
</span><span class="c1">//1、将右侧对象的元素部分拷贝，得到首指针和尾后指针
</span><span class="c1">//2、销毁左侧对象管理的动态元素
</span><span class="c1">//3、让左侧对象的指针接管右侧对象拷出的动态元素
</span><span class="c1"></span><span class="n">StrVec</span> <span class="o">&amp;</span><span class="n">StrVec</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">data</span><span class="o">=</span><span class="n">alloc_n_copy</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">rhs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">free</span><span class="p">();</span>
    <span class="n">elements</span><span class="o">=</span><span class="n">data</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="n">first_free</span><span class="o">=</span><span class="n">cap</span><span class="o">=</span><span class="n">data</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//1、分配原来2倍的空间
</span><span class="c1">//2、把原来的元素依次移动到新空间
</span><span class="c1">//3、释放原来的空间
</span><span class="c1">//4、让类的指针接管新的空间
</span><span class="c1"></span><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">reallocate</span><span class="p">(){</span>
    <span class="k">auto</span> <span class="n">newcapacity</span><span class="o">=</span><span class="n">size</span><span class="p">()</span><span class="o">?</span><span class="mi">2</span><span class="o">*</span><span class="n">size</span><span class="p">()</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>             <span class="c1">//原来空间的2倍或初始值1
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">newdata</span><span class="o">=</span><span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">newcapacity</span><span class="p">);</span>       <span class="c1">//分配新空间
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">dest</span><span class="o">=</span><span class="n">newdata</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">elem</span><span class="o">=</span><span class="n">elements</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">!=</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">dest</span><span class="o">++</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">elem</span><span class="o">++</span><span class="p">));</span> <span class="c1">//使用右值调用移动构造函数
</span><span class="c1"></span>    <span class="n">free</span><span class="p">();</span>                                         <span class="c1">//释放原来的空间
</span><span class="c1"></span>    <span class="n">elements</span><span class="o">=</span><span class="n">newdata</span><span class="p">;</span>
    <span class="n">first_free</span><span class="o">=</span><span class="n">dest</span><span class="p">;</span>
    <span class="n">cap</span><span class="o">=</span><span class="n">elements</span><span class="o">+</span><span class="n">newcapacity</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>重新分配vector的空间时，使用<code>移动</code>而不是拷贝元素。</li>
<li>若类定义了<code>移动构造函数</code>，则可将资源从给定对象移动（而不是拷贝）到正在创建的对象，并保证<code>移后源对象</code>处于有效的、析构安全的状态。</li>
<li><code>std::move</code>函数定义于<code>utility</code>头文件，在移动构造时对输入对象调用std::move表示希望使用移动构造函数，否则使用拷贝构造函数。</li>
<li>通常不对std::move使用using声明，直接用std::move限定调用标准库中的版本。</li>
</ul>
<h2 id="对象移动">对象移动</h2>
<ul>
<li>允许移动而非拷贝对象，是C++11最主要的特性之一。
<ul>
<li>某些时候，对象<code>拷贝后立即销毁</code>不再使用（例如vector重新分配空间），此时用移动代替拷贝会大幅提高性能</li>
<li>某些类包含<code>不可被共享的资源</code>（例如IO类、unique_ptr不可被拷贝），这些类的对象不可拷贝但可移动</li>
</ul>
</li>
<li>旧标准的标准库容器只能存放可拷贝的元素，C++11后只需可移动即可放入容器</li>
</ul>
<h3 id="右值引用">右值引用</h3>
<ul>
<li>右值引用在C++11被引入以支持移动操作。</li>
<li><code>右值引用</code>是必须绑定到<code>右值</code>的引用，通过<code>&amp;&amp;</code>而不是<code>&amp;</code>来获得。右值引用只能绑定到将要被销毁的对象，故可将右值引用的资源安全地移动到另一个对象</li>
<li>左值表达式表示的是对象的身份，右值表达式表示的是对象的值
<ul>
<li><code>左值引用</code>：不可绑定到要求转换的表达式、字面值常量、返回右值的表达式</li>
<li><code>右值引用</code>：可引用的范围与左值引用相反，可绑定到上述表达式，但不可绑定到左值</li>
<li>左值例子：能用&amp;取地址的表达式、返回左值引用的函数/表达式、赋值、下标、解引用、前置递增/递减、字符串字面值</li>
<li>右值例子：返回非引用的函数、算术、关系、位、后置递增/递减、除字符串外的所有字面值</li>
</ul>
</li>
<li>例子：右值引用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>           <span class="c1">//对
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>         <span class="c1">//错，i是左值，不可绑定到右值引用
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">42</span><span class="p">;</span>       <span class="c1">//错，i*42是右值，不可绑定到左值引用
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">42</span><span class="p">;</span> <span class="c1">//对，可将右值绑定到const左值引用（const引用绑定临时量）
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr2</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">42</span><span class="p">;</span>     <span class="c1">//对，可将右值绑定到右值引用
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>左值有持久的状态，右值要么是字面值常量，要么是表达式求值过程中创建的临时对象</li>
<li>右值引用只能绑定到临时对象，它所引用的对象将要销毁，且该对象没有其他用户。因此<code>使用右值引用的代码可自由地接管引用对象的资源</code></li>
<li>变量是特殊的表达式，变量表达式都是左值。因此不可将右值引用绑定到右值引用类型的变量（右值引用类型的变量也是左值）</li>
<li><code>std::move</code>函数可将左值显式转换为它对应的右值引用类型，它定义于<code>utility</code>头文件</li>
<li>std::move告诉编译器：希望将这个左值（<code>移后源对象</code>）当作右值来处理。处理完后，除对它赋值或销毁外，不应进行任何操作，特别是不可使用它的值（未定义）。</li>
<li>使用std::move时应显式指明std::作用域，避免潜在的命名冲突</li>
</ul>
<h3 id="移动构造函数和移动赋值运算符">移动构造函数和移动赋值运算符</h3>
<ul>
<li>自定义<code>移动构造函数</code>和<code>移动赋值算符</code>可让类型支持移动操作</li>
<li>移动构造函数的第一个参数是该类类型的<code>右值引用</code>，且任何额外参数都必须有默认实参</li>
<li>除完成资源移动外，移动构造函数必须确保移后源对象处于<code>析构安全</code>的状态，即销毁它对程序没有任何影响。特别是，一旦完成移动，移后源对象不应该再管理被移动的资源。</li>
<li>例子：移动构造函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//移动构造函数
</span><span class="c1"></span><span class="n">StrVec</span><span class="o">::</span><span class="n">StrVec</span><span class="p">(</span><span class="n">StrVec</span> <span class="o">&amp;&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span>       <span class="c1">//传入右值引用，且声明为noexcept表示不会抛出异常
</span><span class="c1"></span>              <span class="n">elements</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">elements</span><span class="p">),</span>         <span class="c1">//初值列表中拷贝指针，让该对象接管传入对象的资源
</span><span class="c1"></span>              <span class="n">first_free</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">first_free</span><span class="p">),</span>
              <span class="n">cap</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="n">elements</span><span class="o">=</span><span class="n">s</span><span class="p">.</span><span class="n">first_free</span><span class="o">=</span><span class="n">s</span><span class="p">.</span><span class="n">cap</span><span class="o">=</span><span class="k">nullptr</span><span class="p">;</span>  <span class="c1">//将传入对象的指针置为nullptr，表示不再管理这些资源（即将传入对象置于析构安全状态）
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>noexcept</code>通知编译器，该函数不会抛出任何异常，出现在形参列表和初始化列表的冒号之间。
<ul>
<li>移动构造函数不需要分配新内存，只修改管理权限而不分配新资源，不会抛出异常</li>
<li>通知编译器不会抛出异常，可减少处理异常的开销（例如标准库容器处理元素时，为异常安全会优先用拷贝而不是移动）</li>
</ul>
</li>
<li>使用noexcept时必须在函数声明和定义中都说明noexcept</li>
<li>不抛出异常的移动构造函数和移动赋值算符都必须标记为noexcept：
<ol>
<li>拷贝构造可处理异常，移动构造不可处理异常（拷贝时先拷出再修改对象，抛出异常在修改对象之前。移动的过程就是修改原对象的过程，无法处理异常）</li>
<li>因此，对于移动构造函数可能抛出异常的元素，容器都会用拷贝而不是移动来处理它们（例如vector重新分配时使用拷贝而不是移动）</li>
<li>只有告诉容器：移动构造函数不会抛出异常，可安全使用，它才会移动</li>
</ol>
</li>
<li><code>移动赋值算符</code>执行与析构函数和移动构造函数相同的操作</li>
<li>移动赋值算符处理<code>自赋值</code>的方法：判断this指针是否等于右侧对象的地址（即判断右侧是否是std::move产生的左侧对象的右值）。</li>
<li>例子：移动赋值算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//移动赋值算符
</span><span class="c1"></span><span class="n">StrVec</span> <span class="o">&amp;</span><span class="n">StrVec</span><span class="o">::</span><span class="n">StrVec</span><span class="p">(</span><span class="n">StrVec</span> <span class="o">&amp;&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>         <span class="c1">//输入是右值引用，且不会抛出异常
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">!=&amp;</span><span class="n">rhs</span><span class="p">){</span>                                     <span class="c1">//检查this指针是否等于右侧对象的地址，即是否自赋值
</span><span class="c1"></span>        <span class="n">free</span><span class="p">();</span>                                         <span class="c1">//释放左侧对象管理的资源
</span><span class="c1"></span>        <span class="n">elements</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">elements</span><span class="p">;</span>                          <span class="c1">//拷贝指针，让左侧对象接管右侧对象的资源
</span><span class="c1"></span>        <span class="n">first_free</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">first_free</span><span class="p">;</span>
        <span class="n">cap</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">cap</span><span class="p">;</span>
        <span class="n">rhs</span><span class="p">.</span><span class="n">elements</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">first_free</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">cap</span><span class="o">=</span><span class="k">nullptr</span><span class="p">;</span>    <span class="c1">//将右侧对象置于可析构状态
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>从对象移动数据不会销毁此对象，但有时移动后会将原对象销毁。因此必须保证移后源对象可析构，实现方式是将其指针成员置为<code>nullptr</code></li>
<li>移动操作必须保证移后源对象是可析构的，且是有效的（可为其赋予新值或可安全使用而不依赖当前值）。移后源对象的值是未定义的，不应该对其值有任何假设</li>
<li>若类自定义了拷贝构造函数、拷贝赋值算符或析构函数，则编译器不会合成移动构造函数和移动赋值算符。</li>
<li>若一个类没有移动操作，类会使用对应的拷贝操作来代替移动操作（通过函数匹配）</li>
<li>编译器<code>合成移动构造函数和移动赋值算符</code>的情形：当一个类未自定义任何拷贝控制成员，且每个非static成员都可移动时。（内置类型成员都可移动，类类型成员若有移动操作也可移动）</li>
<li>移动操作永远不会被隐式定义为删除函数，但若显式要求生成<code>=default</code>的移动操作且编译器无法移动所有成员时，编译器会将移动操作定义为删除的。</li>
<li>将合成的移动操作定义为删除的情形:
<ul>
<li>移动构造函数被定义为删除的条件：
<ul>
<li>类成员自定义了拷贝构造函数但未自定义移动构造函数</li>
<li>类成员未自定义拷贝构造函数且编译器不能合成移动构造函数</li>
<li>类成员的移动构造函数被定义为删除的或不可访问</li>
<li>类的析构函数被定义为删除的或不可访问</li>
</ul>
</li>
<li>移动赋值算符被定义为删除的条件：
<ul>
<li>类成员自定义了拷贝赋值算符但未自定义移动赋值算符</li>
<li>类成员未自定义拷贝赋值算符且编译器不能合成移动赋值算符</li>
<li>类成员的移动赋值算符被定义为删除的或不可访问</li>
<li>类有成员是const的或是引用</li>
</ul>
</li>
</ul>
</li>
<li>若移动操作可能被定义为删除，编译器就不会合成它们</li>
<li><code>移动与拷贝相互作用</code>：
<ul>
<li>若类自定义了移动构造函数和/或移动赋值算符，则类的合成拷贝构造函数和合成拷贝赋值算符被定义为删除（因此<code>自定义了移动的类必须自定义拷贝</code>）</li>
<li>若类自定义了拷贝构造函数、拷贝赋值算符或析构函数，则编译器不会合成移动构造函数和移动赋值算符。</li>
</ul>
</li>
<li>若类既有移动操作又有拷贝操作，则编译器使用函数匹配规则来判断调用哪个。<code>左值拷贝，右值移动</code></li>
<li>例子：左值拷贝，右值移动</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">StrVec</span> <span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">;</span>
<span class="n">v1</span><span class="o">=</span><span class="n">v2</span><span class="p">;</span>                      <span class="c1">//右边是左值，拷贝
</span><span class="c1"></span><span class="n">StrVec</span> <span class="nf">getVec</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="p">);</span>   <span class="c1">//返回值非引用，调用返回右值
</span><span class="c1"></span><span class="n">v2</span><span class="o">=</span><span class="n">getVec</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span>             <span class="c1">//右边是右值，移动
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>拷贝操作一般将输入定义为const引用的一个原因是：当输入为右值时可隐式转换为const引用。</li>
<li>当类有拷贝构造函数但没有移动构造函数，且使用右值构造时，<code>T &amp;&amp;到const T &amp;的隐式转换</code>可保证拷贝构造函数被调用，即<code>用拷贝代替移动</code>。赋值算符同理</li>
<li>用拷贝操作代替移动操作几乎肯定是安全的，一般拷贝操作满足对应移动操作的要求（但反之不可）</li>
<li>例子：用拷贝代替移动</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Foo</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>      <span class="c1">//定义默认构造函数
</span><span class="c1"></span>    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span> <span class="o">&amp;</span><span class="p">);</span>   <span class="c1">//定义拷贝构造函数
</span><span class="c1"></span>    <span class="c1">//未定义移动构造函数
</span><span class="c1"></span><span class="p">};</span>
<span class="n">Foo</span> <span class="n">x</span><span class="p">;</span>
<span class="n">Foo</span> <span class="nf">y</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>               <span class="c1">//左值，匹配到拷贝构造函数
</span><span class="c1"></span><span class="n">Foo</span> <span class="nf">z</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>    <span class="c1">//右值，但无移动构造函数，Foo &amp;&amp;隐式转换为const Foo &amp;，匹配到拷贝构造函数
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>用<code>swap实现赋值算符</code>时使用的<code>拷贝并交换</code>技术，这样得到的赋值算符既可当作移动赋值算符也可当作拷贝赋值算符（因为形参非引用，传参存在临时量，可根据实参类型决定拷贝/移动构造）</li>
<li>例子：“拷贝并交换技术”实现<code>拷贝赋值算符和移动赋值算符共享实现</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">HasPtr</span><span class="p">{</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//构造函数
</span><span class="c1"></span>    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">=</span><span class="n">string</span><span class="p">())</span><span class="o">:</span>
          <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span><span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
          <span class="p">{}</span>
    <span class="c1">//拷贝构造函数，行为像值
</span><span class="c1"></span>    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span><span class="o">:</span>
          <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span><span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">i</span><span class="p">)</span>
          <span class="p">{}</span>
    <span class="c1">//移动构造函数
</span><span class="c1"></span>    <span class="n">HasPtr</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;&amp;</span><span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span>
          <span class="n">ps</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span><span class="p">),</span><span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">i</span><span class="p">)</span>
          <span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
    <span class="c1">//既可作为拷贝赋值算符，又可作为移动赋值算符
</span><span class="c1"></span>    <span class="c1">//传参时生成临时对象，选择拷贝/移动构造函数：左值拷贝，右值移动
</span><span class="c1"></span>    <span class="c1">//临时对象构造完成后，拷贝赋值和移动赋值都可用交换完成
</span><span class="c1"></span>    <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="n">rhs</span><span class="p">){</span>
        <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="n">rhs</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//析构函数
</span><span class="c1"></span>    <span class="o">~</span><span class="n">HasPtr</span><span class="p">(){</span><span class="k">delete</span> <span class="n">ps</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//使用共同实现的算符
</span><span class="c1"></span><span class="n">HasPtr</span> <span class="n">hp</span><span class="p">,</span><span class="n">hp2</span><span class="p">;</span>
<span class="n">hp</span><span class="o">=</span><span class="n">hp2</span><span class="p">;</span>             <span class="c1">//右侧为左值，operator=作为拷贝赋值
</span><span class="c1"></span><span class="n">hp</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">hp2</span><span class="p">);</span>  <span class="c1">//右侧为右值，operator=作为移动赋值
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>更新的<code>三/五法则</code>：所有5个拷贝控制成员应看作一个整体，一般定义了一个就应定义所有5个（定义移动的目的是避免额外开销，有拷贝需求的类一般也有移动需求）。</li>
<li>例子：为13.4的Message类定义移动操作</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//工具函数：将给定Message所属的Folder信息“移动”到本Message
</span><span class="c1">//1、将给定Message的Folder集合移动到本Message
</span><span class="c1">//2、从给定Message所属的各Folder中删除给定Message并添加本Message
</span><span class="c1">//3、清空给定Message的Folder集合
</span><span class="c1"></span><span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">move_Folders</span><span class="p">(</span><span class="n">Message</span> <span class="o">*</span><span class="n">m</span><span class="p">){</span>
    <span class="n">folders</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">folders</span><span class="p">);</span>              <span class="c1">//移动set
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span><span class="p">:</span><span class="n">folders</span><span class="p">){</span>
        <span class="n">f</span><span class="o">-&gt;</span><span class="n">remMsg</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="n">f</span><span class="o">-&gt;</span><span class="n">addMsg</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">m</span><span class="o">-&gt;</span><span class="n">folders</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//移动构造函数（未说明noexcept，因为move_Folders向集合添加元素可能引发异常）
</span><span class="c1">//1、将给定Message的内容移动到本Message
</span><span class="c1">//2、将给定Message所属的Folder信息“移动”到本Message
</span><span class="c1"></span><span class="n">Message</span><span class="o">::</span><span class="n">Message</span><span class="p">(</span><span class="n">Message</span> <span class="o">&amp;&amp;</span><span class="n">m</span><span class="p">)</span><span class="o">:</span>
                <span class="n">contents</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">contents</span><span class="p">))</span> <span class="c1">//移动string
</span><span class="c1"></span>                <span class="p">{</span><span class="n">move_Folders</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);}</span>
<span class="c1">//移动赋值算符（未说明noexcept，因为move_Folders向集合添加元素可能引发异常）
</span><span class="c1">//1、在左侧对象所属的各Folder中删除左侧对象
</span><span class="c1">//2、将右侧对象的内容移动到左侧对象
</span><span class="c1">//3、将右侧对象所属的Folder信息“移动”到左侧对象
</span><span class="c1"></span><span class="n">Message</span> <span class="o">&amp;</span><span class="n">Message</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Message</span> <span class="o">&amp;&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">!=&amp;</span><span class="n">rhs</span><span class="p">){</span>
        <span class="n">remove_from_Folders</span><span class="p">();</span>
        <span class="n">contents</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">contents</span><span class="p">);</span>       <span class="c1">//移动string
</span><span class="c1"></span>        <span class="n">move_Folders</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>用allocator移动初始化动态内存时，一般用construct结合循环逐个元素移动构造。若能用<code>uninitialized_copy</code>一次移动一个迭代器范围将更简单。</li>
<li><code>迭代器适配器</code>通过修改给定迭代器的解引用<code>*</code>算符来改变迭代器的行为。</li>
<li>C++11定义了<code>移动迭代器适配器</code>。普通迭代器的解引用得到左值引用，移动迭代器的解引用得到右值引用。</li>
<li><code>make_move_iterator</code>函数将一个普通迭代器转换为移动迭代器，它接受一个普通迭代器作为参数，返回对应的移动迭代器。原迭代器的所有操作在移动迭代器中都照常工作。</li>
<li>可将移动迭代器传递给算法，特别是，可用uninitialized_copy一次移动初始化多个元素</li>
<li>例子：重写13.5的reallocate函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//1、分配原来2倍的空间
</span><span class="c1">//2、把原来的元素依次移动到新空间
</span><span class="c1">//3、释放原来的空间
</span><span class="c1">//4、让类的指针接管新的空间
</span><span class="c1"></span><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">reallocate</span><span class="p">(){</span>
    <span class="c1">//原来空间的2倍或初始值1
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">newcapacity</span><span class="o">=</span><span class="n">size</span><span class="p">()</span><span class="o">?</span><span class="mi">2</span><span class="o">*</span><span class="n">size</span><span class="p">()</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="c1">//分配空间
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">first</span><span class="o">=</span><span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">newcapacity</span><span class="p">);</span>
    <span class="c1">//使用移动迭代器范围，批量移动元素
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">last</span><span class="o">=</span><span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">begin</span><span class="p">()),</span>
                                 <span class="n">make_move_iterator</span><span class="p">(</span><span class="n">end</span><span class="p">()));</span>
    <span class="n">free</span><span class="p">();</span>
    <span class="n">elements</span><span class="o">=</span><span class="n">first</span><span class="p">;</span>
    <span class="n">first_free</span><span class="o">=</span><span class="n">last</span><span class="p">;</span>
    <span class="n">cap</span><span class="o">=</span><span class="n">elements</span><span class="o">+</span><span class="n">newcapacity</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>uninitialized_copy对输入序列的每个元素调用construct来构造，该函数用迭代器的解引用算符从输入序列中取元素。传递移动迭代器时construct使用右值引用来构造</li>
<li>标准库不保证哪些算法可使用移动迭代器。移动对象将原对象置于可析构，故只有确信算法为元素赋值或将其传递给用户定义的函数后不再访问它时，才能向其传递移动迭代器</li>
<li>调用std::move时必须绝对确认移后源对象没有其他用户，且只有确信需要移动且移动是安全的时候，才可调用std::move</li>
</ul>
<h3 id="右值引用和成员函数">右值引用和成员函数</h3>
<ul>
<li>除拷贝控制成员外，普通成员同时提供拷贝和移动版本也可得到优化。方法是提供两个版本的重载：拷贝版本接受指向<code>const的左值引用</code>，移动版本接受指向<code>非const的右值引用</code></li>
<li>例子：定义了push_back的容器有拷贝和移动两个版本</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">cons</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>    <span class="c1">//拷贝版本，绑定到任意能转换为T的对象（临时量）
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">);</span>       <span class="c1">//移动版本，只能绑定到类型T的可修改的右值
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>定义拷贝和移动版本时，不需要为函数操作定义接受<code>const T &amp;&amp;</code>或是<code>T &amp;</code>的版本。因为移动应改变对象，不能const；拷贝不应改变对象，应该const</li>
<li>例子：为13.5的StrVec定义拷贝和移动版本的push_back</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">StrVec</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">//拷贝版本
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;&amp;</span><span class="p">);</span>      <span class="c1">//移动版本
</span><span class="c1"></span>    <span class="cm">/* 其他成员 */</span>
<span class="p">};</span>
<span class="c1">//拷贝版本
</span><span class="c1"></span><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span>
    <span class="n">chk_n_alloc</span><span class="p">();</span>
    <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">first_free</span><span class="o">++</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>            <span class="c1">//拷贝构造
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//移动版本
</span><span class="c1"></span><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">push_back</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;&amp;</span><span class="p">){</span>
    <span class="n">chk_n_alloc</span><span class="p">();</span>
    <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">first_free</span><span class="o">++</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">));</span> <span class="c1">//移动构造
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//使用push_back，实参类型决定拷贝还是移动
</span><span class="c1"></span><span class="n">StrVec</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">string</span> <span class="n">s</span><span class="o">=</span><span class="s">&#34;some string or another&#34;</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>       <span class="c1">//传入左值，调用拷贝版本
</span><span class="c1"></span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">);</span>  <span class="c1">//传入右值，调用移动版本
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>允许在右值对象上调用成员</li>
<li>允许向右值赋值（为维持后向兼容）</li>
<li>例子：在右值对象上调用成员，向右值赋值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="n">s1</span><span class="o">=</span><span class="s">&#34;a value&#34;</span><span class="p">,</span><span class="n">s2</span><span class="o">=</span><span class="s">&#34;another&#34;</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="n">s1</span><span class="o">+</span><span class="n">s2</span><span class="p">).</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">);</span>   <span class="c1">//在右值对象上调用成员
</span><span class="c1"></span><span class="n">s1</span><span class="o">+</span><span class="n">s2</span><span class="o">=</span><span class="s">&#34;wow!&#34;</span><span class="p">;</span>               <span class="c1">//向右值赋值
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>C++11允许使用<code>引用限定符</code>来强制算符的左侧运算对象（即this对象）是左值或右值。</li>
<li>引用限定符置于参数列表后，可以是<code>&amp;</code>/<code>&amp;&amp;</code>，分别指出this应指向左值/右值</li>
<li>引用限定符只能用于非static成员函数，且必须同时出现在声明和定义中</li>
<li>例子：引用限定符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Foo</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span> <span class="c1">//有&amp;无const，只能向可修改的左值赋值
</span><span class="c1"></span>    <span class="cm">/* 其他成员 */</span>
<span class="p">};</span>
<span class="n">Foo</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">{</span>
    <span class="cm">/* 执行操作 */</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//使用Foo
</span><span class="c1"></span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">retFoo</span><span class="p">();</span>  <span class="c1">//返回引用，调用结果是左值
</span><span class="c1"></span><span class="n">Foo</span> <span class="nf">retVal</span><span class="p">();</span>   <span class="c1">//返回值，调用结果是右值
</span><span class="c1"></span><span class="n">Foo</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>        <span class="c1">//i和j都是左值
</span><span class="c1"></span><span class="n">i</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>            <span class="c1">//对，i是左值，该operator=可向左值赋值
</span><span class="c1"></span><span class="n">retFoo</span><span class="p">()</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>     <span class="c1">//对，retFoo()返回左值，该operator=可向左值赋值
</span><span class="c1"></span><span class="n">retVal</span><span class="p">()</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>     <span class="c1">//错，retVal()返回右值，该operator=不可向右值赋值
</span><span class="c1"></span><span class="n">i</span><span class="o">=</span><span class="n">retVal</span><span class="p">();</span>     <span class="c1">//对
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>函数可同时使用const和引用限定符，此时限定符必须在const之后</li>
<li>可使用引用限定符来区分重载版本，且可综合const和引用限定符来区分重载版本</li>
<li>例子：用const和引用限定符来区分重载版本</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Foo</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span> <span class="n">sorted</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>        <span class="c1">//对右值对象调用，会改变调用对象
</span><span class="c1"></span>    <span class="n">Foo</span> <span class="nf">sorted</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span>   <span class="c1">//对左值对象调用，不会改变调用对象
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//原址排序
</span><span class="c1"></span><span class="n">Foo</span> <span class="n">Foo</span><span class="o">::</span><span class="n">sorted</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">{</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>          <span class="c1">//直接在右值对象上排序
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>                           <span class="c1">//返回排序后的对象
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//非原址排序
</span><span class="c1"></span><span class="n">Foo</span> <span class="n">Foo</span><span class="o">::</span><span class="n">sorted</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">{</span>
    <span class="n">Foo</span> <span class="nf">ret</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>                         <span class="c1">//先拷贝一个副本
</span><span class="c1"></span>    <span class="n">sort</span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ret</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>  <span class="c1">//在拷贝的副本上排序
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>                             <span class="c1">//返回拷贝的副本
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//使用sort
</span><span class="c1"></span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">retFoo</span><span class="p">();</span>      <span class="c1">//返回引用，调用结果是左值
</span><span class="c1"></span><span class="n">Foo</span> <span class="nf">retVal</span><span class="p">();</span>       <span class="c1">//返回值，调用结果是右值
</span><span class="c1"></span><span class="n">retFoo</span><span class="p">().</span><span class="n">sorted</span><span class="p">();</span>  <span class="c1">//对左值调用，非原址排序
</span><span class="c1"></span><span class="n">retVal</span><span class="p">().</span><span class="n">sorted</span><span class="p">();</span>  <span class="c1">//对右值调用，原址排序
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>用const重载（形参相同的）成员函数时，可定义有const和无const两个版本</li>
<li>用引用限定符重载（形参相同的）成员函数时，必须对所有版本都使用不同限定符（不能一个用而另一个不用）</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">canpi</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-03-15
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_wechat.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_alipay.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          <a href="/tags/c&#43;&#43;-primer/">C&#43;&#43; primer</a>
          <a href="/tags/%E8%AF%BB%E4%B9%A6/">读书</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cpp/cppprimer_ch14/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43; primer 第14章 重载运算与类型转换</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/cpp/cppprimer_ch12/">
            <span class="next-text nav-default">C&#43;&#43; primer 第12章 动态内存</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/cpp/cppprimer_ch13/" class="leancloud_visitors" data-flag-title="C&#43;&#43; primer 第13章 拷贝控制">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'ntftaTIdLaT8sVPL9qFX5dAg-gzGzoHsz',
        appKey: 'lNOKznaI2Gnej5D2MgpUJnzV',
        notify:  false ,
        verify:  false ,
        avatar:'retro',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hucanpei@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/hucanpei" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/canpi" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">canpi</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>








</body>
</html>
