<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; primer 第9章 顺序容器 - pi</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="canpi" /><meta name="description" content="一个容器是特定类型对象的集合 顺序容器中元素的顺序与其加入容器的位置对应 关联容器中元素的顺序由其关联的关键字决定，关联容器分为有序关联容器和无" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.67.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/cpp/cppprimer_ch9/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.78f8f17bab244b9ee62ad16480c9584d5fc2db06ae20681d1ca225cefd80767c.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; primer 第9章 顺序容器" />
<meta property="og:description" content="一个容器是特定类型对象的集合 顺序容器中元素的顺序与其加入容器的位置对应 关联容器中元素的顺序由其关联的关键字决定，关联容器分为有序关联容器和无" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/cpp/cppprimer_ch9/" />
<meta property="article:published_time" content="2020-02-19T13:45:00+08:00" />
<meta property="article:modified_time" content="2020-02-19T13:45:00+08:00" />
<meta itemprop="name" content="C&#43;&#43; primer 第9章 顺序容器">
<meta itemprop="description" content="一个容器是特定类型对象的集合 顺序容器中元素的顺序与其加入容器的位置对应 关联容器中元素的顺序由其关联的关键字决定，关联容器分为有序关联容器和无">
<meta itemprop="datePublished" content="2020-02-19T13:45:00&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-19T13:45:00&#43;08:00" />
<meta itemprop="wordCount" content="10186">



<meta itemprop="keywords" content="C&#43;&#43;,C&#43;&#43; primer,读书," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; primer 第9章 顺序容器"/>
<meta name="twitter:description" content="一个容器是特定类型对象的集合 顺序容器中元素的顺序与其加入容器的位置对应 关联容器中元素的顺序由其关联的关键字决定，关联容器分为有序关联容器和无"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">canpi</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">canpi</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; primer 第9章 顺序容器</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-02-19 </span>
        
          <span class="more-meta"> 约 10186 字 </span>
          <span class="more-meta"> 预计阅读 21 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#顺序容器概述">顺序容器概述</a></li>
    <li><a href="#容器库概览">容器库概览</a>
      <ul>
        <li><a href="#迭代器">迭代器</a></li>
        <li><a href="#容器类型成员">容器类型成员</a></li>
        <li><a href="#begin和end成员">begin和end成员</a></li>
        <li><a href="#容器定义和初始化">容器定义和初始化</a></li>
        <li><a href="#赋值和swap">赋值和swap</a></li>
        <li><a href="#容器大小操作">容器大小操作</a></li>
        <li><a href="#关系运算符">关系运算符</a></li>
      </ul>
    </li>
    <li><a href="#顺序容器操作">顺序容器操作</a>
      <ul>
        <li><a href="#向顺序容器添加元素">向顺序容器添加元素</a></li>
        <li><a href="#访问元素">访问元素</a></li>
        <li><a href="#删除元素">删除元素</a></li>
        <li><a href="#特殊的forward_list操作">特殊的forward_list操作</a></li>
        <li><a href="#改变容器大小">改变容器大小</a></li>
        <li><a href="#容器操作可能使迭代器失效">容器操作可能使迭代器失效</a></li>
      </ul>
    </li>
    <li><a href="#vector对象是如何增长的">vector对象是如何增长的</a></li>
    <li><a href="#额外的string操作">额外的string操作</a>
      <ul>
        <li><a href="#构造string的其他方法">构造string的其他方法</a></li>
        <li><a href="#改变string的其他方法">改变string的其他方法</a></li>
        <li><a href="#string搜索操作">string搜索操作</a></li>
        <li><a href="#compare函数">compare函数</a></li>
        <li><a href="#数值转换">数值转换</a></li>
      </ul>
    </li>
    <li><a href="#容器适配器">容器适配器</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <ul>
<li>一个<code>容器</code>是特定类型对象的集合</li>
<li><code>顺序容器</code>中元素的顺序与其加入容器的位置对应</li>
<li><code>关联容器</code>中元素的顺序由其关联的关键字决定，关联容器分为<code>有序关联容器</code>和<code>无序关联容器</code></li>
<li>所有容器类共享公有接口，不同容器按不同方式扩展。</li>
<li>标准库还提供了3种<code>容器适配器</code>，为容器操作定义了不同的接口</li>
<li>本章9.2节的接口对所有容器适用，之后的小节只适用于顺序容器</li>
</ul>
<h2 id="顺序容器概述">顺序容器概述</h2>
<ul>
<li>所有容器都可快速访问元素，但在不同方面有折中：
<ul>
<li>添加/删除元素的代价</li>
<li>非顺序访问的代价</li>
</ul>
</li>
<li>如表9.1是顺序容器的类型
<img src="../cpp_figs/CPPprimer_ch9-tab_9_1.png" alt="tab_9_1"></li>
<li>存储元素的策略影响容器的操作效率，甚至限制容器的某些操作</li>
<li>只有<code>array</code>大小固定，其他容器都允许扩张和收缩，且高效</li>
<li>除array外，其他容器对应3种内存模型：
<ul>
<li><code>线性表</code>：<code>string</code>和<code>vector</code>将元素存储在连续空间中，故通过下标的随机访问很快，在中间和头部插入/删除很慢，在尾部添加元素很快，添加元素可能造成空间的重新分配和元素拷贝。</li>
<li><code>链表</code>：<code>list</code>（双向链表）和<code>forward_list</code>（单向链表）的设计目的是让任何位置的插入/删除都快速高效且不需重新分配内存。但不支持随机访问，为访问一个元素需要遍历整个链表。由于要存储指针，故内存开销大。</li>
<li><code>队列</code>：<code>deque</code>（双端队列）支持快速随机访问，且在中间插入/删除元素很慢，但两端插入/删除很快。</li>
</ul>
</li>
<li>forward_list和array是C++11新增的类型：
<ul>
<li>array和内置数组一样大小固定，但操作更安全</li>
<li>forward_list的设计目标是达到与最快的手写单向链表相当的性能，故没有size操作（计算和保存都要开销）</li>
</ul>
</li>
<li>最佳实践：C++11的容器比旧版本快很多，其性能与优化过的手写数据结构一样好。故应使用标准库容器而不是用数组造轮子</li>
<li><code>选择容器</code>的最佳实践：
<ul>
<li>一般用vector，除非有理由选其他容器</li>
<li>如果元素小而多，且空间开销重要，则不要用list或forward_list</li>
<li>若要求随机访问，则用vector或deque</li>
<li>若要在中间插入/删除，则用list或forward_list</li>
<li>若要在头尾插入/删除但不在中间插入/删除，则用deque</li>
<li>尽量避免在中间插入。例如可用vector存储，再用标准库算法做排序等操作来改变顺序</li>
<li>如程序分为几阶段，只有前半段必须在中间插入，则前半段用list，再拷贝到vector做后半段</li>
<li>若必须同时使用随机访问和中间插入，则看哪个占主导地位。可用实验来判断用list/forward_list还是vector/deque</li>
<li>若不确定用哪种容器，最好在程序中只用vector和list的公共操作：使用迭代器而不是下标，使用<code>++</code>/<code>--</code>而不是下标访问</li>
</ul>
</li>
</ul>
<h2 id="容器库概览">容器库概览</h2>
<ul>
<li>容器上的操作形成层次：
<ul>
<li>某些操作对<code>所有容器</code>都提供</li>
<li>某些操作仅针对<code>顺序容器</code>，某些操作仅针对<code>关联容器</code>，某些操作仅针对<code>无序容器</code></li>
<li>某些操作仅适用于<code>特定容器</code></li>
</ul>
</li>
<li>本节是针对所有容器都适用的操作，本章剩下几节只对顺序容器适用，11章介绍关联容器</li>
<li>每个容器都定义于一个<code>头文件</code>中，文件名与容器名相同。</li>
<li>容器均定义为<code>模板类</code></li>
<li>顺序容器几乎可以保存任意类型的元素，特别是，可以容器中保存容器。容器的容器在C++11之前的版本中需要多写一个空格，如<code>vector&lt;vector&lt;string&gt; &gt;</code></li>
<li>表9.2是所有容器都支持的通用操作
<img src="../cpp_figs/CPPprimer_ch9-tab_9_2.png" alt="tab_9_2"></li>
</ul>
<h3 id="迭代器">迭代器</h3>
<ul>
<li>表3.6列出了所有容器迭代器都支持的操作（例外：forward_list不支持<code>--</code>）</li>
<li>表3.7列出了<code>string</code>、<code>vector</code>、<code>deque</code>、<code>array</code>支持的迭代器算术运算。它们不适用于其他容器</li>
<li>迭代器范围：由一对迭代器表示，两迭代器指向同一容器中的元素或尾后元素。迭代器范围包含它们之间（左闭右开）的所有元素。</li>
<li>左闭右开的好处:
<ul>
<li>若begin与end相等则范围为空，不等则begin指向范围中的第一个元素</li>
<li>可使begin递增直到begin==end。以此条件做循环，可保证迭代器有效</li>
</ul>
</li>
</ul>
<h3 id="容器类型成员">容器类型成员</h3>
<ul>
<li>表9.2定义了容器通用的类型成员：
<ul>
<li>2个<code>迭代器类型</code>：<code>iterator</code>迭代器类型，<code>const_iterator</code>常量迭代器类型</li>
<li>2个<code>整型</code>：<code>size_type</code>无符号，<code>difference_type</code>有符号</li>
<li>3个<code>类型别名</code>：<code>value_type</code>元素类型，<code>reference</code>元素的左值（引用）类型，<code>const_reference</code>元素的常量引用类型</li>
</ul>
</li>
<li>大多数容器提供<code>反向迭代器</code>，它可反向遍历容器。与正向迭代器相比，其各种操作含义被颠倒。例如对反向迭代器做<code>++</code>得到上一个元素</li>
<li>要使用这些类型成员，需要用<code>::</code>指明作用域，即模板类的类名（含模板参数）</li>
</ul>
<h3 id="begin和end成员">begin和end成员</h3>
<ul>
<li><code>begin</code>和<code>end</code>成员函数得到指向容器首元素和尾后元素的迭代器，即形成包含容器中所有元素的迭代器范围</li>
<li>begin和end有多个版本：<code>rbegin</code>返回反向迭代器，<code>cbegin</code>返回常量迭代器，<code>crbegin</code>返回常量反向迭代器</li>
<li>不以c开头的（即非常量）迭代器都是被重载过的，即返回类型都可以是const/非const。因为考虑到begin可能被const/非const成员调用。</li>
<li>以c开头的（即常量）迭代器类型是C++11定义的，用于支持auto。例如有时候想用auto得到非常量对象的常量迭代器时，用<code>auto it=a.cbegin();</code>。</li>
<li>不需要写访问时，尽量都用cbegin和cend</li>
</ul>
<h3 id="容器定义和初始化">容器定义和初始化</h3>
<ul>
<li>每个容器都定义了默认构造函数。除array之外的容器默认构造函数都会创建指定类型的空容器，且都可接受指定容器大小和初始值的参数</li>
<li>表9.3是容器的定义和初始化方法
<img src="../cpp_figs/CPPprimer_ch9-tab_9_3.png" alt="tab_9_3"></li>
<li>将一个新容器创建为另一个容器的拷贝，方法有2种：
<ul>
<li>直接拷贝整个容器：两容器的类型和元素类型都必须匹配</li>
<li>拷贝一对迭代器指定的范围：不要求容器类型相同，也不要求元素类型相同，只要求元素类型可转换。但不可用于array。可拷贝元素的子序列，新容器大小与迭代器范围的大小相同。</li>
</ul>
</li>
<li>例子：将一个新容器创建为另一个容器的拷贝</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">authors</span><span class="o">=</span><span class="p">{</span><span class="s">&#34;Milton&#34;</span><span class="p">,</span><span class="s">&#34;Shakespeare&#34;</span><span class="p">,</span><span class="s">&#34;Austen&#34;</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">articles</span><span class="o">=</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="s">&#34;an&#34;</span><span class="p">,</span><span class="s">&#34;the&#34;</span><span class="p">};</span>
<span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">list2</span><span class="p">(</span><span class="n">authors</span><span class="p">);</span>                                    <span class="c1">//对，类型匹配
</span><span class="c1"></span><span class="n">deque</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">authList</span><span class="p">(</span><span class="n">authors</span><span class="p">);</span>                                <span class="c1">//错，容器类型不匹配
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">(</span><span class="n">articles</span><span class="p">);</span>                                 <span class="c1">//错，元素类型不匹配
</span><span class="c1"></span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">(</span><span class="n">articles</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">articles</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>    <span class="c1">//对，不需严格匹配
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>可对容器做列表初始化，显式指定初始值，如<code>vector&lt;string&gt; articles={&quot;a&quot;,&quot;an&quot;,&quot;the&quot;};</code>。除array外，初始化列表还隐式指定了容器的大小。</li>
<li>顺序容器（除array外）还可指定容器大小和给定初值，如<code>list&lt;string&gt; svec(10,&quot;hi!&quot;);</code>。如果不给初值，则进行值初始化（内置类型初始化为0，类类型调用默认构造函数）。这种对关联容器不适用。</li>
<li>array的大小也是类型的一部分，定义时模板参数包含元素类型和大小</li>
<li>array不可用普通的容器构造函数，因为它们都隐式确定大小。但可使用指定大小的构造函数</li>
<li>默认构造的array非空，它被填满元素，元素都被默认初始化。</li>
<li>可对array做列表初始化，列表长度须小于等于array大小，如果小于，则初始化靠前元素，剩下的被值初始化。</li>
<li>与内置数组不同的是，array允许做整个容器的拷贝和赋值，要求两array大小和元素类型都一样才行。</li>
<li>例子：array的初始化和拷贝</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">ia1</span><span class="p">;</span>                          <span class="c1">//默认初始化
</span><span class="c1"></span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">ia2</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>    <span class="c1">//列表初始化
</span><span class="c1"></span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">ia3</span><span class="o">=</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>                     <span class="c1">//剩下元素被初始化为0
</span><span class="c1"></span><span class="kt">int</span> <span class="n">digs</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">cpy</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="n">digs</span><span class="p">;</span>                           <span class="c1">//错，内置数组不可拷贝/赋值。digs被转为指针
</span><span class="c1"></span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">digits</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">copy</span><span class="o">=</span><span class="n">digits</span><span class="p">;</span>                  <span class="c1">//对，只要大小和元素类型相同即可
</span></code></pre></td></tr></table>
</div>
</div><h3 id="赋值和swap">赋值和swap</h3>
<ul>
<li>表9.4的<code>赋值</code>相关操作可用于所有容器。赋值运算符将左边容器中的所有元素替换为右边容器中元素的<code>拷贝</code>
<img src="../cpp_figs/CPPprimer_ch9-tab_9_4.png" alt="tab_9_4"></li>
<li>赋值前两容器大小可不同，赋值后大小都等于右边容器的大小</li>
<li>与内置数组不同，array允许赋值，只要两array大小和元素类型都一样</li>
<li>由于array大小固定，故只能用<code>=</code>赋值，不可用<code>assign</code>，也不可用花括号列表赋值。</li>
<li>赋值符<code>=</code>要求两侧容器类型和元素类型都相等，但<code>assign</code>不要求容器类型相同，只需要元素类型可转换即可</li>
<li><code>assign</code>用参数指定的元素替换该容器的所有元素。其参数可为：
<ul>
<li>一对迭代器范围</li>
<li>一个initializer_list（或花括号列表）</li>
<li>一个大小和初值的组合</li>
</ul>
</li>
<li>由于旧元素被替换，故传递给assign的迭代器不能指向调用assign的容器</li>
<li>例子：assign不要求容器类型和元素类型相同</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">oldstyle</span><span class="p">;</span>
<span class="n">names</span><span class="o">=</span><span class="n">oldstyle</span><span class="p">;</span>                                     <span class="c1">//错，容器类型和元素类型不匹配
</span><span class="c1"></span><span class="n">names</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">oldstyle</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">oldstyle</span><span class="p">.</span><span class="n">cend</span><span class="p">());</span>    <span class="c1">//对，只要元素类型可转换
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>swap</code>交换两个相同类型容器的内容</li>
<li>除array外，swap操作都不交换元素本身，只交换数据结构。因此都是<code>O(1)</code>时间</li>
<li>对array做swap会真正交换元素，故是<code>O(n)</code>时间</li>
<li>swap前后迭代器/指针/引用的变化：
<ul>
<li>除string和array外，指向元素的迭代器/指针/引用，在swap后都指向原来的元素，但已经属于不同的容器了。例如：<code>it</code>指向<code>svec1[3]</code>，在进行<code>swap(svec1,svec2);</code>后，<code>it</code>指向<code>svec2[3]</code>，对<code>it</code>解引用得到的结果前后一致。</li>
<li>对string使用swap导致之前的迭代器/指针/引用都失效</li>
<li>对array使用swap导致之前的迭代器/指针/引用指向的元素不变，但值发生改变，即swap前后解引用得到的值不一致（因为真的交换了值）</li>
</ul>
</li>
<li>C++11同时提供swap的成员版本和非成员版本，但在旧标准中只有成员版本。在泛型编程中多用非成员版本，即用<code>swap(a,b)</code>而不是<code>a.swap(b)</code></li>
</ul>
<h3 id="容器大小操作">容器大小操作</h3>
<ul>
<li>3个关于大小的成员函数：
<ul>
<li><code>size</code>返回容器中元素的数目</li>
<li><code>empty</code>当size为0时返回true，否则false</li>
<li><code>max_size</code>返回一个大于等于该类型容器所能容纳的最大元素数量的值</li>
</ul>
</li>
<li><code>forward_list</code>只支持<code>empty</code>和<code>max_size</code>，不支持<code>size</code></li>
</ul>
<h3 id="关系运算符">关系运算符</h3>
<ul>
<li>任何容器都支持相等运算符<code>==</code>和<code>!=</code>，除无序关联容器外都支持关系运算符<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></li>
<li>关系运算符两侧对象必须容器类型相同且元素类型相同，然后进行<code>字典顺序</code>的比较</li>
<li>只有当元素定义了相应的比较符时，才可用其比较容器</li>
<li>容器的相等是用元素的<code>==</code>实现，其他关系运算符是用元素的<code>&lt;</code>实现</li>
</ul>
<h2 id="顺序容器操作">顺序容器操作</h2>
<ul>
<li>顺序容器和关联容器的不同之处在于它们组织元素的方式。<code>顺序容器</code>中元素的顺序与其加入容器的位置对应，<code>关联容器</code>中元素的顺序由其关联的关键字决定</li>
</ul>
<h3 id="向顺序容器添加元素">向顺序容器添加元素</h3>
<ul>
<li>除array外，所有标准库容器都可在运行时动态添加/删除元素以改变容器大小</li>
<li>表9.5是向顺序容器添加元素的操作：
<img src="../cpp_figs/CPPprimer_ch9-tab_9_5.png" alt="tab_9_5"></li>
<li>在vector/string尾部之外的任何位置，或deque首尾之外的任何位置添加元素，都需要移动大量元素。且向vector/string添加元素可能引起整个容器存储空间重新分配</li>
<li><code>容器元素是拷贝</code>：用一个元素初始化容器，或把元素插入到容器中，都是拷贝。与原始对象互不影响。</li>
<li><code>push_back</code>：在尾部插入元素。除array和forward_list外，每个顺序容器都支持push_back</li>
<li><code>push_front</code>：在头部插入元素。list、forward_list、deque容器支持push_front</li>
<li><code>insert</code>：在任意位置插入0个/多个元素。vector、string、deque、list都支持insert。forward_list提供了特殊的insert</li>
<li>vector/string虽不可用push_front，但可用insert在头部插入</li>
<li>insert接受迭代器作为第一个参数，指定插入的位置，在该<code>迭代器之前</code>插入。在之前是为了考虑左闭右开区间。</li>
<li>insert后面的参数指定可插入的值，有4种：
<ul>
<li>给一个<code>值</code></li>
<li>给<code>个数和值</code>，插入多个该值</li>
<li>给一对<code>迭代器范围</code>，将此范围内的迭代器插入。此范围不可来自被插入容器</li>
<li>给一个<code>initializer_list/花括号列表</code></li>
</ul>
</li>
<li>C++11中，接受元素个数或迭代器范围的insert可返回指向<code>第一个新加入元素</code>的迭代器。如范围为空，则不插入，返回insert的第一个参数。该设计是为了重复插入</li>
<li>例子：利用insert返回值，反复插入元素</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">lst</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">iter</span><span class="o">=</span><span class="n">lst</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">word</span><span class="p">)</span>
    <span class="n">iter</span><span class="o">=</span><span class="n">lst</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="n">word</span><span class="p">);</span> <span class="c1">//等价于反复调用push_front
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>C++11引入新成员<code>emplace_front</code>、<code>emplace_back</code>、<code>emplace</code>，分别对应<code>push_front</code>、<code>push_back</code>、<code>insert</code>。区别是<code>emplace</code>是在原地构造元素，而push/insert是拷贝元素</li>
<li>push/insert可能会创建局部的临时量，再将临时量拷贝到容器</li>
<li>调用<code>emplace</code>时，它将参数传递给元素类型的构造函数，使用它们在容器的内存空间中直接构造元素。故<code>emplace的参数需对应到元素的构造函数参数</code></li>
</ul>
<h3 id="访问元素">访问元素</h3>
<ul>
<li>表9.6是顺序容器中访问元素的操作
<img src="../cpp_figs/CPPprimer_ch9-tab_9_6.png" alt="tab_9_6"></li>
<li>若访问处没有元素，则结果未定义</li>
<li>顺序容器都有<code>front</code>成员函数，除forward_list之外的顺序容器都有<code>back</code>成员函数。前者返回首元素的引用，后者返回尾元素的引用</li>
<li>front/end与begin/end的区别：
<ul>
<li>front/back返回引用，begin/end返回迭代器</li>
<li>front/back返回首元素和尾元素，begin/end返回首元素和尾后元素</li>
<li>空元素求front/back是未定义，但可求begin/end且有begin==end</li>
</ul>
</li>
<li>表9.6中访问元素的成员函数（<code>front</code>、<code>back</code>、<code>[]</code>、<code>at</code>）都返回<code>引用</code>。若要用auto，记得将变量声明为引用，否则存在拷贝且不能修改容器。</li>
<li>提供快速随机访问的容器（string、vector、deque、array）都支持下标运算符<code>[]</code>。</li>
<li>下标运算<code>[]</code>不检查下标是否在合法范围，但<code>at</code>成员函数在下标越界时抛出<code>out_of_range</code>异常</li>
</ul>
<h3 id="删除元素">删除元素</h3>
<ul>
<li>表9.7是顺序容器删除元素的操作，除array外
<img src="../cpp_figs/CPPprimer_ch9-tab_9_7.png" alt="tab_9_7"></li>
<li><code>pop_front</code>和<code>pop_back</code>成员函数分别删除首元素和尾元素</li>
<li>vector/string不支持push_front/pop_front，forward_list不支持push_front/pop_front</li>
<li>pop_front/pop_back返回void，若需要值，需在pop之前保存</li>
<li>不能对空容器做删除操作</li>
<li><code>erase</code>可从指定的任意位置删除元素，它有两个版本：
<ul>
<li>接受一个迭代器，删除它指向的元素，返回它之后位置的迭代器</li>
<li>接受一个迭代器范围，删除左闭右开区间内的元素，返回删除列表最后元素之后位置的迭代器</li>
</ul>
</li>
<li>要删除容器的所有元素，可用<code>clear</code>，也可用begin/end调用<code>erase</code></li>
</ul>
<h3 id="特殊的forward_list操作">特殊的forward_list操作</h3>
<ul>
<li>表9.8是forward_list的插入/删除操作
<img src="../cpp_figs/CPPprimer_ch9-tab_9_8.png" alt="tab_9_8"></li>
<li>对forward_list（单向链表）的元素做插入/删除，需要知道其<code>前驱</code>。</li>
<li>forward_list的插入/删除改变的不是指定元素，而是指定元素之后的一个元素</li>
<li>forward_list未定义<code>insert</code>、<code>emplace</code>、<code>erase</code>，但定义了<code>insert_after</code>、<code>emplace_after</code>、<code>erase_after</code>来提供类似操作</li>
<li>forward_list定义了<code>before_begin</code>迭代器，它指向首元素之前，称为<code>首前迭代器</code></li>
<li>使用forward_list时需关注两个元素：我们要处理的元素，和它的前驱</li>
<li>例子：用两个迭代器操作forward_list</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">flst</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">prev</span><span class="o">=</span><span class="n">flst</span><span class="p">.</span><span class="n">before_begin</span><span class="p">();</span>          <span class="c1">//要处理的元素的前驱
</span><span class="c1"></span><span class="k">auto</span> <span class="n">curr</span><span class="o">=</span><span class="n">flst</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>                 <span class="c1">//要处理的元素
</span><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="n">curr</span><span class="o">!=</span><span class="n">flst</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">curr</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">curr</span><span class="o">=</span><span class="n">flst</span><span class="p">.</span><span class="n">erase_after</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>    <span class="c1">//删除curr，返回要处理的元素的下一个迭代器，作为下一轮循环要处理的元素
</span><span class="c1"></span>    <span class="k">else</span><span class="p">{</span>
        <span class="n">prev</span><span class="o">=</span><span class="n">curr</span><span class="p">;</span>                      <span class="c1">//更新前驱
</span><span class="c1"></span>        <span class="o">++</span><span class="n">curr</span><span class="p">;</span>                         <span class="c1">//更新要处理的元素的迭代器
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="改变容器大小">改变容器大小</h3>
<ul>
<li>如表9.9是用<code>resize</code>改变大小的操作，不支持array
<img src="../cpp_figs/CPPprimer_ch9-tab_9_9.png" alt="tab_9_9"></li>
<li>对于给定的目标大小，若比当前大小更小，则容器后面的元素都被删除，若比当前大小更大，则将<code>值初始化</code>的新元素添加到容器尾部。可以指定值初始化的初始值</li>
</ul>
<h3 id="容器操作可能使迭代器失效">容器操作可能使迭代器失效</h3>
<ul>
<li>向容器中添加/删除元素可能使指向元素的指针/引用/迭代器失效</li>
<li>添加元素后：
<ul>
<li><code>vector/string</code>：若空间被重新分配，则所有指针/引用/迭代器失效。若空间未重新分配，则插入位置的之后的指针/引用/迭代器都失效</li>
<li><code>deque</code>：插入首尾之外的任何位置都使所有指针/引用/迭代器失效。在首尾插入时，迭代器失效，指向元素的指针/引用不失效</li>
<li><code>list/forward_list</code>：所有指针/引用/迭代器仍有效</li>
</ul>
</li>
<li>删除元素后：
<ul>
<li>指向被删除元素的指针/引用/迭代器一定失效</li>
<li><code>vector/string</code>：删除位置的之后的指针/引用/迭代器都失效。特别是，删除任何元素时，尾后迭代器一定失效</li>
<li><code>deque</code>：删除首尾之外的任何位置都使所有指针/引用/迭代器失效。删除首元素无影响，删除尾元素使尾后迭代器失效</li>
<li><code>list/forward_list</code>：除被删除元素之外的所有指针/引用/迭代器仍有效</li>
</ul>
</li>
<li>最佳实践：
<ul>
<li>最小化要求迭代器有效的程序片段</li>
<li>保证每次改变容器的操作后都更新迭代器</li>
<li>不要保存尾后迭代器，每次需要时都用end重新取</li>
</ul>
</li>
<li>添加/删除vector/string/deque中的元素，必须考虑指针/引用/迭代器的失效问题。用insert/erase可由返回值直接更新</li>
<li>例子：用insert/erase实时更新迭代器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">iter</span><span class="o">=</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">while</span><span class="p">(</span><span class="n">iter</span><span class="o">!=</span><span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="o">%</span><span class="mi">2</span><span class="p">){</span>
        <span class="n">iter</span><span class="o">=</span><span class="n">vi</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span> <span class="c1">//复制奇数元素，迭代器实时更新
</span><span class="c1"></span>        <span class="n">iter</span><span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
        <span class="n">iter</span><span class="o">=</span><span class="n">vi</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>        <span class="c1">//删除偶数元素，迭代器实时更新
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>添加/删除vector/string的元素，deque除首尾处任何位置的插入/删除，都会使尾后迭代器失效。因此在每次插入/删除后必须重新调用end</li>
</ul>
<h2 id="vector对象是如何增长的">vector对象是如何增长的</h2>
<ul>
<li>为支持快速随机访问，vector将元素<code>连续存储</code></li>
<li>若不使用适当的空间分配策略，则每次插入/删除操作都需要：<code>分配空间</code>、<code>拷贝元素</code>、<code>释放空间</code></li>
<li>为减少分配/释放空间的次数，vector/string要求在每次需要分配新内存空间时，会分配比所需空间更大的空间，预留作备用。之后即使会拷贝元素，但尽量不会分配/释放空间</li>
<li>表9.10提供了vector内存大小管理的操作
<img src="../cpp_figs/CPPprimer_ch9-tab_9_10.png" alt="tab_9_10"></li>
<li><code>capacity</code>操作告诉我们容器在不扩张内存时最多还能容纳多少元素</li>
<li><code>reserve</code>操作允许通知容器它至少需要容纳多少元素</li>
<li>reserve不改变元素的数量，即不改变<code>size</code>，只影响预分配的内存</li>
<li>传给reserve的值小于等于当前capacity时，reserve什么都不做。特别是，小于时不会退回空间</li>
<li>传给reserve的值大于当前capacity时，reserve扩张容量，至少分配与要求容量一样大的空间，可能更大</li>
<li>改变容器大小的<code>resize</code>方法只改变元素数量，不影响capacity</li>
<li><code>shrink_to_fit</code>是C++11的方法，它可要求vector/string/deque退回多余的空间，但具体实现可忽略此要求。即，不保证能退回。</li>
<li>capacity至少与size一样大，具体多大取决于实现</li>
<li>只要没有超出vector的capacity，vector就不会自动扩张（不会重新分配内存）</li>
<li>vector采用的<code>内存扩张策略</code>一般是：在每次需要分配新空间时，将当前容量翻倍。但具体实现可使用不同策略</li>
<li>所有扩张策略都应遵循的原则：确保用<code>push_back</code>添加元素有高效率。即，在初始为空的vector上调用n次push_back，花费时间不应超过n的常数倍</li>
</ul>
<h2 id="额外的string操作">额外的string操作</h2>
<h3 id="构造string的其他方法">构造string的其他方法</h3>
<ul>
<li>表9.11是string特有的3个<code>构造函数</code>
<img src="../cpp_figs/CPPprimer_ch9-tab_9_11.png" alt="tab_9_11"></li>
<li>这些构造函数接受<code>string</code>或<code>const char *</code>参数作为源，还接受（可选的）指定拷贝多少个字符的参数。当源为string时，还可给定下标来指定从哪里开始拷贝</li>
<li>使用<code>const char *</code>构造string时，字符数组必须以空字符<code>\0</code>结尾，用于停止拷贝。但若给定拷贝大小的计数值，则只需不越界，不需空字符结尾。</li>
<li>使用<code>string</code>构造string时，可提供开始位置和计数值。开始位置必须小于等于源string大小，否则out_of_range异常。不管要求拷贝多少，最多拷到源string结尾。</li>
<li>substring操作（表9.12）返回string，其值是原始string的一部分或全部的拷贝。可传递可选的起始位置和计数值。
<img src="../cpp_figs/CPPprimer_ch9-tab_9_12.png" alt="tab_9_12"></li>
</ul>
<h3 id="改变string的其他方法">改变string的其他方法</h3>
<ul>
<li>表9.13定义了string特有的insert/erase/assign操作
<img src="../cpp_figs/CPPprimer_ch9-tab_9_13.png" alt="tab_9_13"></li>
<li>string的<code>insert/erase</code>可接受下标，用于指定insert到指定值之前的位置，或是开始删除的位置。</li>
<li>string的<code>inset/assign</code>可接受C风格字符串</li>
<li>可将来自其他string或子串的字符串插入到当前string或给其赋值。</li>
<li>例子：string的insert/erase/assign</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">);</span>
<span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="mi">5</span><span class="p">,</span><span class="sc">&#39;!&#39;</span><span class="p">);</span>   <span class="c1">//s末尾插入5个&#39;!&#39;
</span><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>       <span class="c1">//删除最后5个字符
</span><span class="c1"></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="o">=</span><span class="s">&#34;Stately, plump Buck&#34;</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>             <span class="c1">//s==&#34;Stately&#34;
</span><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="n">cp</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span>    <span class="c1">//s==&#34;Stately, plump Buck&#34;
</span><span class="c1"></span><span class="n">string</span> <span class="n">s</span><span class="o">=</span><span class="s">&#34;some string&#34;</span><span class="p">,</span> <span class="n">s2</span><span class="o">=</span><span class="s">&#34;some other string&#34;</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s2</span><span class="p">);</span>             <span class="c1">//s位置0之前插入s2的拷贝
</span><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="c1">//s位置0之前插入s2位置0开始的s2.size()个字符
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>append是在string末尾插入的简写</li>
<li>replace是调用erase和insert的组合</li>
<li>例子：append和replace</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&#34;C++ Primer&#34;</span><span class="p">),</span> <span class="n">s2</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="s">&#34; 4th Ed.&#34;</span><span class="p">);</span>  <span class="c1">//s==&#34;C++ Primer 4th Ed.&#34;
</span><span class="c1"></span><span class="n">s2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#34; 4th Ed.&#34;</span><span class="p">);</span>          <span class="c1">//等价于上一行
</span><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>                  <span class="c1">//s==&#34;C++ Primer  Ed.&#34;
</span><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="s">&#34;5th&#34;</span><span class="p">);</span>             <span class="c1">//s==&#34;C++ Primer 5th Ed.&#34;
</span><span class="c1"></span><span class="n">s2</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s">&#34;5th&#34;</span><span class="p">);</span>         <span class="c1">//s2==&#34;C++ Primer 5th Ed.&#34;，等价于上两行
</span><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s">&#34;Fifth&#34;</span><span class="p">);</span>        <span class="c1">//s==&#34;C++ Primer Fifth Ed.&#34;
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>append、assign、insert、replace都有多个重载版本，根据如何指定要添加的字符和string中被替换的部分</li>
<li><code>指定要被替换的部分</code>：
<ul>
<li>assign/append无需指定替换哪部分：assign总是替换所有内容，append总将新字符追加到末尾</li>
<li>replace可用两种方式指定删除范围：可以用位置和长度，也可用迭代器范围</li>
<li>insert可用两种方式指定插入点：下标或迭代器</li>
</ul>
</li>
<li><code>指定要添加的字符</code>：见表9.13</li>
</ul>
<h3 id="string搜索操作">string搜索操作</h3>
<ul>
<li>如表9.14，string提供了6个搜索函数，每个函数有4个重载版本
<img src="../cpp_figs/CPPprimer_ch9-tab_9_14.png" alt="tab_9_14"></li>
<li>每个搜索操作都返回<code>string::size_type</code>类型值，表示匹配位置的下标。</li>
<li>若搜索失败，即无匹配，则返回名为<code>string::npos</code>的static成员，它是<code>string::size_type</code>类型且初始化为<code>-1</code>，即string最大的可能大小</li>
<li><code>string::size_type</code>是无符号类型，不可与int等有符号混用</li>
<li>搜索操作都是大小写敏感</li>
<li><code>find</code>查找参数字符串第一次出现的位置，<code>rfind</code>查找参数字符串最后一次出现的位置</li>
<li><code>find_first_of</code>查找参数中任何一个字符第一次出现的位置，<code>find_last_of</code>查找参数中任何一个字符最后一次出现的位置</li>
<li><code>find_first_not_of</code>查找第一个不在参数中的字符，<code>find_last_not_of</code>查找最后一个不在参数中的字符</li>
<li>可给find们指定可选的开始位置，指出从哪里开始搜索。可利用此机制<code>循环查找</code>所有匹配的位置</li>
<li>例子：循环查找所有匹配</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">numbers</span><span class="p">(</span><span class="s">&#34;0123456789&#34;</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="s">&#34;r2d2&#34;</span><span class="p">);</span>
<span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">((</span><span class="n">pos</span><span class="o">=</span><span class="n">name</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span><span class="n">pos</span><span class="p">))</span><span class="o">!=</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">){</span> <span class="c1">//每次查找一个子串
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;found number at index: &#34;</span>
        <span class="o">&lt;&lt;</span><span class="n">pos</span>
        <span class="o">&lt;&lt;</span><span class="s">&#34; element is &#34;</span>
        <span class="o">&lt;&lt;</span><span class="n">name</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="o">++</span><span class="n">pos</span><span class="p">;</span>                                                  <span class="c1">//移动到下一个字符，准备从后面的子串中查找
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="compare函数">compare函数</h3>
<ul>
<li><code>compare</code>函数类似C语言中的<code>strcmp</code>，根据源字符串等于、大于、小于给定的字符串，compare成员函数返回0、正数、负数</li>
<li>表9.15是compare函数接受的参数
<img src="../cpp_figs/CPPprimer_ch9-tab_9_15.png" alt="tab_9_15"></li>
</ul>
<h3 id="数值转换">数值转换</h3>
<ul>
<li>表9.16规定了数值数据和string间的转换
<img src="../cpp_figs/CPPprimer_ch9-tab_9_16.png" alt="tab_9_16"></li>
<li><code>to_string</code>将数值类型转为对应的string表示，其他各函数将string表示转为相应的数值类型</li>
<li>要将string转为数值，必须保证string中的第一个非空白字符是该数值类型中可能出现的字符，例如正负号、数字等，也可是<code>0x</code>或<code>0X</code>表示的十六进制数（此时string中可包含字母）。对于浮点类型，可以小数点<code>.</code>开头，并可包含<code>e</code>或<code>E</code>指定指数部分。</li>
<li>如string不能转为指定的数值类型，这些函数抛出<code>invalid_argument</code>异常</li>
<li>如转换得到的数值无法用任何类型表示，则抛出<code>out_of_range</code>异常</li>
</ul>
<h2 id="容器适配器">容器适配器</h2>
<ul>
<li><code>适配器</code>是一种机制，能使某种事物的行为看起来像另一种事物。一个<code>容器适配器</code>接受一种已有的容器类型，使其看起来像另一种不同类型</li>
<li>定义了3个<code>顺序容器适配器</code>：stack、queue、priority_queue</li>
<li>表9.17定义了所有容器适配器都支持的操作和类型
<img src="../cpp_figs/CPPprimer_ch9-tab_9_17.png" alt="tab_9_17"></li>
<li>每个适配器都有两个构造函数：
<ul>
<li>默认构造函数，创建空对象</li>
<li>接受一个容器，拷贝该容器来初始化适配器</li>
</ul>
</li>
<li>默认情况下，<code>stack</code>和<code>queue</code>基于deque实现，<code>priority_queue</code>基于vector实现。也可在创建时在模板参数里指定一个顺序容器来重载默认容器类型</li>
<li>对适配器的容器类型有限制：
<ul>
<li>不能基于array，因为要添加/删除元素</li>
<li>不能基于forward_list，因为要访问尾元素</li>
<li><code>stack</code>要求<code>back</code>、<code>push_back</code>、<code>pop_back</code>操作，故可构建于除array/forward_list外的所有容器</li>
<li><code>queue</code>要求<code>back</code>、<code>push_back</code>、<code>front</code>、<code>push_front</code>，故可构建于list/deque</li>
<li><code>priority_queue</code>要求<code>front</code>、<code>push_back</code>、<code>pop_back</code>、<code>随机访问</code>，故可构建于vector/deque</li>
</ul>
</li>
<li>stack定义于<code>stack头文件</code>中，其特有操作如表9.18
<img src="../cpp_figs/CPPprimer_ch9-tab_9_18.png" alt="tab_9_18"></li>
<li>每个适配器都基于底层容器定义了自己的特殊操作，只可用适配器操作，不可用底层容器操作</li>
<li>queue和priority_queue定义于<code>queue头文件</code>中，其特有操作如表9.19
<img src="../cpp_figs/CPPprimer_ch9-tab_9_19.png" alt="tab_9_19"></li>
<li>priority_queue允许为队列中的元素建立优先级，新加入的元素会排在所有优先级比它低的已有元素之前。默认情况下使用元素类型的<code>&lt;</code>运算符来确定优先级</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">canpi</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-02-19
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_wechat.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_alipay.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          <a href="/tags/c&#43;&#43;-primer/">C&#43;&#43; primer</a>
          <a href="/tags/%E8%AF%BB%E4%B9%A6/">读书</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cpp/cppprimer_ch10/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43; primer 第10章 泛型算法</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/cpp/cppprimer_ch8/">
            <span class="next-text nav-default">C&#43;&#43; primer 第8章 IO库</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/cpp/cppprimer_ch9/" class="leancloud_visitors" data-flag-title="C&#43;&#43; primer 第9章 顺序容器">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'ntftaTIdLaT8sVPL9qFX5dAg-gzGzoHsz',
        appKey: 'lNOKznaI2Gnej5D2MgpUJnzV',
        notify:  false ,
        verify:  false ,
        avatar:'retro',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hucanpei@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/hucanpei" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/canpi" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">canpi</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>








</body>
</html>
