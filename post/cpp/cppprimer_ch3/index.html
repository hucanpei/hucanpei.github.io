<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; primer 第3章 字符串、向量和数组 - pi</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="canpi" /><meta name="description" content="string和vector是两类最重要的标准库类型，strng表示可变长的字符序列，vector存放某种给定类型对象的可变长序列。 迭代器是s" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.74.3 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/cpp/cppprimer_ch3/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; primer 第3章 字符串、向量和数组" />
<meta property="og:description" content="string和vector是两类最重要的标准库类型，strng表示可变长的字符序列，vector存放某种给定类型对象的可变长序列。 迭代器是s" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/cpp/cppprimer_ch3/" />
<meta property="article:published_time" content="2020-02-03T15:13:00+08:00" />
<meta property="article:modified_time" content="2020-02-03T15:13:00+08:00" />
<meta itemprop="name" content="C&#43;&#43; primer 第3章 字符串、向量和数组">
<meta itemprop="description" content="string和vector是两类最重要的标准库类型，strng表示可变长的字符序列，vector存放某种给定类型对象的可变长序列。 迭代器是s">
<meta itemprop="datePublished" content="2020-02-03T15:13:00+08:00" />
<meta itemprop="dateModified" content="2020-02-03T15:13:00+08:00" />
<meta itemprop="wordCount" content="6523">



<meta itemprop="keywords" content="C&#43;&#43;,C&#43;&#43; primer,读书," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; primer 第3章 字符串、向量和数组"/>
<meta name="twitter:description" content="string和vector是两类最重要的标准库类型，strng表示可变长的字符序列，vector存放某种给定类型对象的可变长序列。 迭代器是s"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">canpi</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">canpi</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; primer 第3章 字符串、向量和数组</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-02-03 </span>
        
          <span class="more-meta"> 约 6523 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#命名空间的using声明">命名空间的using声明</a></li>
    <li><a href="#标准库类型string">标准库类型string</a>
      <ul>
        <li><a href="#定义和初始化string对象">定义和初始化string对象</a></li>
        <li><a href="#string对象上的操作">string对象上的操作</a></li>
        <li><a href="#处理string对象中的字符">处理string对象中的字符</a></li>
      </ul>
    </li>
    <li><a href="#标准库类型vector">标准库类型vector</a>
      <ul>
        <li><a href="#定义和初始化vector对象">定义和初始化vector对象</a></li>
        <li><a href="#向vector对象中添加元素">向vector对象中添加元素</a></li>
        <li><a href="#其他vector操作">其他vector操作</a></li>
      </ul>
    </li>
    <li><a href="#迭代器介绍">迭代器介绍</a>
      <ul>
        <li><a href="#使用迭代器">使用迭代器</a></li>
        <li><a href="#迭代器运算">迭代器运算</a></li>
      </ul>
    </li>
    <li><a href="#数组">数组</a>
      <ul>
        <li><a href="#定义和初始化内置数组">定义和初始化内置数组</a></li>
        <li><a href="#访问数组元素">访问数组元素</a></li>
        <li><a href="#指针和数组">指针和数组</a></li>
        <li><a href="#c风格字符串">C风格字符串</a></li>
        <li><a href="#与旧代码的接口">与旧代码的接口</a></li>
      </ul>
    </li>
    <li><a href="#多维数组">多维数组</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <ul>
<li><code>string</code>和<code>vector</code>是两类最重要的标准库类型，<code>strng</code>表示可变长的字符序列，<code>vector</code>存放某种给定类型对象的可变长序列。</li>
<li><code>迭代器</code>是string和vector的配套类型，常被用于访问string的字符或vector的元素。</li>
<li><code>内置数组</code>是更基础的类型，string和vector都是对它的抽象。</li>
<li><code>内置类型</code>是由C++语言直接定义的，体现了大多数计算机硬件本身具备的能力。<code>标准库</code>定义了另一组具有更高级性质的类型。</li>
</ul>
<h2 id="命名空间的using声明">命名空间的using声明</h2>
<ul>
<li><code>域操作符::</code>：编译器从操作符左侧名字所示的作用域中寻找右侧的名字。</li>
<li>使用<code>using声明</code>就不需要每次指定命名空间就能使用一个名字，形如<code>using namespace::name;</code>，这样以后可直接使用<code>name</code>。</li>
<li>每个<code>using</code>引入一个名字，因此每个名字都必须有自己的using</li>
<li>由于头文件的代码会被拷贝到引用它的文件中，故头文件的代码不应使用using</li>
</ul>
<h2 id="标准库类型string">标准库类型string</h2>
<ul>
<li><code>string</code>是标准库类型，表示可变长字符序列，定义在头文件<code>string</code>和命名空间<code>std</code>中。</li>
</ul>
<h3 id="定义和初始化string对象">定义和初始化string对象</h3>
<ul>
<li>如何初始化类的对象是由类本身定义。</li>
<li>例子：string的初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="n">s1</span><span class="p">;</span>          <span class="c1">//默认初始化，为空字符串
</span><span class="c1"></span><span class="n">string</span> <span class="nf">s2</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>      <span class="c1">//直接初始化，s2是s1的副本
</span><span class="c1"></span><span class="n">string</span> <span class="n">s2</span><span class="o">=</span><span class="n">s1</span><span class="p">;</span>       <span class="c1">//拷贝初始化，s2是s1的副本，等价于上一行
</span><span class="c1"></span><span class="n">string</span> <span class="nf">s3</span><span class="p">(</span><span class="s">&#34;hiya&#34;</span><span class="p">);</span>  <span class="c1">//直接初始化，初始化为字面值常量
</span><span class="c1"></span><span class="n">string</span> <span class="n">s3</span><span class="o">=</span><span class="s">&#34;hiya&#34;</span><span class="p">;</span>   <span class="c1">//拷贝初始化，初始化为字面值常量，等价于上一行
</span><span class="c1"></span><span class="n">string</span> <span class="nf">s4</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">);</span>  <span class="c1">//直接初始化，初始化为10个字符&#39;c&#39;
</span></code></pre></td></tr></table>
</div>
</div><p><img src="../cpp_figs/CPPprimer_ch3-tab_3_1.png" alt="tab_3_1"></p>
<ul>
<li><code>直接初始化</code>：不用等号，而用括号初始化变量。调用构造函数</li>
<li><code>拷贝初始化</code>：用等号初始化变量。调用重载的赋值运算符</li>
<li>可以先用<code>直接初始化</code>构造<code>临时量</code>，然后<code>拷贝初始化</code>：<code>string s=string(10,'c');</code></li>
</ul>
<h3 id="string对象上的操作">string对象上的操作</h3>
<ul>
<li>类既能定义通过函数名调用的操作（<code>成员函数</code>），又能定义<code>&lt;&lt;</code>、<code>+</code>等各种运算符在该类对象上的新含义（<code>重载运算符</code>）。下表列举string对象可进行的大多数操作：
<img src="../cpp_figs/CPPprimer_ch3-tab_3_2.png" alt="tab_3_2"></li>
<li>从iostream中读取string：用<code>&gt;&gt;</code>读取时，string对象忽略开头的空白（包括空格、换行、制表符等），从第一个真正的字符读起，直到下一处空白为止。</li>
<li>string对象的<code>&lt;&lt;</code>和<code>&gt;&gt;</code>也是返回运算符左侧的iostream对象。</li>
<li>如要在iostream中读取时保留空白，需用<code>getline函数</code>，该函数从iostream中读取内容，直到遇到换行（换行也被读入），然后把读到的内容存入string对象（不存换行符）。</li>
<li>getline也返回它的iostream，故也可作为while的条件。</li>
<li><code>empty函数</code>根据string对象是否为空返回一个bool</li>
<li><code>size函数</code>返回string对象的长度（字符数）</li>
<li>size函数返回的类型是<code>string::size_type</code>（可用decltype得到），它是<code>无符号</code>类型，且能放下任何string对象的大小。（attention：不能将size与int等有符号类型混合计算）</li>
<li><code>==</code>和<code>!=</code>验证两字符串内容是否完全相同，<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>比较两字符串的<code>字典顺序</code>（大小写敏感）</li>
<li>用<code>=</code>进行string对象的拷贝和赋值</li>
<li>用<code>+</code>拼接两string对象，也可拼接一个string对象和一个字符串字面值（类型转换），但不能拼接两个字符串字面值。因为<code>string和字符串字面值是不同的类型</code></li>
</ul>
<h3 id="处理string对象中的字符">处理string对象中的字符</h3>
<ul>
<li>在<code>cctype头文件</code>中定义了一组函数用于处理字符，如下表：
<img src="../cpp_figs/CPPprimer_ch3-tab_3_3.png" alt="tab_3_3"></li>
<li>C++标准库兼容了C标准库，C中命名为<code>name.h</code>的头文件，在C++中被命名为<code>cname</code>，它们内容一样，但<code>cname</code>中的名字属于命名空间<code>std</code>，<code>name.h</code>中的名字不属于任何命名空间。（所以最好不要用C标准库）</li>
<li><code>范围for语句</code>：用<code>for(declaration:expression)</code>遍历给定序列的每个元素。其中<code>expression</code>是一个序列，<code>declaration</code>定义一个变量，用于访问序列中的元素，常用auto。</li>
<li>使用范围for时，如果要改变序列中元素的值，必须把循环变量定义为<code>引用</code>类型。</li>
<li>例子：范围for中改变元素</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&#34;hello,world!&#34;</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">c</span><span class="p">:</span><span class="n">s</span><span class="p">)</span>  <span class="c1">//要改变序列中的元素，必须声明为引用类型
</span><span class="c1"></span>    <span class="n">c</span><span class="o">=</span><span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>访问string对象中的单个字符有两种方式：<code>下标</code>和<code>迭代器</code></li>
<li><code>下标运算符[]</code>接受<code>string::size_type</code>（unsigned）类型的值，返回该位置上字符的<code>引用</code>（因此可修改字符）。若给索引提供signed值，会转为string::size_type表示的unsigned</li>
<li>例子：用下标迭代</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>             <span class="c1">//用decltype推出string::size_type类型
</span><span class="c1"></span>    <span class="n">index</span><span class="o">!=</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>  <span class="c1">//逻辑与，只有左侧为真时才检查右侧。故能保证下标合理时才访问
</span><span class="c1"></span>    <span class="o">++</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">=</span><span class="n">toupper</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]);}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="标准库类型vector">标准库类型vector</h2>
<ul>
<li><code>vector</code>表示对象的集合，所有对象的类型都相同。</li>
<li>由于vector容纳着其他对象，故称为<code>容器</code></li>
<li>vector是一个类模板。C++中有<code>类模板</code>和<code>函数模板</code>。模板本身不是类或函数，可将模板看作为编译器生成类或函数的一份说明。编译器根据模板创建类或函数的过程称为<code>实例化</code></li>
<li>由模板生成类或函数时，必须指定类型</li>
<li>在C++11之前，元素为vector的vector对象，模板变量里必须有空格</li>
<li>例子：根据模板vector声明对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">;</span>               <span class="c1">//元素是int型对象
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Sales_item</span><span class="o">&gt;</span> <span class="n">Sales_vec</span><span class="p">;</span>   <span class="c1">//元素是Sales_item类型的对象
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">file</span><span class="p">;</span>    <span class="c1">//元素是vector&lt;string&gt;类型的对象
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">file</span><span class="p">;</span>   <span class="c1">//C++11之前的写法，元素是vector&lt;string&gt;类型的对象
</span></code></pre></td></tr></table>
</div>
</div><h3 id="定义和初始化vector对象">定义和初始化vector对象</h3>
<p><img src="../cpp_figs/CPPprimer_ch3-tab_3_4.png" alt="tab_3_4"></p>
<ul>
<li>vector的初始化方法有直接初始化、拷贝初始化、列表初始化</li>
<li>通常创建vector对象的方法是：先默认初始化得到一个空vector，再向其中添加元素</li>
<li><code>列表初始化</code>：用花括号<code>{}</code>括起来的0个或多个元素赋值给vector对象。</li>
<li><code>值初始化</code>：可以只提供vector的元素数量而不提供初始值。此时元素都会被值初始化。如果元素是内置类型，会被置为0，如果元素是类类型，由类默认初始化（有些类不支持默认初始化，这时vector也无法初始化）。</li>
<li>初始化的真实含义依赖于传参时用圆括号还是花括号。圆括号是构造，花括号是列表初始化。但当花括号无法初始化时，会尝试将花括号代替为圆括号。</li>
<li>例子：vector构造和列表初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>         <span class="c1">//有10个元素，都是0
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>         <span class="c1">//有1个元素，值是10
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>       <span class="c1">//有10个元素，都是1
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v4</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>       <span class="c1">//有2个元素，分别是10和1
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v5</span><span class="p">{</span><span class="s">&#34;hi&#34;</span><span class="p">};</span>    <span class="c1">//有1个元素，是字符串&#34;hi&#34;
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v6</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">);</span>    <span class="c1">//错，不能用字符串字面值构造vector
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v7</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>      <span class="c1">//不能列表初始化，转为构造。有10个元素，都是空字符串
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v8</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="s">&#34;hi&#34;</span><span class="p">};</span> <span class="c1">//不能列表初始化，转为构造。有10个元素，都是&#34;hi&#34;
</span></code></pre></td></tr></table>
</div>
</div><h3 id="向vector对象中添加元素">向vector对象中添加元素</h3>
<ul>
<li><code>push_back函数</code>：把一个对象当vector的尾元素压入vector尾端</li>
<li>实际上，建立空对象再向其中push_back非常高效，比创建时确定大小之后再修改的方式更快。</li>
<li><code>范围for循环体内不应该改变其遍历序列的大小</code>。</li>
</ul>
<h3 id="其他vector操作">其他vector操作</h3>
<p><img src="../cpp_figs/CPPprimer_ch3-tab_3_5.png" alt="tab_3_5"></p>
<ul>
<li>vector的<code>size方法</code>返回该vector的元素数量，类型是<code>vector&lt;type&gt;::size_type</code>类型。使用size_type时，需首先指定是哪种类型的size_type。</li>
<li>只有元素类型可比较时才能将vector按字典顺序比较。</li>
<li>对vector索引时，下标类型是相应的size_type类型</li>
<li>不能用下标添加元素，用下标访问不存在的元素会引发错误（编译不报错），例如<code>缓冲区溢出</code>等</li>
<li>确保访问元素有效的方法之一是使用<code>范围for</code></li>
</ul>
<h2 id="迭代器介绍">迭代器介绍</h2>
<ul>
<li><code>迭代器</code>比下标访问更通用。所有标准库容器都支持迭代器，但只有几种支持下标。</li>
<li>string对象不属于容器，但操作上和容器很接近</li>
<li>迭代器提供了对元素对象的<code>间接访问</code>，类似于指针。其对象是容器中的元素，或string中的字符</li>
<li><code>有效</code>的迭代器或者指向某个元素，或者指向尾元素的下一位置，其他都是无效。</li>
</ul>
<h3 id="使用迭代器">使用迭代器</h3>
<ul>
<li>有迭代器的类型都配套有返回迭代器的成员。其中<code>begin方法</code>返回指向首元素的迭代器，<code>end方法</code>返回指向尾元素的下一位置（尾后）的迭代器。空容器的begin()和end()返回同一迭代器。</li>
<li>从函数中返回迭代器时，类型用<code>auto</code>，不用管迭代器的类型。
<img src="../cpp_figs/CPPprimer_ch3-tab_3_6.png" alt="tab_3_6"></li>
<li>可用<code>解引用符*</code>访问迭代器指向的元素，类似指针。试图解引用无效或尾后迭代器都是未定义。</li>
<li>对迭代器使用<code>++</code>可移动到下一个元素，它们是逻辑上先后的关系，空间上不一定相邻。</li>
<li>用<code>++</code>、<code>--</code>、<code>==</code>、<code>!=</code>来进行遍历操作，因为这些操作在所有容器的迭代器上都有效。而索引和<code>&lt;</code>、<code>&gt;</code>等操作符在大多数容器的迭代器中未定义。</li>
<li>迭代器的类型是相应容器类型的<code>iterator</code>和<code>const_iterator</code>，前者可读可写，后者只能读。类型书写如<code>vector&lt;int&gt;::iterator</code>。每个容器都定义了一个名为iterator的类型。</li>
<li>如果容器内对象为常量，则<code>begin</code>和<code>end</code>返回<code>const_iterator</code>迭代器，否则返回<code>iterator</code>迭代器</li>
<li><code>cbegin方法</code>和<code>cend方法</code>对任何容器都返回<code>const_iterator</code>迭代器</li>
<li>通过迭代器调用元素对象的成员时，使用诸如<code>(*it).function()</code>，括号必不可少，不然<code>it</code>先取成员再解引用。</li>
<li>通过迭代器调用元素对象的成员时，亦可使用简化的<code>-&gt;操作符</code>，它将解引用和取成员两个操作结合，<code>it-&gt;function()</code>等价于<code>(*it).function()</code></li>
<li>任何可能改变容器容量的操作，如<code>push_back</code>，都会使容器的迭代器失效。</li>
</ul>
<h3 id="迭代器运算">迭代器运算</h3>
<ul>
<li><code>string</code>和<code>vector</code>是顺序存储，故它们的迭代器支持更多的操作，如<code>迭代器运算</code>，这些操作可使迭代器每次移动跨越多个元素，也可对迭代器比较大小。
<img src="../cpp_figs/CPPprimer_ch3-tab_3_7.png" alt="tab_3_7"></li>
<li>可使迭代器和整数值相加减，返回值是向前或向后移动若干位置的迭代器。</li>
<li>可使用关系运算符<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>对迭代器比较大小</li>
<li>将迭代器相减，结果是两迭代器的<code>距离</code>，指的是右侧迭代器向前移动多少位置能和左侧迭代器重合，距离可正可负。其类型是容器类型对应的<code>difference_type</code>，是<code>signed</code>的整型数。</li>
</ul>
<h2 id="数组">数组</h2>
<ul>
<li><code>数组</code>也是存放类型相同的对象的容器，这些对象本身没有名字，通过在数组中的位置访问。</li>
<li>数组大小确定不变，不能增加元素。性能比vector等容器更好。</li>
</ul>
<h3 id="定义和初始化内置数组">定义和初始化内置数组</h3>
<ul>
<li>数组是一种<code>复合类型</code>，声明形如<code>int a[d];</code>，其中<code>a</code>是数组名，<code>d</code>是数组大小。<code>数组大小也是类型的一部分</code>，在编译时应该已知，必须是<code>常量表达式</code>。</li>
<li>默认情况下，数组元素被默认初始化</li>
<li>定义数组时应手动写出类型，不可用auto，但可用decltype</li>
<li>可对数组做列表初始化，此时不用手动指定大小，列表长度就是数组大小。如果手动指定大小，大小只能大于或等于初值列表大小，用初值列表初始化靠前元素，其后的默认初始化。</li>
<li>字符数组比较特殊，可用字符串字面值初始化，且不需手动指定大小，此时会在最后加上空字符。</li>
<li>例子：字符数组初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">a1</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="sc">&#39;C&#39;</span><span class="p">,</span><span class="sc">&#39;+&#39;</span><span class="p">,</span><span class="sc">&#39;+&#39;</span><span class="p">};</span>        <span class="c1">//列表初始化，无空字符
</span><span class="c1"></span><span class="kt">char</span> <span class="n">a1</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="sc">&#39;C&#39;</span><span class="p">,</span><span class="sc">&#39;+&#39;</span><span class="p">,</span><span class="sc">&#39;+&#39;</span><span class="p">,</span><span class="sc">&#39;\0&#39;</span><span class="p">};</span>   <span class="c1">//列表初始化，有空字符
</span><span class="c1"></span><span class="kt">char</span> <span class="n">a3</span><span class="p">[]</span><span class="o">=</span><span class="s">&#34;C++&#34;</span><span class="p">;</span>                <span class="c1">//字符串字面值初始化，有空字符
</span><span class="c1"></span><span class="k">const</span> <span class="kt">char</span> <span class="n">a4</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="s">&#34;Daniel&#34;</span><span class="p">;</span>      <span class="c1">//错，没有空间放空字符了
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>不能将数组拷贝给其他数组作为初值，也不能用数组为数组赋值。因为数组名是首元素地址，不能代表整个数组。有些<code>编译器扩展</code>可能支持数组的拷贝，尽量不使用。</li>
<li>解读带数组的声名符：从内向外，从右向左</li>
<li>例子：<code>指针数组</code>、<code>数组指针</code>、<code>数组引用</code>的声明</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ptrs</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>          <span class="c1">//指针的数组。是长度为10的数组，元素是指针，指向int型
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refs</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="cm">/*?*/</span>     <span class="c1">//错，引用不是对象，不存在引用的数组
</span><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">Parray</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span><span class="o">=&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">//数组的指针。是指针，指向长度为10的数组，元素是int型
</span><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arrRef</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="n">arr</span><span class="p">;</span>  <span class="c1">//数组的引用。是引用，引用长度为10的数组，元素是int型
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arry</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="n">ptrs</span><span class="p">;</span>  <span class="c1">//指针数组的引用。是引用，引用长度为10的数组，元素是指针，指向int型
</span></code></pre></td></tr></table>
</div>
</div><h3 id="访问数组元素">访问数组元素</h3>
<ul>
<li>数组元素可用范围for或下标访问</li>
<li>使用数组下标时，将其定义为<code>size_t</code>型，它是一种机器相关的unsigned类型，它足够大以表示内存中任意对象的大小，定义于<code>cstddef头文件</code>中。</li>
<li>数组的下标类型由C++语言定义，vector等容器的下标类型由标准库定义。</li>
</ul>
<h3 id="指针和数组">指针和数组</h3>
<ul>
<li>使用数组名的时候，编译器一般会将其转换为指向首元素的指针。</li>
<li>对数组元素用<code>取地址符&amp;</code>能手动得到其指针</li>
<li>当数组名作为<code>auto</code>变量初值时，推出的类型是指针而非数组，效果相当于对首元素取地址再给初值。但用<code>decltype</code>时，得到的是数组类型。</li>
<li>指针也是迭代器，string和vector的迭代器支持的运算都可被数组指针支持。</li>
<li>用<code>begin</code>和<code>end</code>得到数组的首元素指针和尾后指针，这两个函数定义于<code>iterator头文件</code>中。由于数组不是类，故它们也不是成员方法</li>
<li>两指针相减的结果类型是<code>ptrdiff_t</code>，定义于<code>cstddef头文件</code>，是一种signed类型。</li>
<li>指针运算与下标：表达式<code>*(ia+4)</code>计算指针<code>ia</code>前进4个元素后的新地址并解引用，等价于<code>ia[4]</code></li>
<li>指针可使用下标。实际上，<code>对数组使用下标，其实是对首元素指针使用下标</code>。此时编译器将数组名转为首元素指针，再对指针使用下标。</li>
<li>标准库内的迭代器下标必须为unsigned，但指针的下标是C++内置，可以处理负值，即<code>指针可接受signed下标</code></li>
</ul>
<h3 id="c风格字符串">C风格字符串</h3>
<ul>
<li><code>C风格字符串</code>不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存在字符数组中且以空字符结束。一般用<code>字符指针</code>操作它们。</li>
<li>一些操作C风格字符串的函数被定义在<code>cstring头文件</code>中，传入这些函数的是字符指针，必须指向以空字符作为结束的数组。对这些函数而言，空字符是字符串结束的标志。
<img src="../cpp_figs/CPPprimer_ch3-tab_3_8.png" alt="tab_3_8"></li>
<li>由于C风格字符串是字符指针，故：
<ul>
<li>用<code>==</code>比较string对象，但只能用<code>strcmp函数</code>比较C风格字符串</li>
<li>用<code>+</code>拼接string对象，但只能用<code>strcat函数</code>拼接C风格字符串</li>
<li>用<code>=</code>拷贝string对象，但只能用<code>strcpy函数</code>拼接C风格字符串</li>
</ul>
</li>
<li>对于strcat和strcpy，需提供存放结果的空间，并由程序员确保此空间不会溢出。</li>
<li>用标准库的string对象比C风格字符串更安全</li>
</ul>
<h3 id="与旧代码的接口">与旧代码的接口</h3>
<ul>
<li>任何可出现字符串字面值的地方都可用C风格字符串（空字符结束的字符数组）替代，例如构造string、使用string的运算符时</li>
<li>如果程序需要C风格字符串，不能直接用string对象代替。应该用string对象的<code>c_str方法</code>返回它对应的C风格字符串，且指针类型是<code>const char *</code>，保证不会改变string的内容。</li>
<li>不允许用数组初始化另一个数组，不允许用vector对象初始化数组，但允许用数组初始化vector对象。更进一步，可以用一对迭代器初始化vector对象。</li>
<li>例子：用数组的一对迭代器初始化vector对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">int_arr</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">int_arr</span><span class="p">),</span><span class="n">end</span><span class="p">(</span><span class="n">int_arr</span><span class="p">));</span> <span class="c1">//用数组的一对迭代器初始化vector对象
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>尽量用vector和迭代器，不要用数组和指针</li>
<li>尽量用string，不要用C风格字符串</li>
</ul>
<h2 id="多维数组">多维数组</h2>
<ul>
<li>C++语言并无多维数组，<code>多维数组是数组的数组</code>。</li>
<li>对于<code>二维数组</code>而言，第一个维度为<code>行</code>，第二个维度为<code>列</code></li>
<li>可对数组用列表初始化，花括号可嵌套也可不嵌套。因为<code>数组连续存储</code></li>
<li>例子：多维数组的定义、绑定一行</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span> <span class="c1">//ia是3元素数组，每个元素是4元素数组，ia三行四列。将前两行初始化，第三行默认初始化
</span><span class="c1"></span><span class="kt">int</span> <span class="n">ib</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="p">{{</span><span class="mi">0</span><span class="p">},{</span><span class="mi">4</span><span class="p">},{</span><span class="mi">8</span><span class="p">}};</span>     <span class="c1">//ib是3元素数组，每个元素是4元素数组，ia三行四列。将第一列初始化，其余元素默认初始化
</span><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">row</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">ia</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>             <span class="c1">//row是引用，引用一个4元素数组，其元素类型为int，被初始化为ia的第二行
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果要用<code>范围for</code>和<code>auto</code>处理多维数组，除了最内层循环，其他所有循环的auto类型都应该是引用。</li>
<li>例子：范围for语句处理多维数组</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 修改元素
</span><span class="c1"></span><span class="n">size_t</span> <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">row</span><span class="p">:</span><span class="n">ia</span><span class="p">){</span>      <span class="c1">//遍历行，外层循环声明为引用的原因是避免数组被auto为指针
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">col</span><span class="p">:</span><span class="n">row</span><span class="p">){</span> <span class="c1">//遍历列，内层循环声明为引用的原因是要修改元素
</span><span class="c1"></span>        <span class="n">col</span><span class="o">=</span><span class="n">cnt</span><span class="p">;</span>        <span class="c1">//修改元素
</span><span class="c1"></span>        <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 打印元素
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">row</span><span class="p">:</span><span class="n">ia</span><span class="p">)</span> <span class="c1">//避免数组被auto为指针
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">col</span><span class="p">:</span><span class="n">row</span><span class="p">)</span>   <span class="c1">//最内层循环是元素不是数组，不存在被auto为指针的问题
</span><span class="c1"></span>        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">col</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">// 错误例子
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">row</span><span class="p">:</span><span class="n">ia</span><span class="p">)</span>        <span class="c1">//ia被auto为指针类型
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">col</span><span class="p">:</span><span class="n">row</span><span class="p">)</span>   <span class="c1">//错，指针不可遍历
</span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">canpi</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-02-03
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_wechat.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_alipay.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          <a href="/tags/c&#43;&#43;-primer/">C&#43;&#43; primer</a>
          <a href="/tags/%E8%AF%BB%E4%B9%A6/">读书</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cpp/cppprimer_ch4/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43; primer 第4章 表达式</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/cpp/cppprimer_ch2/">
            <span class="next-text nav-default">C&#43;&#43; primer 第2章 变量和基本类型</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/cpp/cppprimer_ch3/" class="leancloud_visitors" data-flag-title="C&#43;&#43; primer 第3章 字符串、向量和数组">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'ntftaTIdLaT8sVPL9qFX5dAg-gzGzoHsz',
        appKey: 'lNOKznaI2Gnej5D2MgpUJnzV',
        notify:  false ,
        verify:  false ,
        avatar:'retro',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hucanpei@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/hucanpei" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/canpi" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>canpi</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
