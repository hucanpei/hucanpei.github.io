<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; primer 第14章 重载运算与类型转换 - pi</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="canpi" /><meta name="description" content="当运算符被用于类类型对象时，可利用运算符重载为其指定新含义（以提升可读性） 可自定义类类型之间的转换规则 基本概念 重载的算符是特殊的函数：名字由" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.67.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/cpp/cppprimer_ch14/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.78f8f17bab244b9ee62ad16480c9584d5fc2db06ae20681d1ca225cefd80767c.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; primer 第14章 重载运算与类型转换" />
<meta property="og:description" content="当运算符被用于类类型对象时，可利用运算符重载为其指定新含义（以提升可读性） 可自定义类类型之间的转换规则 基本概念 重载的算符是特殊的函数：名字由" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/cpp/cppprimer_ch14/" />
<meta property="article:published_time" content="2020-03-20T15:50:00+08:00" />
<meta property="article:modified_time" content="2020-03-20T15:50:00+08:00" />
<meta itemprop="name" content="C&#43;&#43; primer 第14章 重载运算与类型转换">
<meta itemprop="description" content="当运算符被用于类类型对象时，可利用运算符重载为其指定新含义（以提升可读性） 可自定义类类型之间的转换规则 基本概念 重载的算符是特殊的函数：名字由">
<meta itemprop="datePublished" content="2020-03-20T15:50:00&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-20T15:50:00&#43;08:00" />
<meta itemprop="wordCount" content="10349">



<meta itemprop="keywords" content="C&#43;&#43;,C&#43;&#43; primer,读书," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; primer 第14章 重载运算与类型转换"/>
<meta name="twitter:description" content="当运算符被用于类类型对象时，可利用运算符重载为其指定新含义（以提升可读性） 可自定义类类型之间的转换规则 基本概念 重载的算符是特殊的函数：名字由"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">canpi</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">canpi</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; primer 第14章 重载运算与类型转换</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-03-20 </span>
        <div class="post-category">
            <a href="/categories/c&#43;&#43;/"> C&#43;&#43; </a>
            <a href="/categories/c&#43;&#43;-primer/"> C&#43;&#43; primer </a>
            </div>
          <span class="more-meta"> 约 10349 字 </span>
          <span class="more-meta"> 预计阅读 21 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#基本概念">基本概念</a></li>
    <li><a href="#输入和输出运算符">输入和输出运算符</a>
      <ul>
        <li><a href="#重载输出运算符">重载输出运算符</a></li>
        <li><a href="#重载输入运算符">重载输入运算符</a></li>
      </ul>
    </li>
    <li><a href="#算术和关系运算符">算术和关系运算符</a>
      <ul>
        <li><a href="#相等运算符">相等运算符</a></li>
        <li><a href="#关系运算符">关系运算符</a></li>
      </ul>
    </li>
    <li><a href="#赋值运算符">赋值运算符</a></li>
    <li><a href="#下标运算符">下标运算符</a></li>
    <li><a href="#递增和递减运算符">递增和递减运算符</a></li>
    <li><a href="#成员访问运算符">成员访问运算符</a></li>
    <li><a href="#函数调用运算符">函数调用运算符</a>
      <ul>
        <li><a href="#lambda是函数对象">lambda是函数对象</a></li>
        <li><a href="#标准库定义的函数对象">标准库定义的函数对象</a></li>
        <li><a href="#可调用对象与function">可调用对象与function</a></li>
      </ul>
    </li>
    <li><a href="#重载类型转换与运算符">重载、类型转换与运算符</a>
      <ul>
        <li><a href="#类型转换运算符">类型转换运算符</a></li>
        <li><a href="#避免有二义性的类型转换">避免有二义性的类型转换</a></li>
        <li><a href="#函数匹配与重载运算符">函数匹配与重载运算符</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <ul>
<li>当运算符被用于类类型对象时，可利用运算符重载为其指定新含义（以提升可读性）</li>
<li>可自定义类类型之间的转换规则</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<ul>
<li><code>重载的算符</code>是特殊的函数：名字由关键字<code>operator</code>后接要定义的算符共同组成，也有返回类型、参数列表、函数体。</li>
<li>重载算符函数的参数量与该算符作用的运算对象数量一样多</li>
<li>除重载调用算符<code>operator()</code>外，其他重载算符不能有默认实参</li>
<li>若一个重载算符是成员函数，则其第一个运算对象（左侧对象）隐式绑定到该类的<code>this</code>指针上。故成员函数的显式参数数量比运算对象数量少1</li>
<li>不可重载内置类型的算符。即，重载算符或者是类的成员，或者至少有一个类类型参数</li>
<li>可重载的算符见表14.1
<img src="../cpp_figs/CPPprimer_ch14-tab_14_1.png" alt="tab_14_1"></li>
<li>只能重载已有的算符，不可发明新的算符</li>
<li><code>+</code>、<code>-</code>、<code>*</code>、<code>&amp;</code>这4个既可是一元算符也可是二元算符，都可被重载，根据参数数量判断是哪种。</li>
<li>重载算符的<code>优先级</code>和<code>结合律</code>与对应的内置算符一致，但<code>求值顺序</code>和<code>短路求值</code>不会被保留</li>
<li>可用算符形式调用重载算符，也可直接用函数名</li>
<li>例子：可用函数名调用重载算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//对于非成员函数算符，下两行等价
</span><span class="c1"></span><span class="n">data1</span><span class="o">+</span><span class="n">data2</span><span class="p">;</span>
<span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span><span class="n">data2</span><span class="p">);</span>
<span class="c1">//对于成员函数算符，下两行等价
</span><span class="c1"></span><span class="n">data1</span><span class="o">+=</span><span class="n">data2</span><span class="p">;</span>
<span class="n">data1</span><span class="p">.</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">data2</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>不建议重载的算符：
<ul>
<li><code>&amp;&amp;</code>、<code>||</code>、<code>,</code>的求值顺序不会被保留（因为算符重载本质是函数调用）</li>
<li><code>&amp;&amp;</code>、<code>||</code>的短路求值不会被保留</li>
<li><code>,</code>、<code>&amp;</code>这两种算符对类类型对象有特殊含义，不建议重载</li>
</ul>
</li>
<li>如果某些操作在逻辑上与算符相关，适合重载：
<ul>
<li>执行IO操作的类，重载<code>&lt;&lt;</code>、<code>&gt;&gt;</code>以和内置类型的IO操作一致</li>
<li>检查相等性的类，重载<code>==</code>，同时也需重载<code>!=</code></li>
<li>单序比较操作的类，重载<code>&lt;</code>，同时也需重载<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></li>
<li>重载算符的返回类型通常应与内置版本兼容：逻辑算符和相等算符返回bool，算术算符返回类类型的值，赋值算符和复合赋值算符返回左侧对象的引用</li>
<li>如果类重载了算术算符或位算符，则最好也提供对应的复合赋值算符</li>
</ul>
</li>
<li>选择将算符定义为成员/非成员：
<ul>
<li><code>=</code>、<code>[]</code>、<code>()</code>、<code>-&gt;</code>必须是成员</li>
<li>复合赋值算符一般是成员，但非必须</li>
<li>改变对象状态的算符或与给定类型密切相关的算符（如<code>++</code>、<code>--</code>、<code>*</code>等）通常应该是成员</li>
<li>具有对称性的算符（如算术、相等性、关系、位）可能转换任意一侧的对象，通常不应该是成员</li>
</ul>
</li>
<li>把算符定义为成员函数时，其左侧对象必须是该类的一个对象</li>
<li>例子：成员函数算符的左侧必须是该类对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">string</span> <span class="n">s</span><span class="o">=</span><span class="s">&#34;world&#34;</span><span class="p">;</span>
<span class="n">string</span> <span class="n">t</span><span class="o">=</span><span class="n">s</span><span class="o">+</span><span class="s">&#34;!&#34;</span><span class="p">;</span>     <span class="c1">//对，左侧是string对象
</span><span class="c1"></span><span class="n">string</span> <span class="n">u</span><span class="o">=</span><span class="s">&#34;hi&#34;</span><span class="o">+</span><span class="n">s</span><span class="p">;</span>    <span class="c1">//若operator+是string的成员函数且未定义非成员版本，则错
</span></code></pre></td></tr></table>
</div>
</div><h2 id="输入和输出运算符">输入和输出运算符</h2>
<ul>
<li>IO库用<code>&gt;&gt;</code>和<code>&lt;&lt;</code>来执行输入和输出，IO库定义了读写内置类型的版本，类需自定义它们以支持IO</li>
</ul>
<h3 id="重载输出运算符">重载输出运算符</h3>
<ul>
<li>通常<code>输出算符</code>的参数和返回值：
<ul>
<li>第一个参数是非常量ostream对象的引用。非常量是因为向流写内容会改变流，引用是因为ostream不可拷贝</li>
<li>第二个参数一般是常量引用。常量是因为打印不改变对象内容，引用是因为避免拷贝</li>
<li>返回值是它的ostream形参的引用（以便重复打印）</li>
</ul>
</li>
<li>IO算符左侧是iostream，故它们必须是<code>非成员函数</code>（iostream类型不可被用户改变）</li>
<li>IO算符经常要读写类的非公有成员，故一般声明为<code>友元</code></li>
<li>例子：重载输出算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//第一个参数是非常量ostream对象的引用，第二个参数一般是常量引用，返回值是它的ostream形参的引用
</span><span class="c1"></span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">){</span>
    <span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">item</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">item</span><span class="p">.</span><span class="n">units_sold</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span>
      <span class="o">&lt;&lt;</span><span class="n">item</span><span class="p">.</span><span class="n">revenue</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">item</span><span class="p">.</span><span class="n">avg_price</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span> <span class="c1">//返回传入的ostream（以便重复打印）
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="重载输入运算符">重载输入运算符</h3>
<ul>
<li>通常<code>输入算符</code>的参数和返回值：
<ul>
<li>第一个参数是要读取的非常量istream对象的引用。非常量是因为读取也会改变流的状态</li>
<li>第二个参数是将读入的非常量对象的引用。非常量是因为要写入该变量，引用也是因为要写入该变量</li>
<li>返回值是它的istream形参的引用（以便重复读取）</li>
</ul>
</li>
<li>输入算符必须处理<code>输入流可能无效</code>的情况（因为输入会改变程序中的变量，无效流导致读入未定义的数据），而输出算符不需要
<ul>
<li>流含有错误类型的数据时读取操作可能失败</li>
<li>读取操作到达文件末尾或遇到输入流的其他错误时也会失效</li>
</ul>
</li>
<li>检查输入流是否有效应该在读完后使用前检查，不应在读之前检查（否则无法检查读取过程中发生的错误）</li>
<li>若在发现错误时对象已经被输入流改变，则改变部分是未定义的值。需要将对象重置为合法的（确定的）状态。</li>
<li>重载输入算符中若读到了不符合用户需求的格式，也可手动设置输入流的<code>failbit</code>。</li>
<li>例子：重载输入算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//第一个参数是要读取的istream的引用，第二个参数是将读入的非常量对象的引用，返回值是它的istream形参的引用
</span><span class="c1"></span><span class="n">istream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">,</span><span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">){</span>
    <span class="kt">double</span> <span class="n">price</span><span class="p">;</span>
    <span class="n">is</span><span class="o">&gt;&gt;</span><span class="n">item</span><span class="p">.</span><span class="n">bookNo</span><span class="o">&gt;&gt;</span><span class="n">item</span><span class="p">.</span><span class="n">units_sold</span><span class="o">&gt;&gt;</span><span class="n">price</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">is</span><span class="p">)</span>                                  <span class="c1">//读完再判断流是否有效
</span><span class="c1"></span>        <span class="n">item</span><span class="p">.</span><span class="n">revenue</span><span class="o">=</span><span class="n">item</span><span class="p">.</span><span class="n">units_sold</span><span class="o">*</span><span class="n">price</span><span class="p">;</span> <span class="c1">//必须在使用读取的变量前判断
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">item</span><span class="o">=</span><span class="n">Sales_data</span><span class="p">();</span>                  <span class="c1">//若输入流无效，将对象重置为确定状态
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">is</span><span class="p">;</span>                              <span class="c1">//返回传入的istream（以便重复读取）
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="算术和关系运算符">算术和关系运算符</h2>
<ul>
<li>通常将算术和关系算符定义为<code>非成员</code>，以允许对左侧或右侧的变量做类型转换。</li>
<li>参数和返回值：
<ul>
<li>形参都是常量引用，因为不需要改变对象状态</li>
<li>返回值是非引用，经常是在函数内定义局部变量作为结果返回</li>
</ul>
</li>
<li>若类定义了算术算符，一般也应该定义复合赋值算符，且应该用复合赋值算符实现算术算符（<code>算术算符比复合赋值算符多一次拷贝</code>）</li>
<li>例子：用复合赋值算符实现算术算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Sales_data</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="n">Sales_data</span> <span class="n">sum</span><span class="o">=</span><span class="n">lhs</span><span class="p">;</span> <span class="c1">//拷贝初始化
</span><span class="c1"></span>    <span class="n">sum</span><span class="o">+=</span><span class="n">rhs</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>         <span class="c1">//局部变量传出时拷贝
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="相等运算符">相等运算符</h3>
<ul>
<li>类通过相等算符来检验两个对象是否相等</li>
<li>相等算符的设计准则：
<ul>
<li>定义相等算符可更容易地使用标准库容器/算法</li>
<li>若类定义了<code>==</code>，则可判断一组对象中是否有重复的</li>
<li>相等算符应该有<code>传递性</code>，即由<code>a==b</code>和<code>b==c</code>可推出<code>a==c</code></li>
<li>定义了<code>==</code>的类也应该定义<code>!=</code></li>
<li><code>==</code>和<code>!=</code>中的一个应该把工作委托给另外一个（可保证两个对象不是相等就是不等）</li>
</ul>
<ul>
<li><code>==</code>和<code>!=</code>应该返回<code>bool</code>类型</li>
</ul>
</li>
<li>例子：定义==和!=</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//参数为常量引用，返回值为bool
</span><span class="c1"></span><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span><span class="o">==</span><span class="n">rhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
           <span class="n">lhs</span><span class="p">.</span><span class="n">units_sold</span><span class="o">==</span><span class="n">rhs</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">&amp;&amp;</span>
           <span class="n">lhs</span><span class="p">.</span><span class="n">revenue</span><span class="o">==</span><span class="n">rhs</span><span class="p">.</span><span class="n">revenue</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//参数为常量引用，返回值为bool，委托给operator==实现
</span><span class="c1"></span><span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">lhs</span><span class="o">==</span><span class="n">rhs</span><span class="p">);</span> <span class="c1">//委托给operator==
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="关系运算符">关系运算符</h3>
<ul>
<li>定义了相等算符的类经常（但非必须）定义关系算符</li>
<li>关联容器和一些算法会用到<code>operator&lt;</code>，它比较有用</li>
<li>关系算符的设计：
<ul>
<li>定义<code>顺序关系</code>，这种关系与关联容器中对关键字的要求一致</li>
<li>若类也有<code>==</code>，则定义的关系应与<code>==</code>保持一致，即关系算符定义的等价类应与相等算符定义的<code>等价类</code>一致，即若两个对象都不小于对方，它们应该相等</li>
<li>若不存在唯一的无歧义的<code>&lt;</code>，则不定义<code>&lt;</code>更好</li>
</ul>
</li>
</ul>
<h2 id="赋值运算符">赋值运算符</h2>
<ul>
<li>除<code>拷贝赋值算符</code>和<code>移动赋值算符</code>外，类还可定义其他赋值算符以使用其他类型作为右侧对象。但不需要考虑<code>自赋值</code>问题，因为类型不同。</li>
<li>赋值算符必须定义为<code>成员函数</code>，无论形参类型是什么。复合赋值算符也通常（不必须）定义为成员</li>
<li>赋值算符和复合赋值算符都应返回左侧对象的引用（对成员函数而言是<code>*this</code>）</li>
<li>例子：vector定义赋值算符用于列表初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">StrVec</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">StrVec</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="cm">/* 其他成员与13.5一致 */</span>
<span class="p">};</span>
<span class="c1">//重载赋值算符，通过initializer_list实现列表初始化
</span><span class="c1"></span><span class="n">StrVec</span> <span class="o">&amp;</span><span class="n">StrVec</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">data</span><span class="o">=</span><span class="n">alloc_n_copy</span><span class="p">(</span><span class="n">il</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">il</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>    <span class="c1">//分配空间并将右侧对象的元素拷贝进去
</span><span class="c1"></span>    <span class="n">free</span><span class="p">();</span>                                         <span class="c1">//释放左侧对象原来管理的资源
</span><span class="c1"></span>    <span class="n">elements</span><span class="o">=</span><span class="n">data</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>                            <span class="c1">//用左侧对象的指针管理拷贝的右侧对象
</span><span class="c1"></span>    <span class="n">first_free</span><span class="o">=</span><span class="n">cap</span><span class="o">=</span><span class="n">data</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span>                                    <span class="c1">//返回左侧对象的引用
</span><span class="c1"></span><span class="p">}</span>
<span class="n">StrVec</span> <span class="n">v</span><span class="p">;</span>
<span class="n">v</span><span class="o">=</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="s">&#34;an&#34;</span><span class="p">,</span><span class="s">&#34;the&#34;</span><span class="p">};</span> <span class="c1">//列表初始化（传入列表，调用参数为initializer_list的赋值算符）
</span></code></pre></td></tr></table>
</div>
</div><h2 id="下标运算符">下标运算符</h2>
<ul>
<li><code>容器类</code>经常可通过元素的位置来访问元素，这些类一般需要下标算符<code>[]</code></li>
<li>下标算符必须是<code>成员函数</code></li>
<li>参数和返回值：
<ul>
<li>通常返回所访问元素的引用，这样可允许下标操作出现在<code>=</code>的左侧或右侧</li>
<li>通常定义const和非const两个版本，作用于const对象的版本其返回值也应该是const</li>
</ul>
</li>
<li>例子：定义下标算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">StrVec</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//非const版本的[]，可赋值
</span><span class="c1"></span>    <span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="n">size_t</span> <span class="n">n</span><span class="p">){</span><span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">n</span><span class="p">];}</span>
    <span class="c1">//const版本的[]，不可赋值，不可改变对象。重载的原因不是返回值const而是后面的const限定符
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">n</span><span class="p">];}</span>
    <span class="cm">/* 其他成员与13.5一致 */</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="o">*</span><span class="n">elements</span><span class="p">;</span>   <span class="c1">//指向动态数组首元素的指针
</span><span class="c1"></span><span class="p">};</span>
<span class="n">StrVec</span> <span class="n">svec</span><span class="p">;</span>            <span class="c1">//非const对象
</span><span class="c1"></span><span class="k">const</span> <span class="n">StrVec</span> <span class="n">cvec</span><span class="o">=</span><span class="n">svec</span><span class="p">;</span> <span class="c1">//const对象
</span><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">svec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">svec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">empty</span><span class="p">()){</span>
    <span class="n">svec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="s">&#34;zero&#34;</span><span class="p">;</span>     <span class="c1">//对，对非const对象调用非const版本的[]，左侧是元素的引用
</span><span class="c1"></span>    <span class="n">cvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="s">&#34;zip&#34;</span><span class="p">;</span>      <span class="c1">//错，对const对象调用const版本的[]，左侧是元素的常量引用
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="递增和递减运算符">递增和递减运算符</h2>
<ul>
<li>迭代器类通常需要实现<code>++</code>和<code>--</code>，使迭代器类可在元素序列中前后移动。</li>
<li>递增递减算符建议（非必须）设为<code>成员函数</code>，因为它们改变操作对象的状态</li>
<li>递增递减算符同时存在前置版本和后置版本，它们应该被同时定义。
<ul>
<li><code>前置版本</code>实现递增/递减操作，并返回对象本身（<code>返回引用</code>）</li>
<li><code>后置版本</code>实现递增/递减操作，并返回操作前的对象的拷贝（<code>返回值</code>）（需在操作前就拷贝）</li>
</ul>
</li>
<li>前置版本和后置版本名字相同无法区分（返回类型不同不算重载），因此使后置版本接受一个额外的<code>int</code>形参以区分，该形参的唯一作用是区分前置/后置因此不需命名，使用后置时编译器为它自动赋值为0</li>
<li>后置版本只是比前置版本多一次拷贝且返回值不同，故应该用前置版本来实现后置版本</li>
<li>例子：定义前置/后置的递增/递减</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">StrBlobPtr</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">();</span>
    <span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">--</span><span class="p">();</span>
    <span class="n">StrBlobPtr</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="n">StrBlobPtr</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="cm">/* 其他成员与12.1.6中一致 */</span>
<span class="p">};</span>
<span class="c1">//前置版本++，包含越界检查
</span><span class="c1"></span><span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">(){</span>
    <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="s">&#34;increment past end of StrBlobPtr&#34;</span><span class="p">);</span>
    <span class="o">++</span><span class="n">curr</span><span class="p">;</span>                 <span class="c1">//先判断是否&gt;=size再递增，因为右边界是开区间
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//前置版本--，包含越界检查
</span><span class="c1"></span><span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">--</span><span class="p">(){</span>
    <span class="o">--</span><span class="n">curr</span><span class="p">;</span>                 <span class="c1">//先递减再判断是否&gt;=size（size_t下溢），因为左边界是闭区间
</span><span class="c1"></span>    <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="s">&#34;decrement past begin of StrBlobPtr&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//后置版本++，委托前置++来实现
</span><span class="c1"></span><span class="n">StrBlobPtr</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>
    <span class="n">StrBlobPtr</span> <span class="n">ret</span><span class="o">=*</span><span class="k">this</span><span class="p">;</span>   <span class="c1">//先拷贝一份用于返回
</span><span class="c1"></span>    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>                <span class="c1">//将本对象++的实现委托给前置版本
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>             <span class="c1">//返回改变前的拷贝
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//后置版本--，委托前置--来实现
</span><span class="c1"></span><span class="n">StrBlobPtr</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>
    <span class="n">StrBlobPtr</span> <span class="n">ret</span><span class="o">=*</span><span class="k">this</span><span class="p">;</span>   <span class="c1">//先拷贝一份用于返回
</span><span class="c1"></span>    <span class="o">--*</span><span class="k">this</span><span class="p">;</span>                <span class="c1">//将本对象--的实现委托给前置版本
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>             <span class="c1">//返回改变前的拷贝
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>可显式调用重载的递增/递减。调用后置版本时需给int传参</li>
<li>例子：显式调用时用实参选择前置/后置</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">StrBlobPtr</span> <span class="nf">p</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
<span class="n">p</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>    <span class="c1">//调用后置版本
</span><span class="c1"></span><span class="n">p</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">();</span>     <span class="c1">//调用前置版本
</span></code></pre></td></tr></table>
</div>
</div><h2 id="成员访问运算符">成员访问运算符</h2>
<ul>
<li>迭代器类或智能指针类中常用到解引用算符<code>*</code>和箭头算符<code>-&gt;</code></li>
<li><code>-&gt;</code>必须是成员函数，<code>*</code>经常也是成员函数（非必须）</li>
<li><code>*</code>和<code>-&gt;</code>是作用在指针上，访问底层对象，不改变指针本身，因此常定义为const函数</li>
<li>理论上可让<code>*</code>做任何事，但<code>-&gt;</code>只能用于获取成员。且<code>-&gt;</code>的工作经常委托给<code>*</code>来实现</li>
<li>对于表达式<code>point-&gt;mem</code>，point必须是指向类对象的指针，或是重载了<code>-&gt;</code>的对象：
<ul>
<li>若point是指向类对象的指针，则等价于<code>(*point).mem</code>。</li>
<li>若point是重载了<code>-&gt;</code>的对象，则等价于<code>point.operator-&gt;()-&gt;mem</code>。</li>
</ul>
</li>
<li>因此<code>operator-&gt;()</code>应该返回一个指向类对象的指针，或是另一个重载了<code>-&gt;</code>的对象</li>
<li>例子：重载*和-&gt;</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">StrBlobPtr</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//返回string的引用
</span><span class="c1"></span>    <span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span><span class="o">=</span><span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="s">&#34;dereference past end&#34;</span><span class="p">);</span>  <span class="c1">//若未越界则返回指向底层对象的shared_ptr
</span><span class="c1"></span>        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">curr</span><span class="p">];</span>                          <span class="c1">//在底层对象中随机索引，返回索引到的元素
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">//返回指向string的指针
</span><span class="c1"></span>    <span class="n">string</span> <span class="o">*</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="k">this</span><span class="o">-&gt;</span><span class="k">operator</span><span class="o">*</span><span class="p">();</span>                  <span class="c1">//对operator*的返回对象取地址得到指针
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="cm">/* 其他成员与12.1.6中一致 */</span>
<span class="p">};</span>
<span class="c1">//使用
</span><span class="c1"></span><span class="n">StrBlob</span> <span class="n">a1</span><span class="o">=</span><span class="p">{</span><span class="s">&#34;hi&#34;</span><span class="p">,</span><span class="s">&#34;bye&#34;</span><span class="p">,</span><span class="s">&#34;now&#34;</span><span class="p">};</span>
<span class="n">StrBlobPtr</span> <span class="nf">p</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
<span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="s">&#34;okay&#34;</span><span class="p">;</span>                  <span class="c1">//解引用得到的是左值引用，可赋值
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>      <span class="c1">//结果是4，等价于p.operator-&gt;()-&gt;size()
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">).</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>    <span class="c1">//结果是4，等价于p.operator*().size()
</span></code></pre></td></tr></table>
</div>
</div><h2 id="函数调用运算符">函数调用运算符</h2>
<ul>
<li>若类重载了函数调用算符，则可以像使用函数一样使用类的对象，它比普通函数更灵活</li>
<li>函数调用算符必须是<code>成员函数</code>。一个类可定义多个调用算符，相互之间应在参数数量/类型上区分</li>
<li>若类定义了调用算符，则称该类对象为<code>函数对象</code></li>
<li>函数对象经常用作标准库算法的实参（类似lambda）</li>
<li>例子：定义调用算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">PrintString</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//构造函数，指明打印对象和打印分隔符
</span><span class="c1"></span>    <span class="n">PrintString</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">o</span><span class="o">=</span><span class="n">cout</span><span class="p">,</span><span class="kt">char</span> <span class="n">c</span><span class="o">=</span><span class="sc">&#39; &#39;</span><span class="p">)</span><span class="o">:</span>
               <span class="n">os</span><span class="p">(</span><span class="n">o</span><span class="p">),</span><span class="n">sep</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
               <span class="p">{}</span>
    <span class="c1">//调用算符，进行实际的打印操作
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">cosnt</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">sep</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">sep</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//使用函数对象
</span><span class="c1"></span><span class="n">PrintString</span> <span class="n">printer</span><span class="p">;</span>            <span class="c1">//定义默认的函数对象
</span><span class="c1"></span><span class="n">printer</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>                     <span class="c1">//调用函数对象
</span><span class="c1"></span><span class="n">PrintString</span> <span class="nf">errors</span><span class="p">(</span><span class="n">cerr</span><span class="p">,</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>  <span class="c1">//定义函数对象
</span><span class="c1"></span><span class="n">errors</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>                      <span class="c1">//调用函数对象
</span></code></pre></td></tr></table>
</div>
</div><h3 id="lambda是函数对象">lambda是函数对象</h3>
<ul>
<li>编写lambda后，编译器将lambda翻译为一个匿名类的匿名对象。</li>
<li>lambda产生的匿名类中含有一个重载的函数调用算符，且形参列表和lambda的形参列表一样</li>
<li>默认lambda不可改变捕获的变量，故其中重载的调用算符是const函数。除非将lambda声明为<code>mutable</code></li>
<li>例子：lambda产生匿名类</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//法1：用lambda实现谓词
</span><span class="c1"></span><span class="n">stable_sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
            <span class="p">[](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();});</span>
<span class="c1">//法2：用等价的函数对象实现谓词
</span><span class="c1"></span><span class="k">class</span> <span class="nc">ShorterString</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//调用算符的返回值、形参列表、函数体都与lambda一致
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();}</span>
<span class="p">};</span>
<span class="n">stable_sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">ShorterString</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>两种捕获:
<ul>
<li><code>引用捕获</code>：编译器直接使用，不需存储数据成员。程序负责保证引用的对象存在</li>
<li><code>值捕获</code>：对象被拷贝到lambda中，在生成的函数对象中为值捕获的变量建立成员，同时创建构造函数用初值列表初始化它们</li>
</ul>
</li>
<li>lambda产生的类不含默认构造函数、赋值算符、默认析构函数，它是否含有默认拷贝/移动构造函数通常取决于捕获的数据成员</li>
<li>例子：值捕获的lambda</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//值捕获的lambda
</span><span class="c1"></span><span class="k">auto</span> <span class="n">wc</span><span class="o">=</span><span class="n">find_if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                <span class="p">[</span><span class="n">sz</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;=</span><span class="n">sz</span><span class="p">;});</span>
<span class="k">class</span> <span class="nc">SizeComp</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//构造函数用于初始化变量
</span><span class="c1"></span>    <span class="n">SizeComp</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">sz</span><span class="p">(</span><span class="n">n</span><span class="p">){}</span>
    <span class="c1">//调用算符
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;=</span><span class="n">sz</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">//为捕获的值生成数据成员
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//使用时用值捕获的变量初始化函数对象
</span><span class="c1"></span><span class="k">auto</span> <span class="n">wc</span><span class="o">=</span><span class="n">find_if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">SizeComp</span><span class="p">(</span><span class="n">sz</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="标准库定义的函数对象">标准库定义的函数对象</h3>
<ul>
<li>标准库定义了一组表示算术、关系、逻辑算符的类，每个类分别定义了一个执行命名操作的调用算符</li>
<li>这些类都是模板，可为其指定应用的类型，即调用该算符的形参类型</li>
<li>例子：使用标准库定义的函数对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intAdd</span><span class="p">;</span>               <span class="c1">//int的加法
</span><span class="c1"></span><span class="n">negate</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intNegate</span><span class="p">;</span>          <span class="c1">//int的取反
</span><span class="c1"></span><span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>          <span class="c1">//结果是30
</span><span class="c1"></span><span class="n">sum</span><span class="o">=</span><span class="n">intNegate</span><span class="p">(</span><span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">));</span>   <span class="c1">//结果是-30
</span><span class="c1"></span><span class="n">sum</span><span class="o">=</span><span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">intNegate</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>   <span class="c1">//结果是0
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>标准库定义的这组函数对象定义于<code>functional</code>头文件，见表14.2：
<img src="../cpp_figs/CPPprimer_ch14-tab_14_2.png" alt="tab_14_2"></li>
<li>表示算符的函数对象类常用于替换标准库算法中的默认算符（类似lambda）</li>
<li>直接用算符比较指针是未定义，但可用标准库的函数对象来比较指针</li>
<li>例子：可用标准库函数对象比较指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span> <span class="o">*&gt;</span> <span class="n">nameTable</span><span class="p">;</span>
<span class="c1">//用内置的&lt;对string指针排序，未定义
</span><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">nameTable</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">nameTable</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
     <span class="p">[](</span><span class="n">string</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="n">string</span> <span class="o">*</span><span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="p">;});</span>
<span class="c1">//用标准库定义的函数对象对string指针排序，正确
</span><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">nameTable</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">nameTable</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">less</span><span class="o">&lt;</span><span class="n">string</span> <span class="o">*&gt;</span><span class="p">());</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="可调用对象与function">可调用对象与function</h3>
<ul>
<li>C++中<code>可调用对象</code>的种类：<code>函数</code>、<code>函数指针</code>、<code>lambda表达式</code>、<code>bind创建的对象</code>、<code>重载了函数调用算符的类</code></li>
<li><code>调用形式</code>指明了调用返回的类型以及传递给调用的参数类型，一种调用形式对应一个函数类型。不同类型的可调用对象可共享同一种调用形式</li>
<li>例子：不同类型的可调用对象共享调用形式</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//以下3个可调用对象的调用形式都是int(int,int)
</span><span class="c1">//函数
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">;}</span>
<span class="c1">//lambda
</span><span class="c1"></span><span class="k">auto</span> <span class="n">mod</span><span class="o">=</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span><span class="o">%</span><span class="n">j</span><span class="p">;}</span>
<span class="c1">//重载了调用算符的类
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">divide</span><span class="p">{</span>
    <span class="kt">int</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">denominator</span><span class="p">,</span><span class="kt">int</span> <span class="n">divisor</span><span class="p">){</span><span class="k">return</span> <span class="n">denominator</span><span class="o">/</span><span class="n">divisor</span><span class="p">;}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>有时候希望将共享调用形式的可调用对象看成同一种类型的对象。例如定义<code>函数表</code>用于存储指向一些可调用对象的指针，程序需要某个可调用对象时从表中查找该对象</li>
<li>函数表可用map实现，key是string，value是可调用对象的指针。但这些指针类型各不相同，无法确定map的类型</li>
<li>使用名为<code>function</code>的标准库类型可将调用形式相同的不同类型可调用对象统一表示，它定义于functional头文件，操作见表14.3：
<img src="../cpp_figs/CPPprimer_ch14-tab_14_3.png" alt="tab_14_3"></li>
<li>function是模板类，其模板参数是它能表示的调用形式（对应的函数类型）</li>
<li>可将不同类型的可调用对象存入同类型的function中，只要它们调用形式相同</li>
<li>function类型重载了调用算符，该算符将其接受的实参传递给底层的可调用对象</li>
<li>例子：不同类型的可调用对象存入同类型的function</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* 上下文：上一个例子 */</span>
<span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f1</span><span class="o">=</span><span class="n">add</span><span class="p">;</span>                          <span class="c1">//加法，函数
</span><span class="c1"></span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f2</span><span class="o">=</span><span class="n">divide</span><span class="p">();</span>                     <span class="c1">//除法，重载调用算符的类
</span><span class="c1"></span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f3</span><span class="o">=</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="p">};</span>  <span class="c1">//乘法，lambda实现
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">f1</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>    <span class="c1">//6
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">f2</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>    <span class="c1">//2
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">f3</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>    <span class="c1">//8
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>例子：用function类定义函数表</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//定义函数表，用于查找操作并调用。统一类型为function&lt;int(int,int)&gt;
</span><span class="c1"></span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">binops</span><span class="o">=</span><span class="p">{</span>
    <span class="p">{</span><span class="s">&#34;+&#34;</span><span class="p">,</span><span class="n">add</span><span class="p">},</span>                          <span class="c1">//上文定义的函数
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;-&#34;</span><span class="p">,</span><span class="n">minus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()},</span>                 <span class="c1">//标准库的函数对象
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;/&#34;</span><span class="p">,</span><span class="n">divide</span><span class="p">()},</span>                     <span class="c1">//上文定义的重载调用算符的类
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;*&#34;</span><span class="p">,[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="p">;}},</span> <span class="c1">//lambda
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;%&#34;</span><span class="p">,</span><span class="n">mod</span><span class="p">},</span>                          <span class="c1">//上文定义的lambda
</span><span class="c1"></span><span class="p">};</span>
<span class="c1">//使用函数表
</span><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;+&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">//调用add(10,5)
</span><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;-&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">//使用minus&lt;int&gt;对象的调用算符
</span><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;/&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">//使用divide对象的调用算符
</span><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;*&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">//使用lambda对象
</span><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;%&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">//使用lambda对象
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>若存在重载函数，则function不能识别是哪一个，即使存在调用形式相同的函数也不行。但定义函数指针时可识别是哪个函数，也可在lambda中调用函数来区分</li>
<li>例子：function不能识别重载函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">;}</span>
<span class="n">Sales_data</span> <span class="nf">add</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="p">,</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">binops</span><span class="p">;</span>
<span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span><span class="n">add</span><span class="p">});</span>                               <span class="c1">//错，function不能识别是哪个重载函数
</span><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">=</span><span class="n">add</span><span class="p">;</span>                                 <span class="c1">//对，函数指针能识别是哪一个重载函数
</span><span class="c1"></span><span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span><span class="n">fp</span><span class="p">});</span>
<span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);}});</span> <span class="c1">//对，直接调用也能识别是哪一个重载函数
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>C++11的<code>function</code>和旧版本的<code>unary_function</code>、<code>binary_function</code>并无关联，后两者已经被更通用的<code>bind</code>函数替代</li>
</ul>
<h2 id="重载类型转换与运算符">重载、类型转换与运算符</h2>
<ul>
<li>用户定义的类型转换：
<ul>
<li><code>转换构造函数</code>：由一个实参调用的非explicit构造函数定义类型转换，将实参类型转换为该类类型</li>
<li><code>类型转换算符</code>：重载的算符，将该类类型转换为指定类型</li>
</ul>
</li>
</ul>
<h3 id="类型转换运算符">类型转换运算符</h3>
<ul>
<li>类型转换算符是一种特殊的<code>成员函数</code>，负责将该类类型转换为其他类型。</li>
<li>类型转换算符的定义形式为<code>operator type() const</code>，其中<code>type</code>表示要转换为的类型。</li>
<li>类型转换算符可对除<code>void</code>外的任何类型定义，只要该类型可作为函数的返回类型（因为用return实现）。故不转换为数组或函数，但可转换为它们的指针/引用</li>
<li>类型转换算符没有显式的返回类型，也没有形参，且必须定义为成员函数。通常不应该改变原对象的内容（拷贝而非移动），故经常定义为const</li>
<li>编译器一次只能执行一个自定义的类型转换，但一个隐式的自定义类型转换可与一个隐式的内置类型转换一起使用。</li>
<li>类型转换隐式执行，故类型转换算符都没有形参</li>
<li>类型转换算符的返回类型不需要指定（蕴含在函数名中）</li>
<li>例子：定义类型转换算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">SmallInt</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//构造函数实现int向该类的转换
</span><span class="c1"></span>    <span class="n">SmallInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">255</span><span class="p">)</span>
            <span class="k">throw</span> <span class="n">out_of_range</span><span class="p">(</span><span class="s">&#34;Bad SmallInt value&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//类型转换算符实现该类向int的转换
</span><span class="c1"></span>    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">val</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">size_t</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">SmallInt</span> <span class="n">si</span><span class="p">;</span>
<span class="n">si</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>       <span class="c1">//4隐式转换为SmallInt，调用合成的SmallInt::operator=
</span><span class="c1"></span><span class="n">si</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span>       <span class="c1">//si隐式转换为int，调用int的加法（因为SmallInt未重载opeartor+）
</span><span class="c1">//可同时使用一个隐式的自定义类型转换与一个隐式的内置类型转换
</span><span class="c1"></span><span class="n">si</span><span class="o">=</span><span class="mf">3.14</span><span class="p">;</span>    <span class="c1">//先内置转换把3.14转为int，再调用转换算符转为SmallInt
</span><span class="c1"></span><span class="n">si</span><span class="o">+</span><span class="mf">3.14</span><span class="p">;</span>    <span class="c1">//先调用转换算符把si转为int，再内置转换为double
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>若在类类型和要转换的类型之间没有明显的映射关系，最好不要定义转换算符</li>
<li>实践中，类很少提供转换算符。隐式转换发生时用户可能感到意外而不是被帮助</li>
<li>定义转为<code>bool</code>的转换算符比较普遍，经常用于条件判断场合</li>
<li>为类定义转为bool的转换算符存在的问题是：bool可参与算术运算，可能引发意想不到的结果</li>
<li>例子：定义转为bool的类参与算术运算（反例）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* 假设cin可以隐式转为bool */</span>
<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span>
<span class="n">cin</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">;</span>
<span class="c1">//cin未定义&lt;&lt;操作，但可转为bool
</span><span class="c1">//于是cin转为bool，无效为0，有效为1。&lt;&lt;成为左移操作，将cin提升为int
</span><span class="c1">//结果是将0或1左移42bit
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>防止上述异常，C++11引入<code>显式类型转换算符</code>，即在类型转换算符前使用<code>explicit</code>关键字，只允许用强制转换方式实现类型转换</li>
<li>若表达式用作条件，则编译器将显式的类型转换自动应用于该表达式（即忽略explicit）：
<ul>
<li>if/while/do语句的条件部分</li>
<li>for语句头的条件表达式</li>
<li>逻辑非<code>!</code>、逻辑与<code>&amp;&amp;</code>、逻辑或<code>||</code>的运算对象</li>
<li>条件算符<code>?:</code>的条件表达式</li>
</ul>
</li>
<li>实现转为bool但避免算术运算的方法：
<ul>
<li>C++11中：将向bool转换的转换算符定义为<code>explicit</code>。变量单独放于条件中会自动忽略explicit</li>
<li>旧标准中：定义向<code>void *</code>而非bool的转换算符。void *也可用于判断，但不会参与算术运算</li>
</ul>
</li>
<li><code>operator bool</code>经常被定义为explicit的</li>
</ul>
<h3 id="避免有二义性的类型转换">避免有二义性的类型转换</h3>
<ul>
<li>若类中包含一个或多个类型转换，则必须确保在该类类型和目标类型之间只存在唯一的转换方式，即无二义性</li>
<li>两种情况下可能产生<code>二义性</code>：
<ul>
<li>两个类定义了作用相同的类型转换，例如：A定义了接受B类型的转换构造函数，同时B定义了向A转换的转换算符</li>
<li>类定义了多个转换算符，而这些转换目标的类型又能相互转换，例如：类定义了转换为int的算符，又定义了转换为short的算符，而实际需要一个double类型</li>
</ul>
</li>
<li>不要为多个类定义相同的类型转换，不要为类定义多个转换源或转换目标是算术类型的转换</li>
<li>对于多个类定义相同类型转换的二义性，解决方式是显式调用函数。显式转换无法解决，因为显式转换也面临二义性</li>
<li>例子：为多个类定义相同的类型转换（反例）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">B</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
    <span class="n">A</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span> <span class="o">&amp;</span><span class="p">);</span>       <span class="c1">//B转为A
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="nc">B</span><span class="p">{</span>
    <span class="k">operator</span> <span class="nf">A</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//B转为A
</span><span class="c1"></span><span class="p">};</span>
<span class="c1">//使用这两个类
</span><span class="c1"></span><span class="n">A</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">);</span>         <span class="c1">//函数接受A的引用，传入B的对象时发生隐式转换
</span><span class="c1"></span><span class="n">B</span> <span class="n">b</span><span class="p">;</span>
<span class="n">A</span> <span class="n">a</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>               <span class="c1">//二义性错误：B转为A时，可调用A的构造函数，也可调用B的转换算符
</span><span class="c1">//解决方案：显式调用
</span><span class="c1"></span><span class="n">A</span> <span class="n">a1</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="k">operator</span> <span class="n">A</span><span class="p">());</span> <span class="c1">//对，显式调用B的转换算符
</span><span class="c1"></span><span class="n">A</span> <span class="n">a2</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>           <span class="c1">//对，显式调用A的构造函数
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>对于类定义了多个转换算符，而这些转换目标的类型又能相互转换的情形，二义性的根本原因是它们所需的内置转换级别一致</li>
<li>使用自定义的转换算符时，若转换过程包含内置转换，则内置转换的级别决定选择哪个转换算符作为最佳匹配</li>
<li>例子：内置转换的级别决定选择哪个转换算符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>                   <span class="c1">//int转为A
</span><span class="c1"></span>    <span class="n">A</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>                  <span class="c1">//double转为A
</span><span class="c1"></span>    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>       <span class="c1">//A转为int
</span><span class="c1"></span>    <span class="k">operator</span> <span class="nf">double</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>    <span class="c1">//A转为double
</span><span class="c1"></span><span class="p">};</span>
<span class="c1">//使用A
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">);</span>
<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="n">f2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>      <span class="c1">//二义性，f2接受long double，存在两条转换路径：A-&gt;int-&gt;long double，A-&gt;double-&gt;long double
</span><span class="c1"></span><span class="kt">long</span> <span class="n">lg</span><span class="p">;</span>
<span class="n">A</span> <span class="nf">a2</span><span class="p">(</span><span class="n">lg</span><span class="p">);</span>   <span class="c1">//二义性，转换为A类型时有两条转换路径：long-&gt;int-&gt;A，long-&gt;double-&gt;A
</span><span class="c1"></span><span class="kt">short</span> <span class="n">s</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span>
<span class="n">A</span> <span class="nf">a3</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>    <span class="c1">//无二义性，&#34;short-&gt;int&#34;优于&#34;short-&gt;double&#34;，故选择转换路径：short-&gt;int-&gt;A
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>设计类的重载算符、转换构造函数、类型转换函数时，必须小心。类同时定义了类型转换算符和重载算符时很容易二义性。
<ul>
<li>不要让两个类实现相同的类型转换</li>
<li>避免转换目标是内置算术类型的转换算符
<ul>
<li>定义了转为算术类型的算符时，不要再定义接受算术类型的重载算符</li>
<li>定义了转为算术类型的算符时，不要定义转换到多种算术类型的转换算符</li>
</ul>
</li>
<li>除了explicit地转换为bool的算符外，应尽量避免定义类型转换算符，并尽可能限制那些“显然正确”的非explicit构造函数</li>
</ul>
</li>
<li>调用<code>重载函数</code>时，从多个类型转换中进行选择将更加复杂。若两个或多个类型转换都提供了同一种可行的匹配，则这些转换一样好</li>
<li>调用者可显式构造正确的类型消除二义性</li>
<li>若在调用重载函数时，需要使用<code>显式构造函数</code>或<code>强制类型转换</code>来改变实参类型，通常意味着程序设计存在不足</li>
<li>例子：从多个类型转换中选择重载函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">C</span><span class="p">{</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>     <span class="c1">//int转为C
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="nc">D</span><span class="p">{</span>
    <span class="n">D</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>     <span class="c1">//int转为D
</span><span class="c1"></span><span class="p">};</span>
<span class="kt">void</span> <span class="nf">manip</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">manip</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="n">manip</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>      <span class="c1">//二义性错误，manip(C(10))或manip(D(10))
</span><span class="c1"></span><span class="n">manip</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>   <span class="c1">//正确，显式调用
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>调用重载函数时，若两个或多个自定义类型转换都提供了可行匹配，则它们提供的转换一样好。此时不考虑任何内置类型转换的级别。</li>
<li>只有所有可行函数能通过同一个自定义类型转换得到匹配时，才会考虑其中出现的内置类型转换</li>
<li>若调用重载函数所请求的自定义类型转换不止一个，即使其中一个需要额外的内置类型转换而另一个精确匹配，它们也是二义性的。（本质原因是，对于自定义类型转换之间的差异而言，内置类型转换的差异可以忽略）</li>
<li>例子：调用重载函数所请求的自定义类型转换不止一个时一定是二义性</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">C</span><span class="p">{</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>     <span class="c1">//int转为C
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="nc">E</span><span class="p">{</span>
    <span class="n">E</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>     <span class="c1">//int转为E
</span><span class="c1"></span><span class="p">};</span>
<span class="kt">void</span> <span class="nf">manip2</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">manip2</span><span class="p">(</span><span class="k">const</span> <span class="n">E</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="n">manip2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//二义性，可匹配到两个类型转换：int-&gt;C和int-&gt;double-&gt;E
</span><span class="c1"></span>            <span class="c1">//但由于是重载函数且是不同的自定义转换，故它们一样好
</span></code></pre></td></tr></table>
</div>
</div><h3 id="函数匹配与重载运算符">函数匹配与重载运算符</h3>
<ul>
<li>重载的算符也是重载的函数，故通用的函数匹配规则也适用于判断表达式中使用哪个算符。</li>
<li>算符出现在表达式中时，候选函数集会比较大，例如<code>a sym b</code>可能是：
<ul>
<li>内置算符<code>sym</code></li>
<li>重载的非成员函数，即<code>operatorsym(b)</code></li>
<li>重载的a的成员函数，即<code>a.operatorsym(b)</code>（当a出现在左侧时才有可能）</li>
</ul>
</li>
<li>显式调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载，因为会用<code>.</code>或<code>-&gt;</code>来显式说明是成员。但算符无法被这样区分。</li>
<li>若对同一个类，既提供了转换源和转换目标是算术类型的转换，又提供了重载的算符，则会遇到<code>重载算符</code>与<code>内置算符</code>的二义性问题</li>
<li>例子：重载算符和内置算符的二义性（反例）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">SmallInt</span><span class="p">{</span>
    <span class="c1">//对SmallInt重载+
</span><span class="c1"></span>    <span class="k">friend</span> <span class="n">SmallInt</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">SmallInt</span> <span class="o">&amp;</span><span class="p">,</span><span class="k">const</span> <span class="n">SmallInt</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">SmallInt</span><span class="p">(</span><span class="kt">int</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>                    <span class="c1">//int转为SmallInt
</span><span class="c1"></span>    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">val</span><span class="p">;}</span>  <span class="c1">//SmallInt转为int
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">size_t</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">SmallInt</span> <span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">;</span>
<span class="n">SmallInt</span> <span class="n">s3</span><span class="o">=</span><span class="n">s1</span><span class="o">+</span><span class="n">s2</span><span class="p">;</span>  <span class="c1">//两侧都是SmallInt，使用重载的operator+
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">s3</span><span class="o">+</span><span class="mi">0</span><span class="p">;</span>         <span class="c1">//一侧SmallInt，另一侧int
</span><span class="c1"></span>                    <span class="c1">//但既可由int转为SmallInt，又可由SmallInt转为int
</span><span class="c1"></span>                    <span class="c1">//且存在int的+和SmallInt的operator+
</span><span class="c1"></span>                    <span class="c1">//故无法选择，二义性错误
</span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">canpi</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-03-20
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_wechat.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_alipay.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          <a href="/tags/c&#43;&#43;-primer/">C&#43;&#43; primer</a>
          <a href="/tags/%E8%AF%BB%E4%B9%A6/">读书</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cpp/cpp_iostream_cstdio/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43;技巧：cin/cout和scanf/printf的速度</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/cpp/cppprimer_ch13/">
            <span class="next-text nav-default">C&#43;&#43; primer 第13章 拷贝控制</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/cpp/cppprimer_ch14/" class="leancloud_visitors" data-flag-title="C&#43;&#43; primer 第14章 重载运算与类型转换">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'ntftaTIdLaT8sVPL9qFX5dAg-gzGzoHsz',
        appKey: 'lNOKznaI2Gnej5D2MgpUJnzV',
        notify:  false ,
        verify:  false ,
        avatar:'retro',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hucanpei@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/hucanpei" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/canpi" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">canpi</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>








</body>
</html>
