<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; primer 第12章 动态内存 - pi</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="canpi" /><meta name="description" content="对象的生存期： 全局对象：程序启动时创建，程序结束时销毁 局部static对象：第一次使用前创建，程序结束时销毁 局部自动对象：定义时创建，离开定" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.67.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/cpp/cppprimer_ch12/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.78f8f17bab244b9ee62ad16480c9584d5fc2db06ae20681d1ca225cefd80767c.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; primer 第12章 动态内存" />
<meta property="og:description" content="对象的生存期： 全局对象：程序启动时创建，程序结束时销毁 局部static对象：第一次使用前创建，程序结束时销毁 局部自动对象：定义时创建，离开定" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/cpp/cppprimer_ch12/" />
<meta property="article:published_time" content="2020-03-08T16:18:00+08:00" />
<meta property="article:modified_time" content="2020-03-08T16:18:00+08:00" />
<meta itemprop="name" content="C&#43;&#43; primer 第12章 动态内存">
<meta itemprop="description" content="对象的生存期： 全局对象：程序启动时创建，程序结束时销毁 局部static对象：第一次使用前创建，程序结束时销毁 局部自动对象：定义时创建，离开定">
<meta itemprop="datePublished" content="2020-03-08T16:18:00&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-08T16:18:00&#43;08:00" />
<meta itemprop="wordCount" content="12349">



<meta itemprop="keywords" content="C&#43;&#43;,C&#43;&#43; primer,读书," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; primer 第12章 动态内存"/>
<meta name="twitter:description" content="对象的生存期： 全局对象：程序启动时创建，程序结束时销毁 局部static对象：第一次使用前创建，程序结束时销毁 局部自动对象：定义时创建，离开定"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">canpi</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">canpi</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; primer 第12章 动态内存</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-03-08 </span>
        
          <span class="more-meta"> 约 12349 字 </span>
          <span class="more-meta"> 预计阅读 25 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#动态内存与智能指针">动态内存与智能指针</a>
      <ul>
        <li><a href="#shared_ptr类">shared_ptr类</a></li>
        <li><a href="#直接管理内存">直接管理内存</a></li>
        <li><a href="#shared_ptr和new结合使用">shared_ptr和new结合使用</a></li>
        <li><a href="#智能指针和异常">智能指针和异常</a></li>
        <li><a href="#unique_ptr">unique_ptr</a></li>
        <li><a href="#weak_ptr">weak_ptr</a></li>
      </ul>
    </li>
    <li><a href="#动态数组">动态数组</a>
      <ul>
        <li><a href="#new和数组">new和数组</a></li>
        <li><a href="#allocator类">allocator类</a></li>
      </ul>
    </li>
    <li><a href="#使用标准库文本查询程序">使用标准库：文本查询程序</a>
      <ul>
        <li><a href="#文本查询程序设计">文本查询程序设计</a></li>
        <li><a href="#文本查询程序类的定义">文本查询程序类的定义</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <ul>
<li>对象的<code>生存期</code>：
<ul>
<li><code>全局对象</code>：程序启动时创建，程序结束时销毁</li>
<li><code>局部static对象</code>：第一次使用前创建，程序结束时销毁</li>
<li><code>局部自动对象</code>：定义时创建，离开定义所在程序块时销毁</li>
<li><code>动态对象</code>：生存期由程序控制，在显式创建时创建，显式销毁时销毁</li>
</ul>
</li>
<li>动态对象的正确释放极易出错。为安全使用动态对象，标准库定义了<code>智能指针</code>来管理动态对象</li>
<li>内存空间：
<ul>
<li><code>静态内存</code>：局部static对象、类static数据成员、定义在任何函数之外的变量</li>
<li><code>栈内存</code>：定义在函数内的非static对象</li>
<li><code>堆内存</code>：动态对象，即运行时分配的对象</li>
</ul>
</li>
<li>静态内存和栈内存中的对象由编译器创建和销毁，堆内存中的动态对象的生存期由程序控制</li>
</ul>
<h2 id="动态内存与智能指针">动态内存与智能指针</h2>
<ul>
<li>C++通过一对<code>运算符</code>管理动态内存：
<ul>
<li><code>new</code>算符在动态内存中为对象分配空间并返回指向该对象的指针，可选择对对象初始化</li>
<li><code>delete</code>算符接受一个动态对象的指针，销毁该对象并释放内存</li>
</ul>
</li>
<li>确保在正确时间释放内存很难：
<ul>
<li>若不释放内存，导致<code>内存泄露</code></li>
<li>若还有指针指向该内存就将其释放，导致<code>指针空悬</code></li>
</ul>
</li>
<li>C++11标准库中提供了两种<code>智能指针</code>来管理动态对象，定义于<code>memory</code>头文件：
<ul>
<li><code>shared_ptr</code>允许多个指针指向同一对象</li>
<li><code>unique_ptr</code>指针独占所指向对象</li>
<li><code>weak_ptr</code>是伴随类，是一种弱引用，指向shared_ptr管理的对象</li>
</ul>
</li>
</ul>
<h3 id="shared_ptr类">shared_ptr类</h3>
<ul>
<li>智能指针也是模板类，创建时必须在模板参数中给定其指向的类型</li>
<li>默认初始化的智能指针中保存空指针，条件判断中使用智能指针是判断其是否为空</li>
<li>解引用智能指针返回其指向的对象</li>
<li>shared_ptr和unique_ptr都支持的操作见表12.1，shared_ptr独有的操作见表12.2
<img src="../cpp_figs/CPPprimer_ch12-tab_12_1.png" alt="tab_12_1">
<img src="../cpp_figs/CPPprimer_ch12-tab_12_2.png" alt="tab_12_2"></li>
<li>最安全的分配和使用动态内存的方法是调用<code>make_shared</code>函数，该函数定义于memory头文件中，它在动态内存中分配一个对象并初始化，返回指向它的shared_ptr</li>
<li><code>make_shared</code>函数用法：
<ul>
<li>是模板函数，使用时必须在模板参数中给出构造对象的类型</li>
<li>其参数必须与构造对象的构造函数参数匹配，使用这些参数构造对象</li>
<li>若不给实参，则对象值初始化</li>
</ul>
</li>
<li>对shared_ptr进行拷贝/赋值时，每个shared_ptr会记录有多少个其他shared_ptr指向相同对象</li>
<li>每个<code>shared_ptr</code>都有一个关联的<code>计数器</code>，称为<code>引用计数</code>：
<ul>
<li>一个shared_ptr的一组拷贝之间共享“引用计数管理区域”，并用原子操作保证该区域中的引用计数被互斥地访问</li>
<li>互相独立的shared_ptr维护的引用计数也互相独立，即使指向同一对象。因此需避免互相独立的shared_ptr指向同一对象</li>
</ul>
</li>
<li>改变<code>引用计数</code>：
<ul>
<li><code>递增</code>：拷贝shared_ptr时，包括：用一个shared_ptr初始化另一个shared_ptr、作为参数传入函数、作为返回值从函数传出</li>
<li><code>递减</code>：给shared_ptr赋新值、shared_ptr被销毁（例如离开作用域）</li>
<li>一旦shared_ptr的计数器变为0，会自动释放管理的对象</li>
</ul>
</li>
<li>C++标准并未要求使用计数器实现引用计数，其实现取决于标准库的实现</li>
<li>指向对象的最后一个shared_ptr被销毁时，shared_ptr会通过它的<code>析构函数</code>完成对象的销毁</li>
<li><code>析构函数</code>控制此类型对象销毁时的操作，一般用于释放对象的资源。shared_ptr类型的析构函数被调用时递减引用计数，一旦计数为0即销毁对象。</li>
<li>例子：使用make_shared创建factory</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//创建对象并返回智能指针
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">factory</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>   <span class="c1">//创建时计数为1，传出拷贝+1，离开作用域-1
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//使用factory创建对象，使用完后销毁
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">use_factory</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">){</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">=</span><span class="n">factory</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span> <span class="c1">//创建对象，初始引用计数为1
</span><span class="c1"></span>    <span class="cm">/* 使用p */</span>                     <span class="c1">//未传出，离开作用域时计数-1变为0，对象被销毁
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//使用factory创建对象，使用完后不销毁
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">use_factory</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">){</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">=</span><span class="n">factory</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span> <span class="c1">//创建对象，初始引用计数为1
</span><span class="c1"></span>    <span class="cm">/* 使用p */</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>                       <span class="c1">//传出时拷贝+1，离开作用域-1，传出后计数为1
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>必须确保shared_ptr在不使用时及时删除。例如容器中的shared_ptr在不使用时要erase</li>
<li>使用动态内存的<code>3种情况</code>：
<ul>
<li>不知道需要使用多少对象（容器）</li>
<li>不知道所需对象的准确类型（多态）</li>
<li>需在多个对象间共享数据</li>
</ul>
</li>
<li>若两个对象共享底层数据，则某个对象被销毁时不可单方面销毁底层数据。此时应将共享的数据做成对象，在需共享它的两个类内分别用shared_ptr访问</li>
<li>例子：用shared_ptr实现共享资源</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//定义StrBlob类
</span><span class="c1"></span><span class="k">class</span> <span class="nc">StrBlob</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//定义类型
</span><span class="c1"></span>    <span class="k">using</span> <span class="n">size_type</span><span class="o">=</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span>
    <span class="c1">//两个构造函数，默认初始化和列表初始化
</span><span class="c1"></span>    <span class="n">StrBlob</span><span class="p">();</span>
    <span class="n">StrBlob</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
    <span class="c1">//以下是对底层vector操作的封装
</span><span class="c1"></span>    <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();}</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">();}</span>
    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);}</span>
    <span class="kt">void</span> <span class="nf">pop_back</span><span class="p">();</span>
    <span class="n">string</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">();</span>
    <span class="n">string</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">//用shared_ptr管理底层的vector&lt;string&gt;数据
</span><span class="c1"></span>    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="c1">//检查索引i是否越界，越界时用msg抛出异常
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//默认构造函数，底层vector&lt;string&gt;默认初始化，返回shared_ptr用于初始化data
</span><span class="c1"></span><span class="n">StrBlob</span><span class="o">::</span><span class="n">StrBlob</span><span class="p">()</span><span class="o">:</span>
         <span class="n">data</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">())</span>
         <span class="p">{}</span>
<span class="c1">//构造函数，底层vector&lt;string&gt;列表初始化，返回shared_ptr用于初始化data
</span><span class="c1"></span><span class="n">StrBlob</span><span class="o">::</span><span class="n">StrBlob</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span><span class="o">:</span>
         <span class="n">data</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">il</span><span class="p">))</span>
         <span class="p">{}</span>
<span class="c1">//检查下标是否越界
</span><span class="c1"></span><span class="kt">void</span> <span class="n">StrBlob</span><span class="o">::</span><span class="n">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span>
        <span class="k">throw</span> <span class="n">out_of_range</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//以下3个函数分别实现front、back、pop_back操作，用0来check索引判断是否为空
</span><span class="c1"></span><span class="n">string</span> <span class="o">&amp;</span><span class="n">StrBlob</span><span class="o">::</span><span class="n">front</span><span class="p">(){</span>
    <span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&#34;front on empty StrBlob&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">string</span> <span class="o">&amp;</span><span class="n">StrBlob</span><span class="o">::</span><span class="n">back</span><span class="p">(){</span>
    <span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&#34;back on empty StrBlob&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">StrBlob</span><span class="o">::</span><span class="n">pop_back</span><span class="p">(){</span>
    <span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&#34;pop_back on empty StrBlob&#34;</span><span class="p">);</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/* 使用StrBlob */</span>
<span class="n">StrBlob</span> <span class="n">b1</span><span class="p">;</span>                         <span class="c1">//创建新StrBlob
</span><span class="c1"></span><span class="p">{</span>                                   <span class="c1">//进入新作用域
</span><span class="c1"></span>    <span class="n">StrBlob</span> <span class="n">b2</span><span class="o">=</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="s">&#34;an&#34;</span><span class="p">,</span><span class="s">&#34;the&#34;</span><span class="p">};</span>    <span class="c1">//初始化b2
</span><span class="c1"></span>    <span class="n">b1</span><span class="o">=</span><span class="n">b2</span><span class="p">;</span>                          <span class="c1">//用b2初始化b1，它们共享底层数据
</span><span class="c1"></span><span class="p">}</span>                                   <span class="c1">//离开作用域，b2被释放，b1仍存在，共享的底层数据未丢失
</span><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="n">b1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">b1</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">b1</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>对类对象使用默认版本的拷贝/赋值/销毁操作时，这些操作拷贝/赋值/销毁类的数据成员（包括智能指针）。</li>
</ul>
<h3 id="直接管理内存">直接管理内存</h3>
<ul>
<li>两个运算符分配/释放动态内存：
<ul>
<li><code>new</code>分配内存，并构造对象</li>
<li><code>delete</code>销毁对象，并释放内存</li>
</ul>
</li>
<li>使用new/delete管理动态内存的类不能依赖动态对象成员的拷贝/赋值/销毁的任何默认操作</li>
<li>堆内存中分配的空间是<code>匿名</code>的，故new无法为其分配的对象命名，只能返回一个指向该对象的指针</li>
<li>动态对象<code>初始化</code>：
<ul>
<li>默认情况下用默认初始化：内置类型的值未定义，类类型依赖默认构造函数</li>
<li>直接初始化：用圆括号调用构造函数，或花括号列表初始化</li>
<li>值初始化：类型名后跟一对空的圆括号。对于有默认构造函数的类类型而言，值初始化没有意义（都是调用默认构造函数），但对于内置类型值初始化可有良好定义的值</li>
<li>拷贝初始化：使用圆括号里放单一对象，被分配的对象用它初始化。此时可用auto推导需分配的类型</li>
</ul>
</li>
<li>例子：动态对象初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//默认初始化
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">;</span>                            <span class="c1">//未定义
</span><span class="c1"></span><span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="o">=</span><span class="k">new</span> <span class="n">string</span><span class="p">;</span>                      <span class="c1">//默认初始化为空字符串
</span><span class="c1">//直接初始化
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>                      <span class="c1">//初始化为1024
</span><span class="c1"></span><span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="o">=</span><span class="k">new</span> <span class="n">stirng</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="sc">&#39;9&#39;</span><span class="p">);</span>              <span class="c1">//初始化为&#34;9999999999&#34;
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pv</span><span class="o">=</span><span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>   <span class="c1">//初始化为{0,1,2,3,4,5}
</span><span class="c1">//值初始化
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">();</span>                          <span class="c1">//初始化为0
</span><span class="c1"></span><span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="o">=</span><span class="k">new</span> <span class="n">string</span><span class="p">();</span>                    <span class="c1">//初始化为空字符串
</span><span class="c1">//拷贝初始化
</span><span class="c1"></span><span class="k">auto</span> <span class="n">p1</span><span class="o">=</span><span class="k">new</span> <span class="k">auto</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>                      <span class="c1">//用obj拷贝初始化p1
</span><span class="c1"></span><span class="k">auto</span> <span class="n">p2</span><span class="o">=</span><span class="k">new</span> <span class="k">auto</span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">};</span>                    <span class="c1">//错，只能拷贝初始化为auto
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>用new分配const对象是合法的，const对象必须初始化。</li>
<li>若new不能分配要求的空间，则抛出名为<code>bad_alloc</code>的异常。</li>
<li>可向new算符传参来阻止抛出异常，传递了参数的new叫<code>定位new</code>。</li>
<li>向new传入<code>std::nothrow</code>，则它不会抛出异常。若不能分配内存，则返回空指针。</li>
<li>bad_alloc和nothrow都定义在头文件<code>new</code>中</li>
<li>例子：阻止new抛出异常</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">p1</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">;</span>            <span class="c1">//若分配失败则抛出bad_alloc异常
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p2</span><span class="o">=</span><span class="k">new</span><span class="p">(</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span><span class="p">;</span>   <span class="c1">//若分配失败则返回空指针
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>delete表达式</code>将内存归还给系统，它接受一个指针，指向需要释放的对象</li>
<li>delete表达式执行两个工作：销毁指针指向的对象，释放对应的内存</li>
<li>传递给delete表达式的指针必须指向动态内存，或是空指针</li>
<li>用delete释放非new分配的内存，或者将同一指针释放多次，都是未定义</li>
<li>编译器无法知道一个指针是否指向动态内存，也无法知道一个指针指向的内存是否已被释放，故这些错误不会被编译器发现</li>
<li>const对象的值不可改变，但可被销毁</li>
<li>内置指针管理的动态对象，在显式释放之前一直存在</li>
<li>内置类型的对象被销毁时什么都不会发生（与类类型不一样）。特别是，内置指针被销毁时不影响其指向的对象。若这个内置指针指向动态对象，则空间不会被释放</li>
<li>例子：内置指针销毁时不会销毁指向对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Foo</span> <span class="o">*</span><span class="nf">factory</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>    <span class="c1">//返回动态对象的指针，调用者负责释放它
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">void</span> <span class="nf">use_factory</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">){</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">factory</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>    <span class="c1">//分配对象，得到指向它的指针
</span><span class="c1"></span>    <span class="cm">/* 使用p但不delete */</span>
<span class="p">}</span>                           <span class="c1">//离开时指针被销毁，对象仍存在。再没有指针指向该对象，该动态对象无法回收，内存泄露
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>用<code>new</code>和<code>delete</code>管理动态内存的常见问题：
<ul>
<li>忘记delete内存，没有指针指向该动态内存时，内存泄露</li>
<li>使用已释放的对象</li>
<li>同一块内存释放两次</li>
<li>用智能指针管理动态内存即可避免这些问题</li>
</ul>
</li>
<li>delete之后，指针变为<code>空悬指针</code>，类似于未初始化的指针。为避免空悬指针，尽量在指针即将离开作用域时释放其管理的动态内存，也可在delete后立即将指针置为<code>nullptr</code></li>
<li>delete内存后将指针置nullptr的做法只对单个指针有效，若还有其他指针指向该对象则它们变为空悬指针。由于很难知道有哪些指针指向这个对象，故很难用new和delete管理动态内存</li>
<li>例子：产生空悬指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="nf">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>    <span class="c1">//分配动态内存
</span><span class="c1"></span><span class="k">auto</span> <span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>               <span class="c1">//两个指针同时指向动态对象
</span><span class="c1"></span><span class="k">delete</span> <span class="n">p</span><span class="p">;</span>               <span class="c1">//释放对象
</span><span class="c1"></span><span class="n">p</span><span class="o">=</span><span class="k">nullptr</span><span class="p">;</span>              <span class="c1">//将构造动态对象时的指针置为nullptr，但其他指针变为空悬
</span></code></pre></td></tr></table>
</div>
</div><h3 id="shared_ptr和new结合使用">shared_ptr和new结合使用</h3>
<ul>
<li>shared_ptr的操作如表12.3
<img src="../cpp_figs/CPPprimer_ch12-tab_12_3.png" alt="tab_12_3"></li>
<li>可用new返回的内置指针初始化智能指针，如果不对智能指针初始化，就被初始化为空指针</li>
<li>接受内置指针的智能指针构造函数是<code>explicit</code>的，即不能将内置指针隐式转换为智能指针，必须直接初始化</li>
<li>例子：不能将内置指针隐式转换为智能指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>       <span class="c1">//错，不可隐式转换
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span>      <span class="c1">//对，可以直接构造
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>                  <span class="c1">//错，不可隐式转换
</span><span class="c1"></span><span class="p">}</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">));</span> <span class="c1">//对，可以直接构造
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>用于初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用delete释放其指向的对象。静态内存和栈内存不需要也不能使用智能指针</li>
<li>shared_ptr用于自动管理对象释放的功能，只限于其自身的一组拷贝之间，<code>互相独立的shared_ptr其引用计数也互相独立</code>，<code>内置指针不参与引用计数</code>。</li>
<li>推荐使用make_shared而不用new的内置指针初始化shared_ptr，因为make_shared可保证分配对象的同时和shared_ptr绑定，避免将一块内存绑定到多个互相独立的shared_ptr</li>
<li>例子：混合使用内置指针与智能指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">){</span>  <span class="c1">//传入时copy，计数+1
</span><span class="c1"></span>    <span class="cm">/* 使用ptr */</span>
<span class="p">}</span>                                   <span class="c1">//离开作用域，计数-1
</span><span class="c1">//以下为正确用法：
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>     <span class="c1">//新建一个智能指针
</span><span class="c1"></span><span class="n">process</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>                         <span class="c1">//处理后引用计数为1
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span><span class="o">=*</span><span class="n">p</span><span class="p">;</span>
<span class="c1">//以下为错误用法：
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="nf">x</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span>
<span class="n">process</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                         <span class="c1">//错，不可将内置指针隐式转换为智能指针
</span><span class="c1"></span><span class="n">process</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>        <span class="c1">//该智能指针的生存期只在这个函数中，离开时智能指针被释放，对象也被释放
</span><span class="c1"></span><span class="kt">int</span> <span class="n">j</span><span class="o">=*</span><span class="n">x</span><span class="p">;</span>                           <span class="c1">//未定义，x指向的对象已被释放
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>使用内置指针构造智能指针时必须立即构造，禁止混合使用两种指针，禁止传参时构造</li>
<li>将一个shared_ptr绑定到一个内置指针时，内存管理的责任被交给shared_ptr，不应该再用该内置指针访问内存</li>
<li>shared_ptr定义了<code>get</code>成员函数，它返回内置指针，指向shared_ptr管理的对象。用于不兼容shared_ptr的情形。</li>
<li><code>get使用风险</code>：
<ul>
<li>不可将get返回的内置指针dedete，因为原来的shared_ptr变为空悬</li>
<li>不可用get返回的内置指针来初始化另一个shared_ptr，因为产生两套引用计数</li>
</ul>
</li>
<li>例子：不可用get返回的内置指针来初始化另一个shared_ptr</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>         <span class="c1">//取底层的内置指针
</span><span class="c1"></span><span class="p">{</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="c1">//产生两个互相独立的shared_ptr，进行互相独立的引用计数
</span><span class="c1"></span><span class="p">}</span>                       <span class="c1">//离开程序块时，块内定义的shared_ptr计数清零，对象被释放
</span><span class="c1"></span><span class="kt">int</span> <span class="n">foo</span><span class="o">=*</span><span class="n">p</span><span class="p">;</span>             <span class="c1">//未定义，p指向的对象已被释放
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>reset</code>成员函数为shared_ptr赋予一个新的内置指针，同时更新原来的引用计数，必要时将原对象销毁。</li>
<li><code>reset</code>函数经常与<code>unique</code>函数一起使用，控制多个shared_ptr共享的对象。改变对象时检查自己是否是唯一的用户。若不是，可拷贝一份自己修改</li>
<li>例子：非独有时拷贝再修改</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">.</span><span class="n">unique</span><span class="p">())</span>                 <span class="c1">//若p不是唯一指向该对象的shared_ptr
</span><span class="c1"></span>    <span class="n">p</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">));</span>    <span class="c1">//将对象拷贝一份，并用p管理这个拷贝
</span><span class="c1"></span><span class="o">*</span><span class="n">p</span><span class="o">+=</span><span class="n">newVal</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="智能指针和异常">智能指针和异常</h3>
<ul>
<li>使用了异常处理的程序可在异常发生时让程序继续，跳进异常中断时需确保异常发生后资源被正确释放。例如new分配的对象，处理异常时要考虑delete</li>
<li>若使用智能指针，即使程序员因异常而过早结束，智能指针也可确保在指针离开作用域时释放资源</li>
<li>函数的退出有两种可能：正常处理结束或发生异常。两种情况下局部非static对象都会被销毁（包括智能指针，因此可使动态对象也被自动销毁）</li>
<li>若使用new/delete管理内存，且在new和delete之间发生异常，则内存不会被释放</li>
<li>例子：new/delete分配的内存遇到异常时可能不会释放</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">f</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ip</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>    <span class="c1">//分配资源
</span><span class="c1"></span>    <span class="cm">/* 这里抛出异常 */</span>
    <span class="k">delete</span> <span class="n">ip</span><span class="p">;</span>              <span class="c1">//函数未正常结束，delete不会被执行
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>C++的很多类都定义了析构函数用于销毁对象释放资源。但不是所有的类都有，尤其是与C交互的类，通常要求用户显式释放使用的任何资源。若在资源的分配和释放之间发生了异常，也会有资源泄露。可用智能指针管理这些未定义析构函数的类，只需<code>自定义delete</code>操作。</li>
<li>默认情况下，shared_ptr假定它们指向的是动态内存，即销毁时对其管理的指针进行delete。这个delete也可自定义。</li>
<li>创建shared_ptr时可在参数列表中给出自定义的delete函数，该delete函数的必须接受一个指向所管理对象的内置指针</li>
<li>例子：自定义shared_ptr的delete</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//以下是C/C++兼容的网络库
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">destination</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">connection</span><span class="p">;</span>
<span class="n">connection</span> <span class="nf">connect</span><span class="p">(</span><span class="n">destination</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">disconnect</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span>
<span class="c1">//以下是使用这个库，手动管理连接
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">destination</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">){</span>
    <span class="n">connection</span> <span class="n">c</span><span class="o">=</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>   <span class="c1">//创建连接，类似new
</span><span class="c1"></span>    <span class="cm">/* 使用连接 */</span>
    <span class="n">disconnect</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>              <span class="c1">//关闭连接。类似delete
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//以下是使用这个库，shared_ptr管理连接
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">end_connection</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span><span class="n">disconnect</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);}</span> <span class="c1">//自定义delete操作用于关闭连接
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">destination</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">){</span>
    <span class="n">connection</span> <span class="n">c</span><span class="o">=</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">connection</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="n">end_connection</span><span class="p">);</span>    <span class="c1">//shared_ptr管理连接
</span><span class="c1"></span>    <span class="cm">/* 使用连接 */</span>
<span class="p">}</span>                                                   <span class="c1">//shared_ptr离开作用域，自动关闭连接
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>智能指针使用<code>基本规范</code>：
<ul>
<li>不使用相同的内置指针来初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()初始化或reset另一个智能指针</li>
<li>谨慎使用get()返回的指针，最后一个智能指针销毁后对象就被销毁了</li>
<li>若使用智能指针管理的资源不是new分配的内存，要自定义delete</li>
</ul>
</li>
</ul>
<h3 id="unique_ptr">unique_ptr</h3>
<ul>
<li>同一个时刻只能有一个unique_ptr指向给定对象。若unique_ptr被销毁，其指向的对象也被销毁</li>
<li>unique_ptr的操作列于表12.4
<img src="../cpp_figs/CPPprimer_ch12-tab_12_4.png" alt="tab_12_4"></li>
<li>定义unique_ptr时需将其绑定到一个new返回的指针上。类似shared_ptr，用内置指针初始化时必须显式构造，不可隐式转换</li>
<li>unique_ptr不支持拷贝/赋值，因为独占其管理的对象</li>
<li>例子：unique_ptr不支持拷贝/赋值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Stegosaurus&#34;</span><span class="p">));</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>  <span class="c1">//错，不可拷贝
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p3</span><span class="p">;</span>
<span class="n">p3</span><span class="o">=</span><span class="n">p1</span><span class="p">;</span>                      <span class="c1">//错，不可赋值
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>可通过release/reset成员函数将指针所有权从一个（非const）unique_ptr转移给另一个unique_ptr
<ul>
<li><code>release</code>函数返回unique_ptr当前保存的指针，并将unique_ptr置为空</li>
<li><code>reset</code>函数将unique_ptr原来指向的对象被释放，并接受一个可选的内置指针参数，令unique_ptr重新指向给定的指针。</li>
</ul>
</li>
<li>例子：unique_ptr用release/reset转移权限</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Stegosaurus&#34;</span><span class="p">));</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>    <span class="c1">//将p1置空并将底层的内置指针交给p2管理
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p3</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Trex&#34;</span><span class="p">));</span>
<span class="n">p2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>                 <span class="c1">//释放p2管理的对象，将p3置空并将底层的内置指针交给p2管理
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>不能拷贝unique_ptr的规则有一个例外：可以拷贝或赋值一个将要被编译器销毁的unique_ptr，这时编译器执行一种特殊的拷贝（<code>移动</code>）。例如可从函数中返回unique_ptr，也可返回局部unique_ptr对象的拷贝</li>
<li>例子：可拷贝将要被编译器销毁的unique_ptr</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//从函数中返回unique_ptr
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">//返回局部unique_ptr对象的拷贝
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>早期的标准库中有一个名为<code>auto_ptr</code>的类，它具有unique_ptr的部分特性，但不完整。特别是，不能在容器中保存auto_ptr，也不能从函数中返回auto_ptr。auto_ptr在标准库中仍存在，但应避免使用，应使用unique_ptr</li>
<li>unique_ptr默认用<code>delete</code>释放它指向的对象，也可<code>自定义delete</code>，但unique_ptr管理删除器的方式和shared_ptr不同</li>
<li>重载unique_ptr的删除器会影响到unique_ptr类型以及如何构造（或reset）unique_ptr对象。因此必须在unique_ptr的模板参数中提供删除器函数的指针类型，构造或reset时需提供删除器。</li>
<li>例子：自定义unique_ptr的delete</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//以下是C/C++兼容的网络库
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">destination</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">connection</span><span class="p">;</span>
<span class="n">connection</span> <span class="nf">connect</span><span class="p">(</span><span class="n">destination</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">disconnect</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span>
<span class="c1">//以下是使用这个库，unique_ptr管理连接
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">end_connection</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span><span class="n">disconnect</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);}</span> <span class="c1">//自定义delete操作用于关闭连接
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">destination</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">){</span>
    <span class="n">connection</span> <span class="n">c</span><span class="o">=</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">connection</span><span class="p">,</span><span class="k">decltype</span><span class="p">(</span><span class="n">end_connection</span><span class="p">)</span> <span class="o">*&gt;</span> 
              <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="n">end_connection</span><span class="p">);</span>                 <span class="c1">//unique_ptr管理连接
</span><span class="c1"></span>    <span class="cm">/* 使用连接 */</span>
<span class="p">}</span>                                                   <span class="c1">//unique_ptr离开作用域，自动关闭连接
</span></code></pre></td></tr></table>
</div>
</div><h3 id="weak_ptr">weak_ptr</h3>
<ul>
<li><code>weak_ptr</code>是一种不控制指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。</li>
<li>将weak_ptr绑定到shared_ptr指向的对象时，不会改变shared_ptr的引用计数，一旦该对象的shared_ptr引用计数清零，对象就会被释放，即使有weak_ptr指向它。</li>
<li>weak的用法如表12.5
<img src="../cpp_figs/CPPprimer_ch12-tab_12_5.png" alt="tab_12_5"></li>
<li>创建weak_ptr时要在模板参数中给出指向对象类型，并用shared_ptr来初始化。模板参数中的类型只需能转换为shared_ptr指向的类型即可，不需严格匹配</li>
<li>由于weak_ptr的对象可能不存在，故不能用weak_ptr直接访问对象，而必须用<code>lock</code>成员函数。lock函数先检查指向对象是否存在，若存在则返回指向该对象的shared_ptr（与初始化weak_ptr的shared_ptr共享引用计数），不存在则返回空的shared_ptr</li>
<li>例子：利用weak_ptr定义伴随指针类（类似迭代器），使用时不干涉底层对象的生存期，但在底层对象不存在时可阻止访问</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/* 上下文：前面例子中的StrBlob */</span>
<span class="k">class</span> <span class="nc">StrBlobPtr</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">StrBlobPtr</span><span class="p">()</span><span class="o">:</span><span class="n">curr</span><span class="p">(</span><span class="mi">0</span><span class="p">){}</span>
    <span class="c1">//用底层对象的shared_ptr初始化weak_ptr，在StrBlob中声明StrBlobPtr为友元才可访问
</span><span class="c1"></span>    <span class="n">StrBlobPtr</span><span class="p">(</span><span class="n">StrBlob</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">sz</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">wptr</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">),</span><span class="n">curr</span><span class="p">(</span><span class="n">sz</span><span class="p">){}</span>
    <span class="c1">//解引用，访问当前位置的元素
</span><span class="c1"></span>    <span class="n">string</span> <span class="o">&amp;</span><span class="n">deref</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//前置递增，位置向前推进
</span><span class="c1"></span>    <span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="n">incr</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">//若检查成功，返回指向底层对象的shared_ptr
</span><span class="c1"></span>    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">check</span><span class="p">(</span><span class="n">size_t</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//weak_ptr指向底层对象
</span><span class="c1"></span>    <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">wptr</span><span class="p">;</span>
    <span class="c1">//当前位置
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">curr</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//检查两项：1、底层对象是否还存在；2、索引是否越界
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="n">check</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
    <span class="c1">//使用weak_ptr检查对象是否存在
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">ret</span><span class="o">=</span><span class="n">wptr</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">throw</span> <span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;unbound StrBlobPtr&#34;</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span>              <span class="c1">//size_t是无符号，下溢时自动变成最大值。故只需检查i&gt;=size
</span><span class="c1"></span>        <span class="k">throw</span> <span class="n">out_of_range</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//解引用，访问当前位置的元素
</span><span class="c1"></span><span class="n">string</span> <span class="o">&amp;</span><span class="n">StrBlobPtr</span><span class="o">::</span><span class="n">deref</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
    <span class="c1">//检查当前位置是否合法，并返回shared_ptr
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">p</span><span class="o">=</span><span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="s">&#34;dereference past end&#34;</span><span class="p">);</span>
    <span class="c1">//访问元素
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">curr</span><span class="p">];</span>
<span class="p">}</span>
<span class="c1">//对位置进行前置递增
</span><span class="c1"></span><span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="n">StrBlobPtr</span><span class="o">::</span><span class="n">incr</span><span class="p">(){</span>
    <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="s">&#34;increment past end of StrBlobPtr&#34;</span><span class="p">);</span>
    <span class="o">++</span><span class="n">curr</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//在StrBlob定义前加上这一行，前向声明StrBlobPtr
</span><span class="c1"></span><span class="k">class</span> <span class="nc">StrBlobPtr</span><span class="p">;</span>
<span class="c1">//在StrBlob定义中加上如下几行，声明StrBlobPtr为友元，并提供返回StrBlobPtr的接口
</span><span class="c1"></span><span class="k">friend</span> <span class="k">class</span> <span class="nc">StrBlobPtr</span><span class="p">;</span>
<span class="n">StrBlobPtr</span> <span class="nf">begin</span><span class="p">();</span>
<span class="n">StrBlobPtr</span> <span class="nf">end</span><span class="p">();</span>
<span class="c1">//在StrBlobPtr完整定义后，实现从StrBlob中得到StrBlobPtr的函数，*this是用于初始化StrBlobPtr的StrBlob
</span><span class="c1"></span><span class="n">StrBlobPtr</span> <span class="n">StrBlob</span><span class="o">::</span><span class="n">begin</span><span class="p">(){</span><span class="k">return</span> <span class="nf">StrBlobPtr</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);}</span>
<span class="n">StrBlobPtr</span> <span class="n">StrBlob</span><span class="o">::</span><span class="n">end</span><span class="p">(){</span>
    <span class="k">auto</span> <span class="n">ret</span><span class="o">=</span><span class="n">StrBlobPtr</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 使用StrBlob和StrBlobPtr */</span>
<span class="c1">//定义一个StrBlob对象
</span><span class="c1"></span><span class="n">StrBlob</span> <span class="n">b1</span><span class="p">;</span>                         <span class="c1">//创建新StrBlob
</span><span class="c1"></span><span class="p">{</span>                                   <span class="c1">//进入新作用域
</span><span class="c1"></span>    <span class="n">StrBlob</span> <span class="n">b2</span><span class="o">=</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="s">&#34;an&#34;</span><span class="p">,</span><span class="s">&#34;the&#34;</span><span class="p">};</span>    <span class="c1">//初始化b2
</span><span class="c1"></span>    <span class="n">b1</span><span class="o">=</span><span class="n">b2</span><span class="p">;</span>                          <span class="c1">//用b2初始化b1，它们共享底层数据
</span><span class="c1"></span><span class="p">}</span>                                   <span class="c1">//离开作用域，b2被释放，b1仍存在，共享的底层数未丢失
</span><span class="c1">//从StrBlob中得到StrBlobPtr
</span><span class="c1"></span><span class="k">auto</span> <span class="n">p1</span><span class="o">=</span><span class="n">b1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">p2</span><span class="o">=</span><span class="n">b1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="c1">//通过StrBlobPtr依次访问StrBlob中的元素
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">b1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p1</span><span class="p">.</span><span class="n">deref</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">.</span><span class="n">incr</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="动态数组">动态数组</h2>
<ul>
<li>new/delete一次只分配/释放一个对象，但有时需要一次为很多元素分配内存，如容器扩张时</li>
<li>两种一次性分配一个<code>动态数组</code>的功能：
<ul>
<li>C++语言提供：另一种<code>new表达式</code>，可分配并初始化一个动态数组</li>
<li>标准库提供：<code>allocator类</code>，可分配多个元素的内存，并将分配和初始化分离，性能更好更灵活</li>
</ul>
</li>
<li>最佳实践：应优先使用容器而不是动态数组来管理可变数量的对象</li>
<li>使用容器的类可用默认版本的拷贝/赋值/析构来处理容器，而分配动态数组的类必须自定义拷贝/赋值/析构操作来处理动态数组</li>
</ul>
<h3 id="new和数组">new和数组</h3>
<ul>
<li>使用new分配动态数组，要在类型名后跟一对方括号<code>[]</code>，并在方括号中指明要分配对象的数目</li>
<li>可用表示数组的类型别名来分配动态数组</li>
<li>例子：分配动态数组</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">pia</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>   <span class="c1">//分配动态数组
</span><span class="c1"></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">arrT</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="n">arrT</span><span class="p">;</span>        <span class="c1">//用数组的类型别名来分配
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>new分配动态数组时，并未得到数组类型的对象，而是返回指向该数组的指针。</li>
<li>由于new返回的不是数组类型，故不能对动态数组使用begin和end，也不能用范围for</li>
<li>new动态数组的<code>初始化</code>：
<ul>
<li>默认情况下new分配的对象（单个或数组）都是<code>默认初始化</code></li>
<li>可用花括号对动态数组做<code>列表初始化</code>。若列表过短则剩下的值初始化，列表过长则分配失败并抛出异常<code>bad_array_new_length</code>（定义于头文件<code>new</code>）</li>
<li>可用空的圆括号对动态数组做<code>值初始化</code>，括号内不能有值。不能用auto分配动态数组</li>
</ul>
</li>
<li>例子：new动态数组的初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//默认初始化
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pia</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">string</span> <span class="o">*</span><span class="n">psa</span><span class="o">=</span><span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="c1">//列表初始化
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pia2</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">string</span> <span class="o">*</span><span class="n">psa2</span><span class="o">=</span><span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]{</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="s">&#34;an&#34;</span><span class="p">,</span><span class="s">&#34;the&#34;</span><span class="p">,</span><span class="n">string</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="sc">&#39;x&#39;</span><span class="p">)};</span>
<span class="c1">//值初始化（不能在括号中给值）
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pia3</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]();</span>
<span class="n">string</span> <span class="o">*</span><span class="n">psa3</span><span class="o">=</span><span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]();</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>用new分配大小为0的数组时，new返回一个合法的非空的指针，并保证该指针与new返回的任何其他指针都不同。对于长为0的数组，该指针类似尾后迭代器。</li>
<li>释放动态数组时可用特殊形式的delete，在指针前加空的方括号<code>[]</code></li>
<li>动态数组中的元素按<code>逆序销毁</code>，即从最后一个元素开始</li>
<li>若在delete动态数组时忽略了<code>[]</code>，或在delete单个对象时使用了<code>[]</code>，其行为都是未定义</li>
<li>即使在new时使用类型别名导致new中没有<code>[]</code>，也要在delete中写<code>[]</code></li>
<li>例子：销毁动态数组</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">arrT</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="n">arrT</span><span class="p">;</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>unique_ptr</code>可管理new分配的动态数组，只需在模板参数中指定类型为数组即可。unique_ptr销毁动态数组的方式是使用<code>delete []</code></li>
<li>例子：unique_ptr管理动态数组</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span> <span class="p">[]</span><span class="o">&gt;</span> <span class="n">up</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span> <span class="c1">//在模板参数中指定为动态数组。由于是指针而不是数组，故不写大小
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">!=</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">up</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>                        <span class="c1">//下标访问unique_ptr管理的动态数组
</span><span class="c1"></span><span class="n">up</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>                       <span class="c1">//自动调用delete []
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>指向数组的unique_ptr操作如表12.6：
<img src="../cpp_figs/CPPprimer_ch12-tab_12_6.png" alt="tab_12_6"></li>
<li>unique_ptr指向动态数组时，不可使用点<code>.</code>和箭头<code>-&gt;</code>算符，因为指向的是数组而不是单个对象</li>
<li>unique_ptr指向动态数组时，可用下标<code>[]</code>访问元素</li>
<li>若要使用shared_ptr管理动态数组，需提供<code>自定义delete</code></li>
<li>shared_ptr未定义下标算符，且智能指针都不支持指针算数运算。故shared_ptr访问数组中元素时必须用get函数取出内置指针</li>
<li>例子：shared_ptr管理动态数组</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
                   <span class="p">[](</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span><span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;});</span>    <span class="c1">//自定义lambda，使用delete []来释放
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">!=</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>                            <span class="c1">//使用get得到内置指针来访问元素
</span><span class="c1"></span><span class="n">sp</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>                                     <span class="c1">//使用自定义的lambda释放动态数组
</span></code></pre></td></tr></table>
</div>
</div><h3 id="allocator类">allocator类</h3>
<ul>
<li>new/delete在灵活性上的局限：将内存分配和对象构造组合在一起，将对象析构和内存释放组合在一起</li>
<li>分配一大块内存时，通常要按需构造对象。此时希望将内存分配和对象构造分离，只在真正需要时才构造对象</li>
<li>new的局限性：
<ul>
<li>分配空间时即构造对象，初始化之后再赋予新值，则每个元素被赋值两次</li>
<li>分配空间被对象填满，可能创建了一些永远不会使用的对象</li>
<li>没有默认构造函数的类不能用new分配动态数组</li>
</ul>
</li>
<li><code>allocator</code>类定义在<code>memory</code>头文件中，提供一种类型感知的内存分配，分配的内存是原始的、未构造的。它可将内存分配和对象构造分离，将对象销毁和内存释放分离。</li>
<li>allocator支持的操作见表12.7
<img src="../cpp_figs/CPPprimer_ch12-tab_12_7.png" alt="tab_12_7"></li>
<li>allocator也是模板类，需在模板参数中给出分配的对象类型。分配内存时根据给定的类型来确定恰当的内存大小和对齐位置</li>
<li><code>allocate</code>成员函数接受一个参数，指定分配能容纳多少个该对象的内存</li>
<li><code>construct</code>成员函数接受一个指针和额外参数，在指针所指位置构造一个元素，额外参数匹配到元素的构造函数</li>
<li>为使用allocate分配的内存，必须用construct构造对象。使用未构造的内存是未定义</li>
<li>早期的标准库construct只接受两个参数，一个指针和一个元素类型的值，只能把给定值拷贝进内存</li>
<li>使用完对象后必须对每个对象调用<code>destroy</code>来销毁，该成员函数接受一个指针，执行所指元素的析构函数</li>
<li>只能对真正构造了的元素进行destroy操作，对未构造的空间进行destroy是未定义</li>
<li>使用destroy销毁元素后可以再构造元素，也可将内存还给系统</li>
<li>使用<code>deallocate</code>成员函数释放内存，它接受两个参数，一个指向这块内存的指针和一个销毁元素的数量，该数量必须与allocate分配的数量相同（即只能全部释放）。</li>
<li>例子：使用allocator</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">p</span><span class="o">=</span><span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">//分配n个string的内存，返回首指针
</span><span class="c1"></span><span class="k">auto</span> <span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>                       <span class="c1">//指向分配区域的起始
</span><span class="c1"></span><span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">++</span><span class="p">);</span>           <span class="c1">//构造空字符串，指针推进
</span><span class="c1"></span><span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">++</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">);</span>    <span class="c1">//构造字符串，指针推进
</span><span class="c1"></span><span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">++</span><span class="p">,</span><span class="s">&#34;hi&#34;</span><span class="p">);</span>      <span class="c1">//构造字符串，指针推进
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>                 <span class="c1">//有效，p指向区域起始，此处有对象
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">q</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>                 <span class="c1">//未定义，q指向已构造空间的尾后，此处无对象
</span><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="o">!=</span><span class="n">p</span><span class="p">)</span>
    <span class="n">alloc</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="o">--</span><span class="n">q</span><span class="p">);</span>         <span class="c1">//从尾部开始销毁元素
</span><span class="c1"></span><span class="n">alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>          <span class="c1">//释放所有内存
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>标准库为allocator类定义了两个<code>伴随算法</code>，用于在未初始化的内存中创建对象，它们定义于<code>memory</code>头文件中</li>
<li>allocator的伴随算法见表12.8
<img src="../cpp_figs/CPPprimer_ch12-tab_12_8.png" alt="tab_12_8"></li>
<li>uninitialized_copy类似copy，接受3个迭代器参数，前两个表示输入序列，第三个表示目的位置。目的位置必须是未构造的内存。该函数在目的位置构造元素，并返回已构造序列的尾后迭代器</li>
<li>uninitialized_fill_n类似fill_n，接受一个指向目的位置的指针、一个计数、一个值。该函数在目的位置创建给定个数目的对象，用给定值初始化</li>
<li>例子：使用allocator的伴随算法</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">p</span><span class="o">=</span><span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>                 <span class="c1">//分配vi长度两倍的内存
</span><span class="c1"></span><span class="k">auto</span> <span class="n">q</span><span class="o">=</span><span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">p</span><span class="p">);</span>   <span class="c1">//将vi拷贝进分配的内存，返回已拷贝区域的尾后迭代器
</span><span class="c1"></span><span class="n">uninitialized_fill_n</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="mi">42</span><span class="p">);</span>               <span class="c1">//剩下的内存初始化未42；
</span></code></pre></td></tr></table>
</div>
</div><h2 id="使用标准库文本查询程序">使用标准库：文本查询程序</h2>
<ul>
<li>例子：查询单词在文件中出现的次数及行号，可打印所有行的内容
//输入示例：
本章英文版
//输出示例：（假如要查询单词element）
element occurs 112 times:
(line 36) A set element contains only a key;
(line 158) operator creates a new element
(line 160) Regardless of whether the element
(line 168) When we fetch an element from a map, we
(line 214) If the element is not found, find returns</li>
</ul>
<h3 id="文本查询程序设计">文本查询程序设计</h3>
<ul>
<li>开始程序设计的一种好方法是列出程序的操作，这会帮助分析需要什么数据结构
<ul>
<li><code>vector&lt;string&gt;</code>来保存整个输入文件的一份拷贝，用行号作为下标索引一行</li>
<li><code>istringstream</code>将每行分解为单词</li>
<li><code>set</code>保存单词出现的行号，保证行号不重复且升序保存</li>
<li><code>map</code>将每个单词与其行号<code>set</code>关联</li>
<li>用一个类保存和查询，另一个类保存查询结果。用<code>shared_ptr</code>在它们之间共享文本数据和行号集合</li>
</ul>
</li>
<li>自顶向下：设计一个类时，在真正实现成员之前先编写程序使用这个类</li>
<li>使用TextQuery类</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">runQueries</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">infile</span><span class="p">){</span>
    <span class="n">TextQuery</span> <span class="n">tq</span><span class="p">(</span><span class="n">infile</span><span class="p">);</span>                           <span class="c1">//构造查询的类
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;enter word to look for, or q to quit: &#34;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">s</span><span class="p">)</span> <span class="o">||</span> <span class="n">s</span><span class="o">==</span><span class="s">&#34;q&#34;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> 		<span class="c1">//若输入无效或使用退出指令
</span><span class="c1"></span>        <span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span><span class="n">tq</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  	<span class="c1">//打印查询结果
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="文本查询程序类的定义">文本查询程序类的定义</h3>
<ul>
<li>TextQuery类</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">QueryResult</span><span class="p">;</span> <span class="c1">//前向声明
</span><span class="c1"></span><span class="k">class</span> <span class="nc">TextQuery</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//定义行号类型
</span><span class="c1"></span>    <span class="k">using</span> <span class="n">line_no</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span>
    <span class="c1">//根据文件流构造
</span><span class="c1"></span>    <span class="n">TextQuery</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="c1">//根据给定的要查找字符串返回QueryResult对象
</span><span class="c1"></span>    <span class="n">QueryResult</span> <span class="nf">query</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">//用shared_ptr管理底层文本数据
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">file</span><span class="p">;</span>
    <span class="c1">//用shared_ptr管理每个单词的行号集合，并将单词map到行号集合
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;&gt;&gt;</span> <span class="n">wm</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//构造函数，初值列表中分配动态内存来构造智能指针
</span><span class="c1"></span><span class="n">TextQuery</span><span class="o">::</span><span class="n">TextQuery</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">)</span><span class="o">:</span><span class="n">file</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
    <span class="c1">//取出一行
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">text</span><span class="p">)){</span>
        <span class="c1">//逐行放入底层vector中
</span><span class="c1"></span>        <span class="n">file</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
        <span class="c1">//n是这一行在vector中的索引
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">line</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">word</span><span class="p">;</span>
        <span class="c1">//用istringstream从一行中读取单词
</span><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">line</span><span class="o">&gt;&gt;</span><span class="n">word</span><span class="p">){</span>
        	<span class="c1">//若word不在map中则添加到map。使用引用是因为对应的集合会改变
</span><span class="c1"></span>            <span class="k">auto</span> <span class="o">&amp;</span><span class="n">lines</span><span class="o">=</span><span class="n">wm</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">lines</span><span class="p">)</span> <span class="c1">//line是智能指针，若指针为空，则说明刚创建，需要new一个set
</span><span class="c1"></span>                <span class="n">lines</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;</span><span class="p">);</span>
            <span class="c1">//将当前行号插入该单词对应的set
</span><span class="c1"></span>            <span class="n">lines</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>QueryResult类</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">QueryResult</span><span class="p">{</span>
<span class="c1">//通过友元函数实现接口
</span><span class="c1"></span><span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="p">,</span><span class="k">const</span> <span class="n">QueryResult</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">line_no</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span>
    <span class="c1">//构造函数只用来初始化成员
</span><span class="c1"></span>    <span class="n">QueryResult</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;&gt;</span> <span class="n">p</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">f</span><span class="p">)</span><span class="o">:</span>
               <span class="n">sought</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="n">lines</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="n">file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">{}</span><span class="err">、</span>
    <span class="c1">//以下3个函数是15.9的面向对象例程需要用的
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">(){</span><span class="k">return</span> <span class="n">lines</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span><span class="p">(){</span><span class="k">return</span> <span class="n">lines</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">get_file</span><span class="p">(){</span><span class="k">return</span> <span class="n">file</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sought</span><span class="p">;</span>                             <span class="c1">//要查找的单词
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;&gt;</span> <span class="n">lines</span><span class="p">;</span>       <span class="c1">//shared_ptr指向行号set
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">file</span><span class="p">;</span> <span class="c1">//shared_ptr指向文本vector
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>query成员函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">QueryResult</span> <span class="n">TextQuery</span><span class="o">::</span><span class="n">query</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sought</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
    <span class="c1">//未找到给定单词时返回的空集合。由于只需要一个这样的集合，声明为static避免每次未找到都分配空间
</span><span class="c1"></span>    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;&gt;</span> <span class="n">nodata</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">loc</span><span class="o">=</span><span class="n">wm</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">sought</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">loc</span><span class="o">==</span><span class="n">wm</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="c1">//未找到时得到指向空集合的指针
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">QueryResult</span><span class="p">(</span><span class="n">sought</span><span class="p">,</span><span class="n">nodata</span><span class="p">,</span><span class="n">file</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="c1">//找到时得到指向对应集合的指针
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">QueryResult</span><span class="p">(</span><span class="n">sought</span><span class="p">,</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>打印结果</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="k">const</span> <span class="n">QueryResult</span> <span class="o">&amp;</span><span class="n">qr</span><span class="p">){</span>
    <span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">qr</span><span class="p">.</span><span class="n">sought</span><span class="o">&lt;&lt;</span><span class="s">&#34; occurs &#34;</span><span class="o">&lt;&lt;</span><span class="n">qr</span><span class="p">.</span><span class="n">lines</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span>
      <span class="o">&lt;&lt;</span><span class="p">((</span><span class="n">qr</span><span class="p">.</span><span class="n">lines</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="s">&#34; times&#34;</span><span class="o">:</span><span class="s">&#34; time&#34;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">num</span><span class="p">:</span><span class="o">*</span><span class="n">qr</span><span class="p">.</span><span class="n">lines</span><span class="p">)</span>
        <span class="n">os</span><span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\t</span><span class="s">(line &#34;</span><span class="o">&lt;&lt;</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="s">&#34;) &#34;</span>
          <span class="o">&lt;&lt;*</span><span class="p">(</span><span class="n">qr</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">num</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>封装：将上述定义按顺序放入文件中，并将runQueries放在最后，并添加头文件和头文件保护，封装为hpp：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//文件名：TextQuery.hpp
</span><span class="c1"></span><span class="cp">#ifndef __TEXTQUERY_HPP__
</span><span class="cp">#define __TEXTQUERY_HPP__
</span><span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;set&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;memory&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cm">/* 上面的一些定义和runQueries */</span>
<span class="cp">#endif
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>测试：建立cpp文件，包含上述头文件</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//文件名：TextQuery_test.cc
</span><span class="c1"></span><span class="cp">#include</span><span class="cpf">&#34;./TextQuery.hpp&#34;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">in</span><span class="p">(</span><span class="s">&#34;文件名&#34;</span><span class="p">);</span>
    <span class="n">runQueries</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">canpi</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-03-08
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_wechat.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_alipay.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          <a href="/tags/c&#43;&#43;-primer/">C&#43;&#43; primer</a>
          <a href="/tags/%E8%AF%BB%E4%B9%A6/">读书</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cpp/cppprimer_ch13/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43; primer 第13章 拷贝控制</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/cpp/cppprimer_ch11/">
            <span class="next-text nav-default">C&#43;&#43; primer 第11章 关联容器</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/cpp/cppprimer_ch12/" class="leancloud_visitors" data-flag-title="C&#43;&#43; primer 第12章 动态内存">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'ntftaTIdLaT8sVPL9qFX5dAg-gzGzoHsz',
        appKey: 'lNOKznaI2Gnej5D2MgpUJnzV',
        notify:  false ,
        verify:  false ,
        avatar:'retro',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hucanpei@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/hucanpei" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/canpi" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">canpi</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>








</body>
</html>
