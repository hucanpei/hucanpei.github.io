<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; primer 第10章 泛型算法 - pi</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="canpi" /><meta name="description" content="标准库未给容器添加大量功能，而是提供一组独立于容器的泛型算法 算法：它们实现了一些经典算法的公共接口 泛型：它们可用于不同类型的容器和不同类型的" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.67.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/cpp/cppprimer_ch10/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.78f8f17bab244b9ee62ad16480c9584d5fc2db06ae20681d1ca225cefd80767c.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; primer 第10章 泛型算法" />
<meta property="og:description" content="标准库未给容器添加大量功能，而是提供一组独立于容器的泛型算法 算法：它们实现了一些经典算法的公共接口 泛型：它们可用于不同类型的容器和不同类型的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/cpp/cppprimer_ch10/" />
<meta property="article:published_time" content="2020-02-25T15:01:00+08:00" />
<meta property="article:modified_time" content="2020-02-25T15:01:00+08:00" />
<meta itemprop="name" content="C&#43;&#43; primer 第10章 泛型算法">
<meta itemprop="description" content="标准库未给容器添加大量功能，而是提供一组独立于容器的泛型算法 算法：它们实现了一些经典算法的公共接口 泛型：它们可用于不同类型的容器和不同类型的">
<meta itemprop="datePublished" content="2020-02-25T15:01:00&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-25T15:01:00&#43;08:00" />
<meta itemprop="wordCount" content="9641">



<meta itemprop="keywords" content="C&#43;&#43;,C&#43;&#43; primer,读书," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; primer 第10章 泛型算法"/>
<meta name="twitter:description" content="标准库未给容器添加大量功能，而是提供一组独立于容器的泛型算法 算法：它们实现了一些经典算法的公共接口 泛型：它们可用于不同类型的容器和不同类型的"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">canpi</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">canpi</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; primer 第10章 泛型算法</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-02-25 </span>
        <div class="post-category">
            <a href="/categories/c&#43;&#43;/"> C&#43;&#43; </a>
            <a href="/categories/c&#43;&#43;-primer/"> C&#43;&#43; primer </a>
            </div>
          <span class="more-meta"> 约 9641 字 </span>
          <span class="more-meta"> 预计阅读 20 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#概述">概述</a></li>
    <li><a href="#初识泛型算法">初识泛型算法</a>
      <ul>
        <li><a href="#只读算法">只读算法</a></li>
        <li><a href="#写容器元素的算法">写容器元素的算法</a></li>
        <li><a href="#重排容器元素的算法">重排容器元素的算法</a></li>
      </ul>
    </li>
    <li><a href="#定制操作">定制操作</a>
      <ul>
        <li><a href="#向算法传递函数">向算法传递函数</a></li>
        <li><a href="#lambda表达式">lambda表达式</a></li>
        <li><a href="#lambda捕获和返回">lambda捕获和返回</a></li>
        <li><a href="#参数绑定">参数绑定</a></li>
      </ul>
    </li>
    <li><a href="#再探迭代器">再探迭代器</a>
      <ul>
        <li><a href="#插入迭代器">插入迭代器</a></li>
        <li><a href="#iostream迭代器">iostream迭代器</a></li>
        <li><a href="#反向迭代器">反向迭代器</a></li>
      </ul>
    </li>
    <li><a href="#泛型算法结构">泛型算法结构</a>
      <ul>
        <li><a href="#5类迭代器">5类迭代器</a></li>
        <li><a href="#算法形参模式">算法形参模式</a></li>
        <li><a href="#算法命名规范">算法命名规范</a></li>
      </ul>
    </li>
    <li><a href="#特定容器算法">特定容器算法</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <ul>
<li>标准库未给容器添加大量功能，而是提供一组独立于容器的<code>泛型算法</code>
<ul>
<li><code>算法</code>：它们实现了一些经典算法的公共接口</li>
<li><code>泛型</code>：它们可用于不同类型的容器和不同类型的元素</li>
</ul>
</li>
<li>利用这些算法可实现容器基本操作很难做到的事，例如查找/替换/删除特定值、重排顺序等</li>
</ul>
<h2 id="概述">概述</h2>
<ul>
<li>大多数算法定义在<code>algorithm</code>头文件中，另外一组数值算法定义在<code>numeric</code>头文件中</li>
<li>标准库算法不直接操作容器，而是遍历迭代器范围</li>
<li>指针就像内置数组上的迭代器，故泛型算法也可操作内置数组和指针</li>
<li><code>find</code>算法：
<ul>
<li>作用：将范围中每一个元素与给定值比较，返回第一个等于给定值的元素的迭代器，如果没有匹配则返回该范围的尾后迭代器。</li>
<li>用法：有3个参数，前2个是输入范围，第3个是给定值。</li>
<li>实现：调用给定值类型的<code>==</code>算符来比较。</li>
</ul>
</li>
<li>算法只依赖迭代器来访问元素并在范围中推进，不依赖于容器操作。但迭代器依赖元素类型上定义的算符，如<code>==</code>、<code>&lt;</code>等</li>
<li>算法不会改变容器大小。它可能改变元素值或移动元素，但不会添加或删除。</li>
<li>标准库定义了<code>插入迭代器</code>，给它们赋值时会在容器上插入。算法操作这样的迭代器时可完成插入元素的效果。</li>
<li>一些算法提供了接口，允许使用自定义的<code>谓词</code>来代替默认算符</li>
<li><code>count</code>算法：
<ul>
<li>作用：将范围中每一个元素与给定值比较，返回给定值在范围中出现的次数。</li>
<li>用法：有3个参数，前2个是输入范围，第3个是给定值。</li>
<li>实现：调用给定值类型的<code>==</code>算符来比较。</li>
</ul>
</li>
</ul>
<h2 id="初识泛型算法">初识泛型算法</h2>
<ul>
<li>附录A中列出所有算法</li>
<li><code>输入范围</code>：大多标准库算法都对一个范围内的元素操作，这个范围称为输入范围。接受输入范围的算法总是用前两个参数来表示输入范围。</li>
<li>多数算法遍历输入范围的方式相似，但使用元素的方法不同（是否读，是否写，是否重排等）。</li>
</ul>
<h3 id="只读算法">只读算法</h3>
<ul>
<li><code>只读算法</code>只读取输入范围的元素，不改变它们。如上一节的find和count</li>
<li>使用只读算法，最好用cbegin/cend</li>
<li><code>accumulate</code>算法（定义于numeric）：
<ul>
<li>作用：对范围中元素求和，再加上给定值，返回求值结果。</li>
<li>用法：有3个参数，前2个是输入范围，第3个是给定值。</li>
<li>实现：调用给定值类型的<code>+</code>算符来求和。</li>
</ul>
</li>
<li>例子：算法严格使用给定值的操作符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">=</span><span class="p">{</span><span class="s">&#34;hello&#34;</span><span class="p">,</span><span class="s">&#34;world&#34;</span><span class="p">};</span>
<span class="n">string</span> <span class="n">sum</span><span class="o">=</span><span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span><span class="s">&#34;&#34;</span><span class="p">);</span>          <span class="c1">//错，const char *类型未定义+算符
</span><span class="c1"></span><span class="n">string</span> <span class="n">sum</span><span class="o">=</span><span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">));</span>  <span class="c1">//对，string上定义了+算符
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>equal</code>算法：
<ul>
<li>作用：确定两序列的值是否相同。所有元素都相等时返回true，否则false</li>
<li>用法：有3个参数，前2个是第一个序列的输入范围，第3个是第二个范围的首迭代器。</li>
<li>实现：调用<code>==</code>算符来比较，元素类型不必严格一致。</li>
</ul>
</li>
<li>某些算法接受单一迭代器来指定第二个序列，这些算法都假定第二个序列至少和第一个序列一样长</li>
</ul>
<h3 id="写容器元素的算法">写容器元素的算法</h3>
<ul>
<li>可对序列中元素重新赋值，要求原序列大小不小于要写入的元素数目。算法不执行容器操作，故不可改变序列大小</li>
<li><code>fill</code>算法：
<ul>
<li>作用：用给定值填满输入范围</li>
<li>用法：有3个参数，前2个是输入范围，第3个是给定值。</li>
</ul>
</li>
<li>操作两序列的算法不要求两序列的容器相同，但要求元素可操作</li>
<li>操作两序列的算法分为两种：
<ul>
<li>接受3个迭代器，前两个表示第一个序列的范围，第三个表示第二个序列的起始。总是假定第二个序列至少和第一个序列一样长</li>
<li>接受4个迭代器，前两个表示第一个序列的范围，后两个表示第二个序列的范围</li>
</ul>
</li>
<li><code>fill_n</code>算法：
<ul>
<li>作用：用给定值填满长为n的区间</li>
<li>用法：有3个参数，第1个代表序列起始的迭代器，第2个是序列长度的计数值，第3个是填入的给定值。</li>
</ul>
</li>
<li>fill_n假定长为n的空间总是有效的，类似指针运算。算法不会改变容器的大小。</li>
<li><code>插入迭代器</code>：给插入迭代器赋值会向容器中插入元素，即真正改变容器的大小。</li>
<li>通过给插入迭代器赋值，算法可保证容器中总有足够的空间</li>
<li><code>back_inserter</code>函数定义于<code>iterator</code>头文件中，它接受一个指向容器的引用，返回该容器的一个插入迭代器。通过此迭代器赋值时，赋值符会调用容器类型的<code>push_back</code>来添加元素</li>
<li>例子：算法中使用back_inserter</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>                    <span class="c1">//空vector
</span><span class="c1"></span><span class="n">fill_n</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>           <span class="c1">//错，算法不可向空vector写值
</span><span class="c1"></span><span class="n">fill_n</span><span class="p">(</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>    <span class="c1">//对，在vec尾部插入10个0
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>copy</code>算法：
<ul>
<li>作用：将输入范围的值拷贝到目标序列，返回目标序列的尾后迭代器</li>
<li>用法：有3个参数，前2个是输入范围，第3个是目标序列的起始位置</li>
</ul>
</li>
<li>很多算法提供<code>copy版本</code>，即计算新元素的值后，不放入原来的序列，而是放入一个新序列中。</li>
<li><code>replace</code>算法：
<ul>
<li>作用：将序列中所有等于给定值的元素换为另一个值</li>
<li>用法：有4个参数，前2个是输入范围，后2个分别是要搜索的值和新值</li>
</ul>
</li>
<li><code>replace_copy</code>算法：
<ul>
<li>作用：将序列中所有等于给定值的元素换为另一个值，放入新序列，原序列不变。</li>
<li>用法：有5个参数，前2个是输入范围，第3个是输出序列的首迭代器，最后2个分别是要搜索的值和新值</li>
</ul>
</li>
<li>例子：replace和replace_copy</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ilst</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">;</span>
<span class="n">replace</span><span class="p">(</span><span class="n">ilst</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ilst</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="mi">0</span><span class="p">,</span><span class="mi">42</span><span class="p">);</span>                              <span class="c1">//原址版本，将ilst中的0都替换为42
</span><span class="c1"></span><span class="n">replace_copy</span><span class="p">(</span><span class="n">ilst</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">ilst</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">ivec</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="mi">42</span><span class="p">);</span>   <span class="c1">//copy版本，将ilst中的0替换为42后插入ivec，ilst不变
</span></code></pre></td></tr></table>
</div>
</div><h3 id="重排容器元素的算法">重排容器元素的算法</h3>
<ul>
<li>可对容器中元素重新排列顺序</li>
<li><code>sort</code>算法：
<ul>
<li>作用：重排输入序列的元素使其有序</li>
<li>用法：有2个参数，是输入范围</li>
<li>实现：调用序列元素类型的<code>&lt;</code>算符</li>
</ul>
</li>
<li><code>unique</code>算法：
<ul>
<li>作用：重排输入序列，消除相邻重复项。返回消除后的无相邻重复值的范围的尾后迭代器</li>
<li>用法：有2个参数，是输入范围</li>
</ul>
</li>
<li>unique不真正删除元素，只是将后面的不重复值前移来覆盖前面的重复值，使不重复值在序列前部。</li>
<li>unique将不重复元素向首部集中，尾部（返回迭代器之后）的元素值是未定义</li>
<li>真正删除元素需要使用容器操作</li>
<li>例子：消除重复单词</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//将输入vector中的string元素重排并消除重复
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">elimDups</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">){</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>                    <span class="c1">//将元素排序，使重复项相邻
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">end_unique</span><span class="o">=</span><span class="n">unique</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>  <span class="c1">//将不重复元素集中到序列前端，返回不重复元素序列的尾后迭代器
</span><span class="c1"></span>    <span class="n">words</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">end_unique</span><span class="p">,</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>                <span class="c1">//擦除不重复序列之后的元素
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="定制操作">定制操作</h2>
<ul>
<li>对于使用元素的<code>==</code>、<code>&lt;</code>等算符的算法，标准库允许在执行算法时用自定义操作代替默认算符，而不需要在类型中重载。</li>
</ul>
<h3 id="向算法传递函数">向算法传递函数</h3>
<ul>
<li><code>谓词</code>：是一个可调用的表达式，其返回值可用作条件（即true/false）。按照参数的数量分为<code>一元谓词</code>和<code>二元谓词</code></li>
<li>接受谓词的算法用该谓词代替默认的算符来操作元素，故元素类型必须可转为谓词接受的参数类型。例如，接受二元谓词的sort用该谓词代替<code>&lt;</code></li>
<li><code>stable_sort</code>是<code>稳定排序</code>，即维持相等元素的原有顺序</li>
</ul>
<h3 id="lambda表达式">lambda表达式</h3>
<ul>
<li><code>lambda</code>应用的场景：函数接口已固定，但要传入额外的参数，可用lambda的捕获列表。例如谓词中要获取局部变量时。</li>
<li><code>find_if</code>算法：
<ul>
<li>作用：对输入范围的每个元素调用给定谓词，返回第一个使谓词非0的元素的迭代器</li>
<li>用法：有3个参数，前2个是输入范围，第3个是一元谓词</li>
</ul>
</li>
<li><code>可调用对象</code>：一个对象或表达式，若能使用调用运算符<code>()</code>，就是可调用的</li>
<li>4种可调用对象：<code>函数</code>、<code>函数指针</code>、<code>重载了调用算符的类</code>、<code>lambda表达式</code></li>
<li><code>lambda表达式</code>：是一个可调用的代码单元，即一个未命名的<code>内联函数</code>。它有捕获列表、返回类型、形参列表、函数体，但可定义在函数内部（函数不可）</li>
<li>lambda表达式形式:
<code>[capture list](parameter list) -&gt; return type {function body}</code>
<ul>
<li>capture list是<code>捕获列表</code>，是lambda所在函数中定义的局部变量的列表</li>
<li>parameter list、return type、function body与函数一样</li>
<li>lambda必须用<code>尾置返回</code></li>
<li>可忽略形参列表和返回类型，但必须有捕获列表和函数体</li>
<li>若函数体不是单一return语句，则必须指定返回类型（否则为void）</li>
</ul>
</li>
<li>可用变量定义的形式定义lambda，用函数调用的方式使用lambda</li>
<li>例子：使用lambda</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span> <span class="n">f</span><span class="o">=</span><span class="p">[]{</span><span class="k">return</span> <span class="mi">42</span><span class="p">;};</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">f</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//用调用算符使用lambda
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>lambda忽略返回类型时使用类型推导。如果函数体是单一return语句则可推出类型，否则返回void。</li>
<li>调用lambda时用实参初始化形参的方式和函数相同，但<code>lambda不可有默认实参</code></li>
<li>lambda将局部变量包含在捕获列表中来访问它们，只有被捕获到的局部变量才可在函数体中被使用。但只有<code>局部非static变量</code>才需要捕获，<code>lambda可直接使用定义在当前函数之外的名字和局部static变量</code></li>
<li><code>for_each</code>算法：
<ul>
<li>作用：对输入范围的每个元素调用给定的可调用对象</li>
<li>用法：有3个参数，前2个是输入范围，第3个是可调用对象</li>
</ul>
</li>
<li>例子：计数并按字典序打印长度&gt;=给定值的字符串</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//将输入vector中的string元素重排并消除重复
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">elimDups</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">){</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>                    <span class="c1">//将元素排序，使重复项相邻
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">end_unique</span><span class="o">=</span><span class="n">unique</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>  <span class="c1">//将不重复元素集中到序列前端，返回不重复元素序列的尾后迭代器
</span><span class="c1"></span>    <span class="n">words</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">end_unique</span><span class="p">,</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>                <span class="c1">//擦除不重复序列之后的元素
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//计数并按字典序打印vector&lt;string&gt;中长度&gt;=给定值的string
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">biggies</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">sz</span><span class="p">){</span>
    <span class="c1">//按字典排序并消除重复
</span><span class="c1"></span>    <span class="n">elimDups</span><span class="p">(</span><span class="n">words</span><span class="p">);</span>
    <span class="c1">//对字符串长度做稳定排序，长度相同的单词维持字典序
</span><span class="c1"></span>    <span class="c1">//用lambda做二元谓词比较两元素
</span><span class="c1"></span>    <span class="n">stable_sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                <span class="p">[](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();});</span>
    <span class="c1">//找到第一个长度&gt;=sz的元素
</span><span class="c1"></span>    <span class="c1">//用lambda做一元谓词比较元素和变量
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">wc</span><span class="o">=</span><span class="n">find_if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                    <span class="p">[</span><span class="n">sz</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;=</span><span class="n">sz</span><span class="p">;});</span>
    <span class="c1">//计算长度&gt;=sz的元素数目
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">count</span><span class="o">=</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="n">wc</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">count</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">count</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">(</span><span class="s">&#34;words&#34;</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="s">&#34;word&#34;</span><span class="p">)</span>
        <span class="o">&lt;&lt;</span><span class="s">&#34; of length &#34;</span><span class="o">&lt;&lt;</span><span class="n">sz</span><span class="o">&lt;&lt;</span><span class="s">&#34; or longer&#34;</span>
        <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">//打印长度&gt;=sz的元素，每个元素后接一个空格
</span><span class="c1"></span>    <span class="c1">//用lambda遍历元素
</span><span class="c1"></span>    <span class="n">for_each</span><span class="p">(</span><span class="n">wc</span><span class="p">,</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
             <span class="p">[](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;});</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="lambda捕获和返回">lambda捕获和返回</h3>
<ul>
<li><code>lambda实际是匿名类</code>：定义lambda时，编译器生成一个与其对应的未命名的类类型</li>
<li>向函数传递lambda时，同时定义了一个新类型和该类型的一个对象，传递的参数就是该对象。用auto定义一个lambda初始化的变量时，该变量也是这种对象。</li>
<li>从lambda生成的类都有一个数据成员对应捕获到的变量。lambda的数据成员在创建时被初始化，即<code>被捕获的变量用于初始化lambda匿名对象的成员</code></li>
<li>lambda捕获变量的方式可用<code>值捕获</code>和<code>引用捕获</code></li>
<li><code>值捕获</code>存在拷贝，且值捕获的变量是在lambda创建（lambda对象构造）时被拷贝，而不是调用时拷贝，故创建lambda后修改捕获变量不影响lambda中的值。</li>
<li>使用<code>引用捕获</code>时必须确保lambda执行时被捕获变量存在。例如，从函数中返回lambda时不可用引用捕获。</li>
<li>最佳实践：尽量减少捕获的变量，且避免捕获指针/引用</li>
<li>例子：值捕获的变量会被拷贝，引用捕获的变量不会</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">fcn1</span><span class="p">(){</span>
    <span class="n">size_t</span> <span class="n">v</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">f1</span><span class="o">=</span><span class="p">[</span><span class="n">v</span><span class="p">]{</span><span class="k">return</span> <span class="n">v</span><span class="p">;};</span>     <span class="c1">//值捕获，创建lambda（构造lambda对象）
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">f2</span><span class="o">=</span><span class="p">[</span><span class="o">&amp;</span><span class="n">v</span><span class="p">]{</span><span class="k">return</span> <span class="n">v</span><span class="p">;};</span>    <span class="c1">//引用捕获，创建lambda（构造lambda对象）
</span><span class="c1"></span>    <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>                        <span class="c1">//改变捕获变量的值
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">j1</span><span class="o">=</span><span class="n">f1</span><span class="p">();</span>               <span class="c1">//j1是42，因为lambda创建时保存了捕获变量的拷贝
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">j2</span><span class="o">=</span><span class="n">f2</span><span class="p">();</span>               <span class="c1">//j2是0，因为lambda创建时未拷贝捕获变量，只是建立了引用
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>隐式捕获</code>：可让编译器根据lambda函数体中的代码来推断要捕获哪些变量。</li>
<li>使用隐式捕获，需在捕获列表中写<code>&amp;</code>或<code>=</code>，分别对应引用捕获和值捕获</li>
<li>可混合使用隐式捕获和显式捕获，只需在捕获列表中写<code>&amp;</code>或<code>=</code>，再写显式捕获的变量，要求：
<ul>
<li>捕获列表第一个元素必须是<code>&amp;</code>或<code>=</code>，指定默认为引用/值捕获</li>
<li>显式捕获的变量必须使用与隐式捕获不同的方式。即隐式引用捕获，则显式必须为值捕获，反之亦然</li>
</ul>
</li>
<li>例子：混合使用隐式捕获和显式捕获</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">print_strings</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">strin</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">,</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="o">=</span><span class="n">cout</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="o">=</span><span class="sc">&#39; &#39;</span><span class="p">){</span>
    <span class="c1">//c为显式值捕获，其他变量（os）为隐式引用捕获
</span><span class="c1"></span>    <span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
             <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span><span class="n">c</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span><span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">;});</span>
    <span class="c1">//os为显式引用捕获，其他变量（c）为隐式值捕获，等价于上一行
</span><span class="c1"></span>    <span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
             <span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="o">&amp;</span><span class="n">os</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span><span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">;});</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>表10.1是lambda捕获列表可能的状态
<img src="../cpp_figs/CPPprimer_ch10-tab_10_1.png" alt="tab_10_1"></li>
<li><code>可变lambda</code>：<code>普通lambda不会改变值捕获的变量的copy的值</code>，但可变lambda可改变值捕获的变量的copy的值，只需在参数列表后使用关键字<code>mutable</code></li>
<li>例子：可变lambda</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">fcn3</span><span class="p">(){</span>
    <span class="n">size_t</span> <span class="n">v</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">f</span><span class="o">=</span><span class="p">[</span><span class="n">v</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span><span class="k">return</span> <span class="o">++</span><span class="n">v</span><span class="p">;}</span>  <span class="c1">//mutalbe，允许改变捕获到的copy的值
</span><span class="c1"></span>    <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">j</span><span class="o">=</span><span class="n">f</span><span class="p">();</span>                         <span class="c1">//j是43
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>若lambda函数体包含return之外的任何语句，则编译器推断它返回void，返回void的函数不能返回值，除非手动指定返回类型</li>
<li>为lambda指定返回类型时，必须使用<code>尾置返回</code></li>
<li><code>transform</code>算法：
<ul>
<li>作用：对输入范围的每个元素调用可调用对象，将返回值依次写入目标序列</li>
<li>用法：有4个参数，前2个是输入范围，第3个是目的序列的首迭代器，第4个是可调用对象</li>
</ul>
</li>
<li>transform写入的目标序列和输入序列可以相同，即可以向原址写入</li>
<li>transform和for_each的区别：
<ul>
<li>transform可进行非原址写，for_each不可（除非在可调用对象内写非原址目标）</li>
<li>transform通过可调用对象的返回值写入，for_each在可调用对象内部操作</li>
</ul>
</li>
<li>例子：lambda的返回值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="n">transform</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
          <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span> <span class="k">else</span> <span class="k">return</span> <span class="n">i</span><span class="p">;});</span> <span class="c1">//取绝对值
</span></code></pre></td></tr></table>
</div>
</div><h3 id="参数绑定">参数绑定</h3>
<ul>
<li>对于少数地方使用的简单操作用lambda，而多次调用时应该定义函数。</li>
<li>若lambda的捕获列表为空，可用函数替换它。但对于有捕获列表的lambda，很难用函数替换。因为不能在函数中定义函数，导致不能在不修改形参的前提下使用局部变量（例如标准库算法中的可调用对象，其形参必须固定）。</li>
<li>在<code>functional</code>头文件中定义了<code>bind</code>函数，可看作通用的函数适配器。它接受一个可调用对象，生成新的可调用对象来适应原对象的参数列表（即改变可调用对象的调用接口）</li>
<li>调用bind的形式为：
<code>auto newCallable=bind(callable,arg_list);</code>
<ul>
<li>callable是可调用对象，arg_list是逗号分隔的参数列表，对应callable的参数</li>
<li>调用newCallable时，是在用arg_list的参数调用callable</li>
<li>arg_list中的参数可包含占位符，即<code>_n</code>，其中<code>n</code>是传入newCallable的第n个参数</li>
</ul>
</li>
<li>名字<code>_n</code>都定义于<code>placeholders</code>命名空间中，该命名空间又定义于<code>std</code>命名空间。同时，placeholders命名空间定义于<code>functional</code>头文件</li>
<li>使用<code>using namespace namespace_name</code>来说明希望所有来自namespace_name的名字都可在程序中直接使用</li>
<li>例子：使用bind</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span> <span class="n">g</span><span class="o">=</span><span class="n">bind</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">_2</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">_1</span><span class="p">);</span> <span class="c1">//对g的定义，abc类似于lambda的捕获列表
</span><span class="c1"></span><span class="n">g</span><span class="p">(</span><span class="n">_1</span><span class="p">,</span><span class="n">_2</span><span class="p">);</span>                   <span class="c1">//调用g
</span><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">_2</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">_1</span><span class="p">);</span>             <span class="c1">//等价于调用f
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>默认下，bind的非占位符参数被<code>拷贝</code>到可调用对象中，类似lambda中的<code>值捕获</code></li>
<li>用<code>ref</code>函数可实现lambda中的<code>引用捕获</code></li>
<li><code>ref</code>函数返回一个对象，该对象中包含输入的引用，且可拷贝。若需要包含const引用，则应用<code>cref</code>函数。ref和cref也定义于<code>functional</code>头文件中</li>
<li>例子：用bind和ref捕获引用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* 上下文：os是局部变量，引用输出流；c是局部变量，类型为char */</span>
<span class="c1">//lambda实现，引用捕获输出流，值捕获字符
</span><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
         <span class="p">[</span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="n">c</span><span class="p">](</span><span class="n">cons</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span><span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">;});</span>
<span class="c1">//函数实现，要被标准库算法使用，需要用bind捕获os和c
</span><span class="c1"></span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//错，os不可拷贝，不能用默认方式bind
</span><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
         <span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span><span class="n">os</span><span class="p">,</span><span class="n">_1</span><span class="p">,</span><span class="sc">&#39; &#39;</span><span class="p">));</span>
<span class="c1">//对，用ref返回的对象包含os引用且可拷贝
</span><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
         <span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span><span class="n">ref</span><span class="p">(</span><span class="n">os</span><span class="p">),</span><span class="n">_1</span><span class="p">,</span><span class="sc">&#39; &#39;</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>在C++11之前，标准库定义了<code>bind1st</code>和<code>bind2nd</code>来绑定第一个或第二个参数。由于局限性太强，在C++11中被deprecated</li>
</ul>
<h2 id="再探迭代器">再探迭代器</h2>
<ul>
<li><code>iterator</code>头文件中定义了额外的迭代器：
<ul>
<li><code>插入迭代器</code>：被绑定到一个容器，赋值时向容器中插入元素</li>
<li><code>流迭代器</code>：绑定到输入输出流，用于遍历这个流</li>
<li><code>反向迭代器</code>：向后而不是向前移动，除forward_list外的所有标准库容器都有反向迭代器</li>
<li><code>移动迭代器</code>：不是拷贝元素，而是移动元素</li>
</ul>
</li>
</ul>
<h3 id="插入迭代器">插入迭代器</h3>
<ul>
<li><code>插入器</code>是一种<code>迭代器适配器</code>，它接受一个容器，生成一个迭代器，可通过该迭代器向容器添加元素。</li>
<li>通过插入迭代器赋值时，该迭代器调用对应的容器操作来向给定位置插入元素</li>
<li>插入迭代器支持的操作见表10.2
<img src="../cpp_figs/CPPprimer_ch10-tab_10_2.png" alt="tab_10_2"></li>
<li>有3种插入迭代器，区别在于插入的位置：
<ul>
<li><code>back_inserter</code>函数：创建一个使用<code>push_back</code>的迭代器。</li>
<li><code>front_inserter</code>函数：创建一个使用<code>push_front</code>的迭代器。</li>
<li><code>inserter</code>函数：创建一个使用<code>insert</code>的迭代器。它接受迭代器作为第二个参数来指定位置。使用返回的迭代器时，插入的元素在指定位置之前</li>
</ul>
</li>
<li>只有容器本身支持push_back/pus*h_front/insert，才可用back_inserter/front_inserter/inserter</li>
<li>inserter等价于两步操作：先<code>insert</code>后<code>++</code>：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">inserter</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">iter</span><span class="p">);</span>   <span class="c1">//iter是it的初始位置
</span><span class="c1"></span><span class="o">*</span><span class="n">it</span><span class="o">=</span><span class="n">val</span><span class="p">;</span>
<span class="c1">//上一行等价于下两行
</span><span class="c1"></span><span class="n">it</span><span class="o">=</span><span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>        <span class="c1">//先在it前插入，之后it指向插入元素。
</span><span class="c1"></span><span class="o">++</span><span class="n">it</span><span class="p">;</span>                       <span class="c1">//再递增it，使其与给定位置iter一致。
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>反复调用front_inserter插入元素的顺序与插入顺序相反，而back_inserter/inserter插入元素的顺序与插入顺序相同</li>
<li>插入迭代器的<code>*</code>和<code>++</code>算符不会对迭代器做任何事。</li>
</ul>
<h3 id="iostream迭代器">iostream迭代器</h3>
<ul>
<li>iostream类型不是容器，但也可用迭代器操作：
<ul>
<li><code>istream_iterator</code>：读输入流</li>
<li><code>ostream_iterator</code>：写输出流</li>
</ul>
</li>
<li>创建流迭代器时需在模板参数中指定读写类型，使用时调用该类型的<code>&lt;&lt;</code>、<code>&gt;&gt;</code>算符。流迭代器将其对应的流当作该类型的元素序列处理</li>
<li>创建istream_iterator时，可将其绑定到一个流。也可默认初始化为<code>尾后迭代器</code>。</li>
<li>对于绑定到流的迭代器，一旦关联的流遇到文件末尾或IO错误，则迭代器等于尾后迭代器</li>
<li>例子：使用istream_iterator</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in_iter</span><span class="p">(</span><span class="n">cin</span><span class="p">),</span> <span class="n">eof</span><span class="p">;</span>    <span class="c1">//in_iter绑定到cin，eof作为输入流的尾后迭代器
</span><span class="c1">//法1：先创建vector再依次读取数据、插入
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">in_iter</span><span class="o">!=</span><span class="n">eof</span><span class="p">)</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">in_iter</span><span class="o">++</span><span class="p">);</span>              <span class="c1">//用迭代器从cin中读数据
</span><span class="c1">//法2：直接用输入流迭代器创建vector
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">in_iter</span><span class="p">,</span><span class="n">eof</span><span class="p">);</span>               <span class="c1">//等价于上面3行
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>标准库只保证在第一次解引用输入流迭代器之前完成从流中读数据的操作，而不一定在绑定时立即读取。如果从两个不同对象同步地读取一个流，或是创建流迭代器还未使用就销毁，则何时读取是重要的。</li>
<li>istream_iterator的操作见表10.3
<img src="../cpp_figs/CPPprimer_ch10-tab_10_3.png" alt="tab_10_3"></li>
<li>例子：用算法操作流迭代器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">(</span><span class="n">cin</span><span class="p">),</span> <span class="n">eof</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">accumulate</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="n">eof</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>   <span class="c1">//将输入序列读为int并累加输出
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>创建ostream_iterator时有可选的第二个参数，必须是C风格字符串，在输出每个元素之后都输出该字符串。</li>
<li>ostream_iterator创建时必须绑定到流，不允许默认初始化</li>
<li>ostream_iterator的<code>*</code>和<code>++</code>算符不会对迭代器做任何事，因为输出操作自动递增。</li>
<li>ostream_iterator的操作见表10.4
<img src="../cpp_figs/CPPprimer_ch10-tab_10_4.png" alt="tab_10_4"></li>
<li>例子：使用ostream_iterator</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">out_iter</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span><span class="s">&#34; &#34;</span><span class="p">);</span>
<span class="c1">//法1：显式写出解引用和递增
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span><span class="p">:</span><span class="n">vec</span><span class="p">)</span>
    <span class="o">*</span><span class="n">out_iter</span><span class="o">++=</span><span class="n">e</span><span class="p">;</span>
<span class="c1">//法2：流自动解引用和递增
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span><span class="p">:</span><span class="n">vec</span><span class="p">)</span>
    <span class="n">out_iter</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
<span class="c1">//法3：直接向流中拷贝
</span><span class="c1"></span><span class="n">copy</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">out_iter</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="反向迭代器">反向迭代器</h3>
<ul>
<li><code>反向迭代器</code>：在容器中从尾元素向首前元素移动，<code>++</code>向后移动，<code>--</code>向前移动</li>
<li>除forward_list外的容器都有反向迭代器。可通过<code>rbgein</code>、<code>crbegin</code>、<code>rend</code>、<code>crend</code>函数来得到指向首前元素和尾元素的迭代器，如图10.1
![fig_10_1][fig_10_1_fig]</li>
<li>反向迭代器的作用是让算法透明地向前或向后处理容器，例如向sort传递反向迭代器可反向排序而不需修改算法或算符</li>
<li>例子：用反向迭代器做反向排序</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>    <span class="c1">//递增序
</span><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span>  <span class="c1">//递减序
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>反向迭代器只能从同时支持<code>++</code>和<code>--</code>的迭代器来产生。故<code>forward_list</code>和<code>流迭代器</code>都无反向迭代器</li>
<li>反向迭代器的<code>base</code>成员函数返回它对应的正向迭代器。特别的，rbegin对应的正向迭代器是end，rend对应的正向迭代器是begin</li>
<li>反向迭代器比它对应的正向迭代器左偏一个位置，原因是左闭右开区间的特性。为了使<code>[rit1,rit2)</code>和<code>[rit1.base(),rit2.base())</code>表示的元素范围相同</li>
<li>从正向迭代器初始化反向迭代器，或是给反向迭代器赋值时，结果迭代器与原迭代器指向的元素不相同。</li>
<li>例子：使用反向迭代器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">string</span> <span class="n">line</span><span class="o">=</span><span class="s">&#34;FIRST,MIDDLE,LAST&#34;</span><span class="p">;</span>
<span class="c1">//检测第一个&#39;,&#39;并打印
</span><span class="c1"></span><span class="k">auto</span> <span class="n">comma</span><span class="o">=</span><span class="n">find</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">line</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span><span class="sc">&#39;,&#39;</span><span class="p">);</span>     <span class="c1">//检测第一个`,`
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">string</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">comma</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>            <span class="c1">//打印&#34;FIRST&#34;
</span><span class="c1">//检测最后一个&#39;,&#39;并打印
</span><span class="c1"></span><span class="k">auto</span> <span class="n">rcomma</span><span class="o">=</span><span class="n">find</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">crbegin</span><span class="p">(),</span><span class="n">line</span><span class="p">.</span><span class="n">crend</span><span class="p">(),</span><span class="sc">&#39;,&#39;</span><span class="p">);</span>  <span class="c1">//检测最后一个`,`，只需修改迭代器类型，不需修改算法
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">string</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">crbegin</span><span class="p">(),</span><span class="n">rcomma</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>          <span class="c1">//打印&#34;TSAL&#34;
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">string</span><span class="p">(</span><span class="n">rcomma</span><span class="p">.</span><span class="n">base</span><span class="p">(),</span><span class="n">line</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>      <span class="c1">//打印&#34;LAST&#34;
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>上例中<code>[line.crbegin(),rcomma)</code>和<code>[rcomma.base(),line.cend())</code>表示的范围相同，只是方向相反，如图10.2
![fig_10_2][fig_10_2_fig]</li>
</ul>
<h2 id="泛型算法结构">泛型算法结构</h2>
<ul>
<li>算法最基本的特性是要求迭代器可提供哪些操作（即可使用何种迭代器），这可分为5个迭代器类别，每个算法都会指明需要的迭代器至少是哪一种</li>
<li>表10.5是迭代器的5种类别
<img src="../cpp_figs/CPPprimer_ch10-tab_10_5.png" alt="tab_10_5"></li>
<li>另一种算法的分类方式是按照读/写/重排元素来分类</li>
<li>算法共享一组形参规范和一组命名规范</li>
</ul>
<h3 id="5类迭代器">5类迭代器</h3>
<ul>
<li>迭代器按照支持的操作来分类，形成一种层次。</li>
<li>C++标准指明每种算法需要的迭代器的最小类别（即至少要支持的操作）。但对算法传递错误的迭代器经常不会被编译器警告</li>
<li><code>输入迭代器</code>
<ul>
<li>操作：只可读不可写</li>
<li>算符：<code>==</code>、<code>!=</code>、<code>++</code>、<code>*</code>、<code>-&gt;</code></li>
<li>访问：只能顺序访问，不保证迭代器的状态有效并再次访问元素。故只能单遍扫描</li>
<li>例子：find和accumulate要求输入迭代器，isrteam_iterator是输入迭代器</li>
</ul>
</li>
<li><code>输出迭代器</code>
<ul>
<li>操作：只可写不可读</li>
<li>算符：<code>++</code>、<code>*</code></li>
<li>访问：只能赋值一次，即只能单遍扫描</li>
<li>例子：用作目的位置的迭代器通常是输出迭代器，如copy的第三个参数，osrteam_iterator</li>
</ul>
</li>
<li><code>前向迭代器</code>
<ul>
<li>操作：可多次读写元素</li>
<li>算符：<code>==</code>、<code>!=</code>、<code>++</code>、<code>*</code>、<code>-&gt;</code></li>
<li>访问：可多次读写元素，可保存迭代器状态，可对序列多次扫描</li>
<li>例子：replace要求前向迭代器，forward_list的迭代器是前向迭代器</li>
</ul>
</li>
<li><code>双向迭代器</code>
<ul>
<li>操作：可正反方向多次读写元素</li>
<li>算符：<code>==</code>、<code>!=</code>、<code>++</code>、<code>--</code>、<code>*</code>、<code>-&gt;</code></li>
<li>访问：可多次读写元素，可保存迭代器状态，可对序列多次扫描</li>
<li>例子：reverse要求双向迭代器，除forward_list外的容器迭代器都是双向迭代器</li>
</ul>
</li>
<li><code>随机访问迭代器</code>
<ul>
<li>操作：常量时间内随机读写任意元素</li>
<li>算符：<code>==</code>、<code>!=</code>、<code>++</code>、<code>--</code>、<code>*</code>、<code>-&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>+</code>、<code>+=</code>、<code>-</code>、<code>-=</code>、<code>[]</code></li>
<li>访问：可多次读写元素，可保存迭代器状态，可对序列多次扫描</li>
<li>例子：sort要求随机访问迭代器，array/deque/string/vector的迭代器、数组的指针都是随机访问迭代器</li>
</ul>
</li>
</ul>
<h3 id="算法形参模式">算法形参模式</h3>
<ul>
<li>大多数算法的形参具有下列4种形式之一：
<ul>
<li><code>alg(beg,end,others);</code></li>
<li><code>alg(beg,end,dest,other);</code></li>
<li><code>alg(beg,end,beg2,other);</code></li>
<li><code>alg(beg,end,beg2,end2,other);</code></li>
</ul>
</li>
<li>参数：
<ul>
<li>beg和end表示操作的输入范围</li>
<li>dest是算法可写入目的位置的迭代器，假定写入任意多个元素都安全。因此dest经常被绑定到插入迭代器或输出流迭代器</li>
<li>beg2表示操作的第二个输入范围，假定从beg2开始的序列至少和beg到end的长度一样长</li>
<li>beg2和end2表示操作的第二个输入范围，对这种指定没有限制</li>
</ul>
</li>
</ul>
<h3 id="算法命名规范">算法命名规范</h3>
<ul>
<li>接受谓词的算法和不接受额外参数的算法通常被重载，不需另外命名</li>
<li><code>_if</code>版本：接受一个谓词代替给定元素值</li>
<li>例子：_if版本算法</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">find</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>      <span class="c1">//接受元素值，查找第一个等于val的元素
</span><span class="c1"></span><span class="n">find_if</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">pred</span><span class="p">);</span>  <span class="c1">//接受谓词，查找第一个使谓词为真的元素
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>_copy</code>版本：输出到目标位置，而不是原址</li>
<li>例子：_copy版本算法</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">reverse</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span><span class="n">end</span><span class="p">);</span>           <span class="c1">//逆序写入原址
</span><span class="c1"></span><span class="n">reverse_copy</span><span class="p">(</span><span class="n">bed</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">dest</span><span class="p">);</span> <span class="c1">//逆序拷贝到dest
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>同时_if和_copy</li>
<li>例子：同时_if和_copy</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//从v1中移除奇数
</span><span class="c1"></span><span class="n">remove_if</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
          <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">;});</span>
<span class="c1">//将v1中移除奇数后剩下的拷贝到v2，v1不变
</span><span class="c1"></span><span class="n">remove_copy_if</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">v2</span><span class="p">),</span>
               <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">;});</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="特定容器算法">特定容器算法</h2>
<ul>
<li>链表类型<code>list</code>和<code>forward_list</code>定义了成员函数形式的算法，如<code>sort</code>、<code>merge</code>、<code>remove</code>、<code>reverse</code>、<code>unuque</code>。
<ul>
<li>通用sort要求随机访问，不可用于链表</li>
<li>其他算法的通用版本可用于链表，但交换元素代价太高。链表可交换指针而不是交换元素，可提高性能。</li>
</ul>
</li>
<li>对于链表类型list和forward_list，应优先使用成员函数版本的算法</li>
<li>表10.6是链表的成员函数版本的算法
<img src="../cpp_figs/CPPprimer_ch10-tab_10_6.png" alt="tab_10_6"></li>
<li>链表类型特有的算法有<code>splice</code>，用于拼接链表，该算法没有通用版本</li>
<li>表10.7是链表splice的形参
<img src="../cpp_figs/CPPprimer_ch10-tab_10_7.png" alt="tab_10_7"></li>
<li>链表特有算法与通用算法的一个区别是：链表特有的算法会改变底层容器，通用算法不会</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">canpi</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-02-25
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_wechat.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_alipay.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          <a href="/tags/c&#43;&#43;-primer/">C&#43;&#43; primer</a>
          <a href="/tags/%E8%AF%BB%E4%B9%A6/">读书</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cpp/cppprimer_ch11/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43; primer 第11章 关联容器</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/cpp/cppprimer_ch9/">
            <span class="next-text nav-default">C&#43;&#43; primer 第9章 顺序容器</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/cpp/cppprimer_ch10/" class="leancloud_visitors" data-flag-title="C&#43;&#43; primer 第10章 泛型算法">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'ntftaTIdLaT8sVPL9qFX5dAg-gzGzoHsz',
        appKey: 'lNOKznaI2Gnej5D2MgpUJnzV',
        notify:  false ,
        verify:  false ,
        avatar:'retro',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hucanpei@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/hucanpei" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/canpi" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">canpi</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>








</body>
</html>
