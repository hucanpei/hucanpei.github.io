<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>趣谈Linux操作系统6-9：架构、启动、初始化、系统调用 - pi</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="canpi" /><meta name="description" content="06-x86架构：有了开放的架构，才能打造开放的营商环境 x86是一个统一、开放的架构，保证系统运行的硬件环境单一稳定 计算机的工作模式是什么样" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.74.3 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/os/linux_interest_6-9/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.651e6917abb0239242daa570c2bec9867267bbcd83646da5a850afe573347b44.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="趣谈Linux操作系统6-9：架构、启动、初始化、系统调用" />
<meta property="og:description" content="06-x86架构：有了开放的架构，才能打造开放的营商环境 x86是一个统一、开放的架构，保证系统运行的硬件环境单一稳定 计算机的工作模式是什么样" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/os/linux_interest_6-9/" />
<meta property="article:published_time" content="2020-03-24T23:17:00+08:00" />
<meta property="article:modified_time" content="2020-03-24T23:17:00+08:00" />
<meta itemprop="name" content="趣谈Linux操作系统6-9：架构、启动、初始化、系统调用">
<meta itemprop="description" content="06-x86架构：有了开放的架构，才能打造开放的营商环境 x86是一个统一、开放的架构，保证系统运行的硬件环境单一稳定 计算机的工作模式是什么样">
<meta itemprop="datePublished" content="2020-03-24T23:17:00+08:00" />
<meta itemprop="dateModified" content="2020-03-24T23:17:00+08:00" />
<meta itemprop="wordCount" content="10075">



<meta itemprop="keywords" content="Linux,操作系统,趣谈Linux操作系统,极客时间专栏," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="趣谈Linux操作系统6-9：架构、启动、初始化、系统调用"/>
<meta name="twitter:description" content="06-x86架构：有了开放的架构，才能打造开放的营商环境 x86是一个统一、开放的架构，保证系统运行的硬件环境单一稳定 计算机的工作模式是什么样"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">canpi</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">canpi</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">趣谈Linux操作系统6-9：架构、启动、初始化、系统调用</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-03-24 </span>
        
          <span class="more-meta"> 约 10075 字 </span>
          <span class="more-meta"> 预计阅读 21 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#06-x86架构有了开放的架构才能打造开放的营商环境">06-x86架构：有了开放的架构，才能打造开放的营商环境</a>
      <ul>
        <li><a href="#计算机的工作模式是什么样的">计算机的工作模式是什么样的？</a></li>
        <li><a href="#x86成为开放平台历史中的重要一笔">x86成为开放平台历史中的重要一笔</a></li>
        <li><a href="#从8086的原理说起">从8086的原理说起</a></li>
        <li><a href="#再来说32位处理器">再来说32位处理器</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#07-从bios到bootloader创业伊始有活儿老板自己上">07-从BIOS到bootloader：创业伊始，有活儿老板自己上</a>
      <ul>
        <li><a href="#bios时期">BIOS时期</a></li>
        <li><a href="#bootloader时期">bootloader时期</a></li>
        <li><a href="#从实模式切换到保护模式">从实模式切换到保护模式</a></li>
        <li><a href="#总结-1">总结</a></li>
      </ul>
    </li>
    <li><a href="#08-内核初始化生意做大了就得成立公司">08-内核初始化：生意做大了就得成立公司</a>
      <ul>
        <li><a href="#初始化公司职能部门">初始化公司职能部门</a></li>
        <li><a href="#初始化1号进程">初始化1号进程</a></li>
        <li><a href="#从内核态到用户态">从内核态到用户态</a></li>
        <li><a href="#ramdisk的作用">ramdisk的作用</a></li>
        <li><a href="#创建2号进程">创建2号进程</a></li>
        <li><a href="#总结-2">总结</a></li>
      </ul>
    </li>
    <li><a href="#09-系统调用公司成立好了就要开始接项目">09-系统调用：公司成立好了就要开始接项目</a>
      <ul>
        <li><a href="#glibc对系统调用的封装">glibc对系统调用的封装</a></li>
        <li><a href="#32位系统调用过程">32位系统调用过程</a></li>
        <li><a href="#64位系统调用过程">64位系统调用过程</a></li>
        <li><a href="#系统调用表">系统调用表</a></li>
        <li><a href="#总结-3">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="06-x86架构有了开放的架构才能打造开放的营商环境">06-x86架构：有了开放的架构，才能打造开放的营商环境</h2>
<ul>
<li>x86是一个统一、开放的架构，保证系统运行的硬件环境单一稳定</li>
</ul>
<h3 id="计算机的工作模式是什么样的">计算机的工作模式是什么样的？</h3>
<ul>
<li>如下图是计算机的结构
<img src="../os_figs/Linux_interest_6_1.jpeg" alt="计算机结构"></li>
<li><code>cpu</code>是最核心的计算设备，<code>总线</code>是cpu和其他设备之间的高速通道，<code>内存</code>用于存放中间结果</li>
<li>cpu分为3部分：运算单元、数据单元、控制单元：
<ul>
<li><code>运算单元</code>只负责计算。它不知道算哪些数据，也不知道结果放在哪</li>
<li><code>数据单元</code>包括寄存器组和cache，空间很小但很快。用于存放中间结果（寄存器、cache、内存、硬盘、云存储，它们构成存储的层次性）</li>
<li><code>控制单元</code>指导运算单元取出数据单元中的数据，计算出结果并放入数据单元。</li>
</ul>
</li>
<li>如下图是cpu和存储设备之间的数据流向
<img src="../os_figs/Linux_interest_6_2.jpeg" alt="cpu和存储设备间的数据流"></li>
<li>cpu执行程序的过程：
<ul>
<li>每个进程的程序都是存储于硬盘的<code>二进制文件</code>，进程将其加载到自己的独立进程空间中形成<code>代码段</code>。</li>
<li>cpu的控制单元有一个<code>指令指针寄存器</code>，它里面存放的是下一条指令在内存中的地址，控制单元从代码段中取指令，放入<code>指令寄存器</code>。</li>
<li>指令分两部分：一部分指明做什么操作（交给运算单元），另一部分指明操作哪些数据（交给数据单元）</li>
<li>数据单元根据数据的地址，从<code>数据段</code>中读数据到<code>数据寄存器</code>。运算单元进行运算，产生的结果暂存在数据单元的数据寄存器，最终会有指令将其写回内存的数据段</li>
</ul>
</li>
<li><code>进程切换</code>：cpu有两个寄存器，分别保存当前进程代码段和数据段的起始地址。切换到另一个进程时更新这两个寄存器</li>
<li>总线：
<ul>
<li><code>地址总线</code>传输地址，在内存中索引。地址总线宽度决定能寻址的范围</li>
<li><code>数据总线</code>传输数据。数据总线的宽度决定一次能传多少数据</li>
</ul>
</li>
</ul>
<h3 id="x86成为开放平台历史中的重要一笔">x86成为开放平台历史中的重要一笔</h3>
<ul>
<li>硬件架构的标准：开放、统一、兼容</li>
<li>如下图是x86的发展历程，x86的开端是8086，故叫x86
<img src="../os_figs/Linux_interest_6_3.jpeg" alt="x86的发展历程"></li>
</ul>
<h3 id="从8086的原理说起">从8086的原理说起</h3>
<ul>
<li>8086是x86中最经典的处理器，已经很老了，但现代操作系统的很多特性都和它有关，且一直保持兼容</li>
<li>如下图是8086的组件
<img src="../os_figs/Linux_interest_6_4.jpeg" alt="8086的组件"></li>
<li>数据单元：
<ul>
<li>处理器内部有8个16位<code>通用寄存器</code>，分别是AX、BX、CX、DX、SP、BP、SI、DI</li>
<li>AX、BX、CX、DX可分成两个8位寄存器，分别是AH、AL、BH、BL、CH、CL、DH、DL</li>
</ul>
</li>
<li>控制单元：
<ul>
<li>IP(Instruction Pointer)是<code>指令指针寄存器</code>，指向代码段中下一条指令的位置（下一条指令在代码段中的<code>偏移量</code>）。CPU会根据它来将指令从内存的代码段中加载到CPU的指令队列中，然后交给运算单元去执行</li>
<li>CS(Code Segment)是<code>代码段寄存器</code>，存放代码段的起始地址</li>
<li>DS(Data Segment)是<code>数据段寄存器</code>，存放数据段的起始地址</li>
<li>SS(Stack Register)是<code>堆栈段寄存器</code></li>
<li>ES(Extra Segment)是<code>附加段寄存器</code></li>
</ul>
</li>
<li>凡是与函数调用相关的操作都和栈紧密相关。</li>
<li>如下图是函数调用栈的例子：从左到右是栈随程序执行的变化。A调用B，B调用C。调用B时把A运行的相关信息压入栈中，调用C时把B运行的相关信息压入栈中。C执行完将B弹出继续执行，B执行完将A弹出继续执行
<img src="../os_figs/Linux_interest_6_5.jpeg" alt="函数调用栈"></li>
<li>从内存中加载指令和数据：
<ul>
<li>代码段起始地址保存在CS中，代码段偏移量保存在IP中</li>
<li>数据段起始地址保存在DS中，数据段偏移量保存在通用寄存器中</li>
</ul>
</li>
<li>8086的寄存器是16位，但地址是20位（为增大寻址范围）。为了利用20位地址总线，使用<code>起始地址*16+偏移量</code>的计算方法（如上图的<code>地址加法器</code>，*16即是左移4位，刚好用到最高位）</li>
<li>20位地址总线的最大寻址范围：1M</li>
<li>16位偏移量的范围（即段的最大值）：64k</li>
</ul>
<h3 id="再来说32位处理器">再来说32位处理器</h3>
<ul>
<li>32位地址总线的最大寻址范围：4G，但必须保证对8086的兼容</li>
<li>通用寄存器保持兼容：通用寄存器被扩展到32位，但低16位和低8位的命名与8086保持一致。只是整个32位寄存器的名字在原理6位寄存器的名字前加上E(extend)</li>
<li>段寄存器（CS、DS、SS、ES）不完全兼容：若段寄存器和地址线都是32位，则不需要偏移再相加。</li>
<li>对段寄存器重新定义：32位机中段寄存器仍是16位，但不再保存段的起始地址。段的起始地址放在内存中，是一个表格（<code>段表</code>）。表格中的每一项是<code>段描述符</code>，这里才是真正的段起始地址。而段寄存器里面保存的是在这个表格中的哪一项，称为<code>选择子</code>。寻址的过程变为：从段寄存器中取索引，在段表中根据索引取出段的起始地址</li>
<li>如下图是32位机的通用寄存器和段寄存器
<img src="../os_figs/Linux_interest_6_6.jpeg" alt="32位机的通用寄存器和段寄存器"></li>
<li>实模式和保护模式：
<ul>
<li><code>实模式</code>：兼容16位机，从段寄存器中直接取段起始地址（只能寻址1M，每个段最多64K）</li>
<li><code>保护模式</code>：不兼容16位机，从段寄存器中查找段表索引，再从段表中取段起始地址（可用到32位机完整的寻址能力）</li>
<li>系统刚启动时，cpu处于实模式。需要更多内存时可切换到保护模式。</li>
<li>32位机和16位机不能无缝兼容，但可切换模式来兼容</li>
</ul>
</li>
</ul>
<h3 id="总结">总结</h3>
<ul>
<li>如下图是32位机的整体架构
<img src="../os_figs/Linux_interest_6_7.jpeg" alt="32位机的整体架构"></li>
</ul>
<h2 id="07-从bios到bootloader创业伊始有活儿老板自己上">07-从BIOS到bootloader：创业伊始，有活儿老板自己上</h2>
<h3 id="bios时期">BIOS时期</h3>
<ul>
<li><code>BIOS</code>是一块<code>ROM</code>，掉电不会丢失。而内存是RAM，掉电会被擦除。</li>
<li>主板上电时没有操作系统，内存也是空白，从BIOS中读取程序。
<img src="../os_figs/Linux_interest_7_1.jpeg" alt="BIOS的作用"></li>
<li>刚开机时cpu处于实模式，只能寻址1M</li>
<li>如下图是开机处于实模式时的内存分布
<img src="../os_figs/Linux_interest_7_2.jpeg" alt="实模式时的内存分布"></li>
<li>最上面的0xF0000到0xFFFFF这64K映射给ROM</li>
<li>电脑刚上电时会做一些重置工作，将CS设置为0xFFFF，将IP设置为0x0000，所以第一条指令指向0xFFFF0，在ROM中。这里有一条<code>JMP</code>命令跳到ROM中初始化的代码，即让BIOS控制初始化。</li>
<li>BIOS控制初始化：
<ul>
<li>第一阶段检查各硬件是否正常工作</li>
<li>第二阶段建立<code>中断向量表</code>和<code>中断服务程序</code>（为鼠标和键盘控制服务），并向屏幕打印信息</li>
</ul>
</li>
<li>如下图是BIOS初始化阶段提供的服务
<img src="../os_figs/Linux_interest_7_3.jpeg" alt="BIOS初始化阶段提供的服务"></li>
</ul>
<h3 id="bootloader时期">bootloader时期</h3>
<ul>
<li>BIOS完成初始化后，需要寻找操作系统</li>
<li>操作系统一般放在硬盘（启动盘）上，<code>启动盘</code>一般在第一个扇区，占<code>512字节</code>，而且以<code>0xAA55</code>结束。满足这个条件时说明是一个启动盘，在512字节以内会启动相关的代码</li>
<li>Linux中由<code>grub2</code>(Grand Unified Bootloader Version 2)管理启动，可通过<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code>来配置启动选项，里面的代码类似于下面：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-plain" data-lang="plain">menuentry &#39;CentOS Linux (3.10.0-862.el7.x86_64) 7 (Core)&#39; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option &#39;gnulinux-3.10.0-862.el7.x86_64-advanced-b1aceb95-6b9e-464a-a589-bed66220ebee&#39; {
	load_video
	set gfxpayload=keep
	insmod gzio
	insmod part_msdos
	insmod ext2
	set root=&#39;hd0,msdos1&#39;
	if [ x$feature_platform_search_hint = xy ]; then
	  search --no-floppy --fs-uuid --set=root --hint=&#39;hd0,msdos1&#39;  b1aceb95-6b9e-464a-a589-bed66220ebee
	else
	  search --no-floppy --fs-uuid --set=root b1aceb95-6b9e-464a-a589-bed66220ebee
	fi
	linux16 /boot/vmlinuz-3.10.0-862.el7.x86_64 root=UUID=b1aceb95-6b9e-464a-a589-bed66220ebee ro console=tty0 console=ttyS0,115200 crashkernel=auto net.ifnames=0 biosdevname=0 rhgb quiet 
	initrd16 /boot/initramfs-3.10.0-862.el7.x86_64.img
}
</code></pre></td></tr></table>
</div>
</div><ul>
<li>上面的代码对应下图，即在系统启动时成为一个列表，让用户选择从哪个系统启动。
<img src="../os_figs/Linux_interest_7_4.jpeg" alt="grub2界面"></li>
<li>使用<code>grub2-install /dev/sda</code>，可以将启动程序安装到相应的位置</li>
<li>grub2首先安装的是<code>boot.img</code>。它由boot.S编译而成，一共512字节，安装到启动盘的第一个扇区。该扇区通常称为<code>MBR</code>（Master Boot Record，主引导记录/扇区）。</li>
<li>BIOS完成任务后，会将boot.img从硬盘加载到内存中的<code>0x7c00</code>来运行</li>
<li>boot.img做不了太多的事（512字节空间有限），它的最重要的事是加载grub2的另一个镜像<code>core.img</code>，它由<code>lzma_decompress.img</code>、<code>diskboot.img</code>、<code>kernel.img</code>和一系列的模块组成，功能比较丰富，能做很多事情。</li>
<li>如下图是硬盘空间的分布
<img src="../os_figs/Linux_interest_7_5.jpeg" alt="硬盘空间的分布"></li>
<li>boot.img先加载core.img的第一个扇区。如果从硬盘启动，该扇区里面是diskboot.img，对应代码是diskboot.S</li>
<li>diskboot.img得到控制权后，将core.img的其他部分加载进来。首先解压lzma_decompress.img，然后kernel.img（它不是Linux的内核，而是grub的内核），最后各个模块module对应的映像</li>
<li>lzma_decompress.img对应的代码是startup_raw.S，它调用<code>real_to_prot</code>切换到保护模式（随着加载的内容变多，实模式的寻址空间不够用），然后解压缩kernel.img</li>
</ul>
<h3 id="从实模式切换到保护模式">从实模式切换到保护模式</h3>
<ul>
<li>切换到保护模式要干很多工作，大部分工作都与内存的访问方式有关。
<ul>
<li>启用<code>分段</code>：在内存里建立段表，将段寄存器变成段选择子，指向段表中的段描述符。</li>
<li>启动<code>分页</code>：将内存分为等大小的块</li>
</ul>
</li>
<li>切换到保护模式的函数<code>DATA32 call real_to_prot</code>会打开<code>Gate A20</code>，即第21根地址线的控制线</li>
<li>对<code>kernel.img</code>解压缩并运行。它对应的代码是<code>startup.S</code>以及一堆c文件。在startup.S中调用<code>grub_main</code>，这是grub kernel的主函数。</li>
<li>在grub_main中，<code>grub_load_config()</code>开始解析grub.conf文件里的配置信息。</li>
<li>若正常启动，则grub_main最后会调用<code>grub_command_execute (“normal”, 0, 0)</code>，最终会调用<code>grub_normal_execute()</code>函数。在该函数中，<code>grub_show_menu()</code>会显示出可供选择的操作系统列表。</li>
<li>选择操作系统后，调用<code>grub_menu_execute_entry()</code>解析并执行选择的系统</li>
<li>例如上面代码中的linux16命令表示装载指定的内核文件，并传递内核启动参数。于是<code>grub_cmd_linux()</code>函数会被调用，它首先读取Linux内核镜像头部的一些数据结构，放到内存中进行检查。若检查通过，则读取整个Linux内核镜像到内存。</li>
<li>若配置文件中还有<code>initrd</code>命令，用于为即将启动的内核传递<code>init ramdisk</code>路径。于是<code>grub_cmd_initrd()</code>函数会被调用，将<code>initramfs</code>加载到内存中来</li>
<li>上面都做完之后，<code>grub_command_execute (“boot”, 0, 0)</code>才开始真正地启动内核</li>
</ul>
<h3 id="总结-1">总结</h3>
<ul>
<li>如下图是从BIOS到启动linux内核之间的工作
<img src="../os_figs/Linux_interest_7_6.jpeg" alt="从BIOS到启动linux内核"></li>
</ul>
<h2 id="08-内核初始化生意做大了就得成立公司">08-内核初始化：生意做大了就得成立公司</h2>
<ul>
<li>内核的启动入口函数是<code>start_kernel()</code>。在<code>init/main.c</code>文件中，start_kernel相当于内核的main函数。打开这个函数，里面是各种初始化函数XXXX_init。</li>
<li>下图是start_kernel()中的各种初始化
<img src="../os_figs/Linux_interest_8_1.jpeg" alt="start_kernel()中的各种初始化"></li>
</ul>
<h3 id="初始化公司职能部门">初始化公司职能部门</h3>
<ul>
<li><code>INIT_TASK(init_task)</code>：初始化进程
<ul>
<li><code>0号进程</code>：是系统创建的第一个进程，唯一一个没有通过<code>fork</code>或者<code>kernel_thread</code>产生的进程，也是进程列表的第一个。有一行指令set_task_stack_end_magic(&amp;init_task)。其中参数init_task即是零号进程，其定义是struct task_struct init_task=INIT_TASK(init_task)</li>
</ul>
</li>
<li><code>trap_init()</code>：初始化中断
<ul>
<li>初始化中断时设置<code>中断门</code>用于处理中断。其中set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)是系统调用的中断门。</li>
<li><code>系统调用</code>也是通过发送中断的方式实现，但64位有另外的系统调用方法</li>
</ul>
</li>
<li><code>mm_init()</code>：初始化内存管理模块</li>
<li><code>sched_init()</code>：初始化调度模块</li>
<li><code>vfs_caches_init()</code>：初始化基于内存的文件系统rootfs。该函数中调用mnt_init()-&gt;init_rootfs()，有一行register_filesystem(&amp;rootfs_fs_type)，在VFS虚拟文件系统里注册一种类型，定义为struct file_system_type rootfs_fs_type
<ul>
<li><code>VFS</code>（Virtual File System，<code>虚拟文件系统</code>）：为了兼容各种文件系统，需要将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一接口，这个抽象层就是VFS</li>
</ul>
</li>
<li><code>rest_init()</code>：其他方面的初始化</li>
<li>如下图是初始化的各项工作：
<img src="../os_figs/Linux_interest_8_2.jpeg" alt="初始化的各项工作"></li>
</ul>
<h3 id="初始化1号进程">初始化1号进程</h3>
<ul>
<li><code>rest_init()</code>的第一个工作是，用kernel_thread(kernel_init, NULL, CLONE_FS)创建第二个进程，这个是<code>1号进程</code></li>
<li>1号进程对操作系统意义很大。因为它将运行一个用户进程，此时要区分内核态和用户态。（1号进程是所有用户态进程的祖先）</li>
<li>x86提供了分层的权限机制，把区域分成四个<code>Ring</code>，越往里权限越高。</li>
<li>如下图是x86的分层权限机制
<img src="../os_figs/Linux_interest_8_3.jpeg" alt="x86的分层权限机制"></li>
<li>操作系统把能访问关键资源的代码放在<code>Ring0</code>，称为<code>内核态</code>。普通程序代码放在<code>Ring3</code>，称为<code>用户态</code></li>
<li>在保护模式下，用户态代码不可执行更高权限的指令。它们只能通过系统调用来调用内核态的代码来访问核心资源，访问结束后返回用户态代码继续执行。</li>
<li>用户态代码进行系统调用（切换到内核态）时，要把当时CPU寄存器的值全部暂存到内存中。系统调用结束后返回时，从内存中将寄存器的值恢复到cpu（切换到用户态）</li>
<li>如下两图是用户态切换到内核态的过程
<img src="../os_figs/Linux_interest_8_4.jpeg" alt="用户态切换到内核态">
<img src="../os_figs/Linux_interest_8_5.jpeg" alt="用户态切换到内核态"></li>
</ul>
<h3 id="从内核态到用户态">从内核态到用户态</h3>
<ul>
<li>执行kernel_thread函数创建1号进程时，还在内核态</li>
<li>建立1号进程时，<code>kernel_thread</code>的参数是一个函数<code>kernel_init</code>，即该进程会执行这个函数。在kernel_init中又调用<code>kernel_init_freeable()</code></li>
<li>kernel_init_freeable()中有代码：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ramdisk_execute_command</span><span class="p">)</span>
		<span class="n">ramdisk_execute_command</span> <span class="o">=</span> <span class="s">&#34;/init&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>kernel_init()中有代码：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">	<span class="k">if</span> <span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">run_init_process</span><span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">);</span>
<span class="p">......</span>
	<span class="p">}</span>
<span class="p">......</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">&#34;/sbin/init&#34;</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">&#34;/etc/init&#34;</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">&#34;/bin/init&#34;</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">&#34;/bin/sh&#34;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>run_init_process()的定义：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="nf">run_init_process</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">init_filename</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">argv_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_filename</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">do_execve</span><span class="p">(</span><span class="n">getname_kernel</span><span class="p">(</span><span class="n">init_filename</span><span class="p">),</span>
		<span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">argv_init</span><span class="p">,</span>
		<span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">envp_init</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>以上三段代码说明1号进程运行的是一个文件：
<ul>
<li>在<code>kernel_init</code>函数中调用run_init_process/try_to_run_init_process</li>
<li>在<code>run_init_process</code>函数中调用<code>do_execve</code></li>
<li>do_execve是系统调用<code>execve</code>的实现，作用是运行一个可执行文件</li>
<li>运行的文件是<code>ramdisk的/init</code>，或者普通文件系统上的<code>/sbin/init</code>或<code>/etc/init</code>或<code>/bin/init</code>或<code>/bin/sh</code></li>
<li>不同linux选择不同文件，只要有一个能运行即可</li>
</ul>
</li>
<li>调用链：do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler</li>
<li>调用链中search_binary_handler的定义：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">search_binary_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">......</span>
  <span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
  <span class="p">......</span>
  <span class="n">retval</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">load_binary</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
  <span class="p">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>以上代码说明，要运行程序需要加载其二进制文件。</li>
<li>linux下常用的可执行文件格式是<code>ELF</code>(Executable and Linkable Format)</li>
<li><code>elf_format</code>的定义：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="n">elf_format</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">.</span><span class="n">module</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">.</span><span class="n">load_binary</span>	<span class="o">=</span> <span class="n">load_elf_binary</span><span class="p">,</span>
<span class="p">.</span><span class="n">load_shlib</span>	<span class="o">=</span> <span class="n">load_elf_library</span><span class="p">,</span>
<span class="p">.</span><span class="n">core_dump</span>	<span class="o">=</span> <span class="n">elf_core_dump</span><span class="p">,</span>
<span class="p">.</span><span class="n">min_coredump</span>	<span class="o">=</span> <span class="n">ELF_EXEC_PAGESIZE</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>执行文件时先调用load_elf_binary，最后调用<code>start_thread</code></li>
<li>start_thread的定义：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span>
<span class="nf">start_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_sp</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">set_user_gs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">regs</span><span class="o">-&gt;</span><span class="n">fs</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ds</span>	<span class="o">=</span> <span class="n">__USER_DS</span><span class="p">;</span>
<span class="n">regs</span><span class="o">-&gt;</span><span class="n">es</span>	<span class="o">=</span> <span class="n">__USER_DS</span><span class="p">;</span>
<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ss</span>	<span class="o">=</span> <span class="n">__USER_DS</span><span class="p">;</span>
<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cs</span>	<span class="o">=</span> <span class="n">__USER_CS</span><span class="p">;</span>
<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span>	<span class="o">=</span> <span class="n">new_ip</span><span class="p">;</span>
<span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span>	<span class="o">=</span> <span class="n">new_sp</span><span class="p">;</span>
<span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">X86_EFLAGS_IF</span><span class="p">;</span>
<span class="n">force_iret</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">start_thread</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>上面代码中的struct <code>pt_regs</code>是保存寄存器的结构体</li>
<li>该函数将寄存器中的CS设置为__USER_CS，DS设置为__USER_DS，IP和SP也设置为新的值。即将寄存器设置为用户态（内核中准备好的状态）</li>
<li><code>force_iret()</code>用于从系统调用中返回，此时执行将pt_regs加载到寄存器的工作。因此后面的指令以用户态运行</li>
</ul>
<h3 id="ramdisk的作用">ramdisk的作用</h3>
<ul>
<li>之前的grub.cfg中有一行：initrd16 /boot/initramfs-3.10.0-862.el7.x86_64.img，这是一个<code>基于内存的文件系统</code></li>
<li>1号进程运行的init程序在文件系统上，文件系统在硬盘上，硬盘需要驱动。驱动繁多，不可能都放进内核。但内存不需要驱动，因此需要先使用基于内存的文件系统来存放init程序，这个时候ramdisk是根文件系统</li>
<li>1号进程运行完ramdisk上的/init程序后就处于用户态了。该程序先根据存储系统的类型加载驱动，有了驱动就可设置真正的根文件系统。有了真正的根文件系统，ramdisk上的/init会启动文件系统上的init。然后各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录了。</li>
</ul>
<h3 id="创建2号进程">创建2号进程</h3>
<ul>
<li><code>1号进程是所有用户态进程的祖先，2号进程是所有内核态进程的祖先</code></li>
<li>从内核态来看，无论是<code>进程</code>，还是<code>线程</code>，我们都可以统称为<code>任务</code>，都使用相同的数据结构，平放在同一个链表中</li>
<li>2号进程使用kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)创建</li>
<li><code>kthreadd</code>函数负责所有内核态的线程的调度和管理</li>
</ul>
<h3 id="总结-2">总结</h3>
<ul>
<li>如下图是初始化的总结
<img src="../os_figs/Linux_interest_8_6.jpeg" alt="初始化的总结"></li>
</ul>
<h2 id="09-系统调用公司成立好了就要开始接项目">09-系统调用：公司成立好了就要开始接项目</h2>
<ul>
<li>以glibc中打开文件的open为例来解释系统调用的过程</li>
</ul>
<h3 id="glibc对系统调用的封装">glibc对系统调用的封装</h3>
<ul>
<li>glibc中open函数的声明：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>glibc有一个文件<code>syscalls.list</code>，其中存放glibc的函数对应的系统调用，例如</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-plain" data-lang="plain"># File name	Caller	Syscall name	Args	Strong name	Weak names
accept		-	accept		Ci:iBN	__libc_accept	accept
access		-	access		i:si	__access	access
acct		-	acct		i:S	acct
adjtime		-	adjtime		i:pp	__adjtime	adjtime
......
open		-	open		Ci:siv	__libc_open __open open
......
</code></pre></td></tr></table>
</div>
</div><ul>
<li>glibc还有一个脚本<code>make-syscall.sh</code>，可根据上述配置文件，对于每一个封装好的系统调用生成一个文件，该文件中定义了C语言的宏，例如<code>#define SYSCALL_NAME open</code></li>
<li>glibc还有一个文件<code>syscall-template.S</code>，它使用上面定义的宏来定义这个系统调用的调用方式，例如：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
    ret
T_PSEUDO_END (SYSCALL_SYMBOL)

#define T_PSEUDO(SYMBOL, NAME, N)		PSEUDO (SYMBOL, NAME, N)
</code></pre></td></tr></table>
</div>
</div><ul>
<li>上面代码中的<code>PSEUDO</code>也是宏，定义为：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#define PSEUDO(name, syscall_name, args)                      \
  .text;                                      \
  ENTRY (name)                                    \
    DO_CALL (syscall_name, args);                         \
    cmpl $-4095, %eax;                               \
    jae SYSCALL_ERROR_LABEL
</code></pre></td></tr></table>
</div>
</div><ul>
<li>其中对于任一个系统调用都会调用<code>DO_CALL</code>，它也是一个宏，且32位和64位定义不一样</li>
</ul>
<h3 id="32位系统调用过程">32位系统调用过程</h3>
<ul>
<li>32位的<code>DO_CALL</code>定义于i386目录下的<code>sysdep.h</code>文件：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Linux takes system call arguments in registers:
</span><span class="cm">	syscall number	%eax	     call-clobbered
</span><span class="cm">	arg 1		%ebx	     call-saved
</span><span class="cm">	arg 2		%ecx	     call-clobbered
</span><span class="cm">	arg 3		%edx	     call-clobbered
</span><span class="cm">	arg 4		%esi	     call-saved
</span><span class="cm">	arg 5		%edi	     call-saved
</span><span class="cm">	arg 6		%ebp	     call-saved
</span><span class="cm">......
</span><span class="cm">*/</span>
<span class="cp">#define DO_CALL(syscall_name, args)                           \
</span><span class="cp">    PUSHARGS_##args                               \
</span><span class="cp">    DOARGS_##args                                 \
</span><span class="cp">    movl $SYS_ify (syscall_name), %eax;                          \
</span><span class="cp">    ENTER_KERNEL                                  \
</span><span class="cp">    POPARGS_##args
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如上面注释所说，根据系统调用名称<code>syscall_name</code>得到系统调用号，放在寄存器<code>eax</code>中，各参数也放于寄存器中。然后执行ENTER_KERNEL</li>
<li><code>ENTER_KERNEL</code>的定义是<code># define ENTER_KERNEL int $0x80</code>，即触发一个<code>软中断</code>，通过它来<code>陷入</code>（trap）内核</li>
<li>内核启动时有运行<code>trap_init()</code>初始化中断，其中代码set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32);是一个软中断的<code>陷入门</code>。当接收到系统调用时，<code>entry_INT80_32</code>被调用，在<code>entry_32.S</code>中定义如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ENTRY(entry_INT80_32)
        ASM_CLAC
        pushl   %eax                    /* pt_regs-&gt;orig_ax */
        SAVE_ALL pt_regs_ax=$-ENOSYS    /* save rest */
        movl    %esp, %eax
        call    do_syscall_32_irqs_on
.Lsyscall_32_done:
......
.Lirq_return:
	INTERRUPT_RETURN
</code></pre></td></tr></table>
</div>
</div><ul>
<li>上面的代码通过<code>push</code>和<code>SAVE_ALL</code>将当前用户态的寄存器保存在<code>pt_regs</code>结构里面，然后调用<code>do_syscall_32_irqs_on</code>，其实现如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">do_syscall_32_irqs_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current_thread_info</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">orig_ax</span><span class="p">;</span>
<span class="p">......</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="n">IA32_NR_syscalls</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ia32_sys_call_table</span><span class="p">[</span><span class="n">nr</span><span class="p">](</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">bx</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">si</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">syscall_return_slowpath</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>上面代码将系统调用号从eax（即是orig_ax）中取出，然后在系统调用表<code>ia32_sys_call_table</code>中查找相应函数进行调用。这里的eax和调用的各项参数与前面sysdep.h中（即DO_CALL定义处）的注释一致。</li>
<li>实际上ia32_sys_call_table的定义是#define ia32_sys_call_table sys_call_table，即<code>sys_call_table</code>才是真正的调用表</li>
<li>根据定义#define INTERRUPT_RETURN iret可知，在entry_32.S中，entry_INT80_32之后紧接着调用iret。<code>iret</code>指令将原来用户态保存的现场恢复回来，包括代码段、指令指针寄存器等。这时候用户态进程恢复执行。</li>
<li>如下图是32位系统调用的过程
<img src="../os_figs/Linux_interest_9_1.jpeg" alt="32位系统调用"></li>
</ul>
<h3 id="64位系统调用过程">64位系统调用过程</h3>
<ul>
<li>64位的<code>DO_CALL</code>定义于x86_64目录下的<code>sysdep.h</code>文件：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* The Linux/x86-64 kernel expects the system call parameters in
</span><span class="cm">   registers according to the following table:
</span><span class="cm">    syscall number	rax
</span><span class="cm">    arg 1		rdi
</span><span class="cm">    arg 2		rsi
</span><span class="cm">    arg 3		rdx
</span><span class="cm">    arg 4		r10
</span><span class="cm">    arg 5		r8
</span><span class="cm">    arg 6		r9
</span><span class="cm">......
</span><span class="cm">*/</span>
<span class="cp">#define DO_CALL(syscall_name, args)					      \
</span><span class="cp">  lea SYS_ify (syscall_name), %rax;					      \
</span><span class="cp">  syscall
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>将系统调用名称syscall_name转为调用号放到寄存器rax，但这里用的是真正的调用（<code>syscall</code>指令）而不是中断。另外传递参数的寄存器也不一样了</li>
<li>syscall指令使用了一种特殊的寄存器，<code>特殊模块寄存器</code>（Model Specific Registers，MSR），它们帮助CPU完成某些特殊控制功能（例如系统调用）</li>
<li>系统初始化时，<code>trap_init</code>除了初始化上一节的中断模式外，在这里还会调用cpu_init-&gt;syscall_init，其中有代码：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_LSTAR</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">entry_SYSCALL_64</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>rdmsr</code>和<code>wrmsr</code>用来读写特殊模块寄存器</li>
<li><code>MSR_LSTAR</code>是一种特殊模块寄存器，当<code>syscal</code>指令调用时，会从这个寄存器里取出函数地址来调用。这里是调用<code>entry_SYSCALL_64</code></li>
<li>entry_SYSCALL_64定义于arch/x86/entry/entry_64.S：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ENTRY(entry_SYSCALL_64)
        /* Construct struct pt_regs on stack */
        pushq   $__USER_DS                      /* pt_regs-&gt;ss */
        pushq   PER_CPU_VAR(rsp_scratch)        /* pt_regs-&gt;sp */
        pushq   %r11                            /* pt_regs-&gt;flags */
        pushq   $__USER_CS                      /* pt_regs-&gt;cs */
        pushq   %rcx                            /* pt_regs-&gt;ip */
        pushq   %rax                            /* pt_regs-&gt;orig_ax */
        pushq   %rdi                            /* pt_regs-&gt;di */
        pushq   %rsi                            /* pt_regs-&gt;si */
        pushq   %rdx                            /* pt_regs-&gt;dx */
        pushq   %rcx                            /* pt_regs-&gt;cx */
        pushq   $-ENOSYS                        /* pt_regs-&gt;ax */
        pushq   %r8                             /* pt_regs-&gt;r8 */
        pushq   %r9                             /* pt_regs-&gt;r9 */
        pushq   %r10                            /* pt_regs-&gt;r10 */
        pushq   %r11                            /* pt_regs-&gt;r11 */
        sub     $(6*8), %rsp                    /* pt_regs-&gt;bp, bx, r12-15 not saved */
        movq    PER_CPU_VAR(current_task), %r11
        testl   $_TIF_WORK_SYSCALL_ENTRY|_TIF_ALLWORK_MASK, TASK_TI_flags(%r11)
        jnz     entry_SYSCALL64_slow_path
......
entry_SYSCALL64_slow_path:
        /* IRQs are off. */
        SAVE_EXTRA_REGS
        movq    %rsp, %rdi
        call    do_syscall_64           /* returns with IRQs disabled */
return_from_SYSCALL_64:
	RESTORE_EXTRA_REGS
	TRACE_IRQS_IRETQ
	movq	RCX(%rsp), %rcx
	movq	RIP(%rsp), %r11
    movq	R11(%rsp), %r11
......
syscall_return_via_sysret:
	/* rcx and r11 are already restored (see code above) */
	RESTORE_C_REGS_EXCEPT_RCX_R11
	movq	RSP(%rsp), %rsp
	USERGS_SYSRET64
</code></pre></td></tr></table>
</div>
</div><ul>
<li>上面的代码向pt_regs结构保存了很多寄存器，如用户态的代码段、数据段、保存参数的寄存器，然后调用entry_SYSCALL64_slow_path，在其中再调用do_syscall_64</li>
<li><code>do_syscall_64</code>的定义如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">__visible</span> <span class="kt">void</span> <span class="nf">do_syscall_64</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current_thread_info</span><span class="p">();</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">orig_ax</span><span class="p">;</span>
<span class="p">......</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="n">__SYSCALL_MASK</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NR_syscalls</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ax</span> <span class="o">=</span> <span class="n">sys_call_table</span><span class="p">[</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="n">__SYSCALL_MASK</span><span class="p">](</span>
                        <span class="n">regs</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">si</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">,</span>
                        <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r10</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r8</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r9</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">syscall_return_slowpath</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>如上面代码，在do_syscall_64中，先从rax里面拿出系统调用号，然后根据系统调用号，在系统调用表<code>sys_call_table</code>中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。参数对应的寄存器和sysdep.h文件中的注释一样</li>
<li>在entry_64.S中，64位系统调用返回时，执行<code>USERGS_SYSRET64</code>，它定义为：#define USERGS_SYSRET64 swapgs; sysretq;，因此返回用户态的指令是<code>sysretq</code></li>
<li>如下图是64位系统调用的过程
<img src="../os_figs/Linux_interest_9_2.jpeg" alt="64位系统调用"></li>
</ul>
<h3 id="系统调用表">系统调用表</h3>
<ul>
<li>32位和64位都会使用系统调用表<code>sys_call_table</code></li>
<li>32位系统调用表定义于arch/x86/entry/syscalls/syscall_32.tbl，例如</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-plain" data-lang="plain">......
5	i386	open			sys_open  compat_sys_open
......
</code></pre></td></tr></table>
</div>
</div><ul>
<li>64位系统调用表定义于arch/x86/entry/syscalls/syscall_64.tbl，例如</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-plain" data-lang="plain">......
2	common	open			sys_open
......
</code></pre></td></tr></table>
</div>
</div><ul>
<li>以上两个文件中，第一列数字是系统调用号（同一个调用的32位和64位不同），第三列是系统调用的名字，第四列是系统调用在内核的实现函数，它们都以sys开头</li>
<li>系统调用在内核中的实现经常声明在include/linux/syscalls.h文件中，例如：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
                                <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>系统调用真正的实现一般在c文件中，例如sys_open实现于fs/open.c中：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">open</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">force_o_largefile</span><span class="p">())</span>
                <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_LARGEFILE</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">do_sys_open</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>以上代码看起来很奇怪，主要是SYSCALL_DEFINE3这个宏系统调用，它定义于：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)
</span><span class="cp">#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)
</span><span class="cp">#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)
</span><span class="cp">#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)
</span><span class="cp">#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)
</span><span class="cp">#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)
</span><span class="cp"></span>

<span class="cp">#define SYSCALL_DEFINEx(x, sname, ...)                          \
</span><span class="cp">        SYSCALL_METADATA(sname, x, __VA_ARGS__)                 \
</span><span class="cp">        __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)
</span><span class="cp"></span>

<span class="cp">#define __PROTECT(...) asmlinkage_protect(__VA_ARGS__)
</span><span class="cp">#define __SYSCALL_DEFINEx(x, name, ...)                                 \
</span><span class="cp">        asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       \
</span><span class="cp">                __attribute__((alias(__stringify(SyS##name))));         \
</span><span class="cp">        static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__));  \
</span><span class="cp">        asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__));      \
</span><span class="cp">        asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__))       \
</span><span class="cp">        {                                                               \
</span><span class="cp">                long ret = SYSC##name(__MAP(x,__SC_CAST,__VA_ARGS__));  \
</span><span class="cp">                __MAP(x,__SC_TEST,__VA_ARGS__);                         \
</span><span class="cp">                __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));       \
</span><span class="cp">                return ret;                                             \
</span><span class="cp">        }                                                               \
</span><span class="cp">        static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__)
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>在以上代码中，宏系统调用<code>SYSCALL_DEFINEx</code>最多6个参数，x是参数数量。sys_open定义使用SYSCALL_DEFINE3是因为它有3个参数</li>
<li>若在上面的代码中代入参数x=3，将该宏的实现展开并代入sys_open的实现，得到等价的C语言定义：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
 <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>


 <span class="k">if</span> <span class="p">(</span><span class="n">force_o_largefile</span><span class="p">())</span>
  <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_LARGEFILE</span><span class="p">;</span>


 <span class="n">ret</span> <span class="o">=</span> <span class="n">do_sys_open</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
 <span class="n">asmlinkage_protect</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
 <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>编译sys_open时，需根据<code>syscall_32.tbl</code>和<code>syscall_64.tbl</code>生成自己的<code>unistd_32.h</code>和<code>unistd_64.h</code>。生成方式在arch/x86/entry/syscalls/Makefile</li>
<li>编译时会使用两个脚本：
<ul>
<li>arch/x86/entry/syscalls/syscallhdr.sh，会在文件中生成<code>#define __NR_open</code></li>
<li>arch/x86/entry/syscalls/syscalltbl.sh，会在文件中生成<code>__SYSCALL(__NR_open, sys_open)</code></li>
<li>这样，unistd_32.h和unistd_64.h是sys_open对应的系统调用号和系统调用实现函数之间的对应关系</li>
</ul>
</li>
<li>在文件arch/x86/entry/syscall_32.c中定义了这样一个表，它include了这些系统调用的头文件，因此所有sys_系统调用都在这个表中：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">__visible</span> <span class="k">const</span> <span class="n">sys_call_ptr_t</span> <span class="n">ia32_sys_call_table</span><span class="p">[</span><span class="n">__NR_syscall_compat_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="cm">/*
</span><span class="cm">         * Smells like a compiler bug -- it doesn&#39;t work
</span><span class="cm">         * when the &amp; below is removed.
</span><span class="cm">         */</span>
        <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">__NR_syscall_compat_max</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sys_ni_syscall</span><span class="p">,</span>
<span class="cp">#include</span> <span class="cpf">&lt;asm/syscalls_32.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>在文件arch/x86/entry/syscall_64.c中定义了这样一个表，它include了这些系统调用的头文件，因此所有sys_系统调用都在这个表中：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* System call table for x86-64. */</span>
<span class="n">asmlinkage</span> <span class="k">const</span> <span class="n">sys_call_ptr_t</span> <span class="n">sys_call_table</span><span class="p">[</span><span class="n">__NR_syscall_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/*
</span><span class="cm">	 * Smells like a compiler bug -- it doesn&#39;t work
</span><span class="cm">	 * when the &amp; below is removed.
</span><span class="cm">	 */</span>
	<span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">__NR_syscall_max</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sys_ni_syscall</span><span class="p">,</span>
<span class="cp">#include</span> <span class="cpf">&lt;asm/syscalls_64.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="总结-3">总结</h3>
<ul>
<li>如下图是系统调用的总结
<img src="../os_figs/Linux_interest_9_3.jpeg" alt="系统调用总结"></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">canpi</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-03-24
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_wechat.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/reward_alipay.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">Linux</a>
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
          <a href="/tags/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">趣谈Linux操作系统</a>
          <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E4%B8%93%E6%A0%8F/">极客时间专栏</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/os/linux_interest_10-14/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">（未完成）趣谈Linux操作系统10-14：进程、线程、进程数据结构</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/os/linux_interest_3-5/">
            <span class="next-text nav-default">趣谈Linux操作系统3-5：概述、命令、系统调用</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/os/linux_interest_6-9/" class="leancloud_visitors" data-flag-title="趣谈Linux操作系统6-9：架构、启动、初始化、系统调用">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'ntftaTIdLaT8sVPL9qFX5dAg-gzGzoHsz',
        appKey: 'lNOKznaI2Gnej5D2MgpUJnzV',
        notify:  false ,
        verify:  false ,
        avatar:'retro',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hucanpei@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/hucanpei" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/canpi" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">canpi</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>








</body>
</html>
